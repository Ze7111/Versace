# -*- coding: utf-8 -*-
# THIS FILE WAS GENERATED BY VERSACE 4.0.1
# Versace can be found here: "https://github.com/Ze7111/Versace-Programing-language/"
# Versace Documentation can be found here: "https://dhruvan.gitbook.io/vs/"

# if you want to rebuild Versace, uncomment the following line:
# REBUILD_VERSACE = True

__doc__ = """ ---------------- This is in Markdown format ----------------
----------------------------------------------------------------------------------------------------------------------------------
# Execution Model (Versace)
-------------------------
1. Tokenize
2. Parse
3. Transpile
4. Execute/Compile/Translate

## Tokenize
--------
### The tokenizer in Versace is different from most other languages.
It works by reading all the code from the file as one continuos string without leading/trailing whitespace.
it then reads each character, and if it a part of the alphabet, it will read the next character until it is not unless it starts with (").
it will then merge all the newly read characters into one token(list), and repeat the process until it reaches the end of the file.
It will also look for (;) and if it finds one, it will split that token into two tokens with the first one being the token before the (;) and the second one being the token after the (;).
Finally it will make a nested list of all the tokens, and then move on to the next step.
#### Example of a line getting tokenized:
```
int a = 1;

Stage 1: ['i', 'n', 't', 'a', '=', '1', ';']
Stage 2: [['int', 'a', '=', '1', ';']]
```
- Result: [['int', 'a', '=', '1']]
#### Example of multiple lines getting tokenized:
```
int a = 1;
str b = "hello world";

Stage 1: ['i', 'n', 't', 'a', '=', '1', ';', 's', 't', 'r', 'b', '=', '"', 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd', '"', ';']
Stage 2: [['int', 'a', '=', '1', ';', 'str', 'b', '=', '"hello world"', ';']]
```
- Result: [['int', 'a', '=', '1'], ['str', 'b', '=', '"hello world"']]

Parse
-----
### The parser in Versace is different from most other languages.
It will always check the first word in the token list, and if it is a keyword,
if it is a keyword it will then send that token list to the function that handles that keyword.
if it is not a keyword it will then check if a class with that name exists, and if not it will throw an error.
#### Example of a token getting parsed:
```
['int', 'a', '=', '1']

Stage 1: keyword = 'int'
Stage 2: boolean (does 'int' exist in the keywords list) = True
Stage 3: send token list to the function that handles the 'int' keyword
```
- Result: a: int = 1 (with type checking)

#### Example of multiple tokens getting parsed:
```
[['int', 'a', '=', '1'], ['str', 'b', '=', '"hello world"']]

Stage 1: keyword = 'int'
Stage 2: boolean (does 'int' exist in the keywords list) = True
Stage 3: send token list to the function that handles the 'int' keyword
```
- Result: a: int = 1 (with type checking)

```
Stage 1: keyword = 'str'
Stage 2: boolean (does 'str' exist in the keywords list) = True
Stage 3: send token list to the function that handles the 'str' keyword
```
- Result: b: str = "hello world" (with type checking)

## Parse Tree:
### All the keywords currently in Versace:
1. 'public'
1. 'priv'
1. 'method'
1. 'with'
1. 'call'
1. 'if'
1. 'else'
1. 'else if'
1. 'for'
1. 'while'
1. 'return'
1. 'class'
1. 'struct'
1. 'static'
1. 'enum'
1. 'ptr'
1. 'func'
1. 'async'
1. 'await'
1. 'coroutine'
1. 'const'
1. 'ref'
1. 'copy'
1. 'let'
1. 'final'
1. 'rem'
1. 'type'
1. 'out'
1. 'in'
1. 'include'
1. 'import'
1. 'from'
1. 'pyc'

- Data Types:
1. 'int'
1. 'float'
1. 'complex'
1. 'double'
1. 'str'
1. 'usize'
1. 'bool'
1. 'list'
1. 'map'
1. 'array'
1. 'set'
1. 'bytes'
1. 'object'
1. 'char'
1. 'self'
1. 'super'
1. 'memoryview'
1. 'bytearray'
1. 'frozenset'
1. 'range'
1. 'None'
1. 'NoneType'

- Kernel Types:
1. 'u8'
1. 'u16'
1. 'u32'
1. 'u64'
1. 'u128'
1. 'i8'
1. 'i16'
1. 'i32'
1. 'i64'
1. 'i128'
1. 'f32'
1. 'f64'

## Transpile
---------
### The transpiler in Versace is different from most other languages.
It will work by taking the parse tree and converting it into a string of python code.
It will then write that string to a file and then run it using the python interpreter.
#### Example of a parse tree getting transpiled:
```
a: int = 1
Stage 1: check if 'a' is a variable, if yes throw an error as we tried to declare a variable that already exists without using the `let` keyword
Stage 2: check if 'a' is a variable, if no, check if '1' matches the type of 'int'
Stage 3: check if '1' is a variable, if yes, get the type of '1' and check if it matches the type of 'int'
Stage 4: repeat stage 3 until it reaches the end of the parse tree
```

- Result: a: int = 1 # the : int means we are declaring a variable with the type of int, and not assigning a already existing variable

## Execute/Compile/Translate
-------------------------
### The execution stage in Versace is different from most other languages.
It will work by taking the transpiled code and running it using the python interpreter (with the extra lines in the code, to make it execute a lot faster).
It will securely run the code using the python interpreter, and then print the output (Versace uses `subprocess` to run the code on any platform, and uses `_winapi` to run the code on windows).
The code will be run in a separate process, and will not be able to access any program in the main process (unless specified).

### The compiler stage in Versace is different from most other languages.
The Versace compiler uses `pyinstaller` to compile the code into a .exe file. Or cx_freeze to compile the code into a .exe file.
The compiler takes the transpiled code and executes a `pyinstaller/cx_freeze` command in a separate process (hence why you see a loading bar and not the raw output of the command).
If the compilation is successful, it will then move the .exe file to the directory of the Versace file.
If the compilation is not successful, it will then print the error message and delete any files that were created during the compilation process.

### The translator stage works in the following way.
It will save the transpiled code to a file.

----------------------------------------------------------------------------------------------------------------------------------

This is the Source code for the Versace programming language.
This code does kinda not follow PEP8, but it is still readable and understandable.
A lot of code is not commented, but it is still understandable.
Most functions and classes have docstring.

For more information about Versace, please visit the Versace documentation at
https://dhruvan.gitbook.io/vs/

FSTAB: TYPE-ANNOTATIONS USED IN THIS FILE
"""

VERSION: str = '4.0.1'
ALLOW_PYTHONIC_SYNTAX: bool = True  # do not change this, unless you know exactly what you are doing.

def GET_OS() -> str and bool:
    """Get the operating system"""
    try:
        import msvcrt
        WINDOWS = True
        OS = 'nt' # noqa: F841
        del msvcrt
    except ImportError:
        WINDOWS = False
        OS = 'posix'
    return (WINDOWS, OS)
WINDOWS, OS = GET_OS()

if WINDOWS:
    import _winapi
    from sys import exit
    from io import StringIO
    from pickle import dumps
    from time import strftime
    from textwrap import wrap
    from copy import deepcopy
    from re import search, sub
    from functools import wraps
    from typing import Callable
    from ast import literal_eval
    from threading import Thread
    from time import perf_counter
    from time import sleep as wait
    from tempfile import gettempdir
    from os import get_terminal_size
    from os import stat as temp_stat
    from os import system as _system
    from emojis import EMOJI_UNICODE
    from time import time as get_time
    from types import MappingProxyType
    from collections import OrderedDict
    from sys import path as SYS_PATH
    from subprocess import run as execute
    from contextlib import redirect_stdout
    from sys import executable as PYTHON_PATH
    from sys import stdout, argv, setrecursionlimit
    from ctypes import windll, create_unicode_buffer
    from subprocess import call as execute_no_output
    from subprocess import check_call, DEVNULL, STDOUT
    from string import ascii_letters, digits, punctuation, whitespace
else:
    from io import StringIO
    from pickle import dumps
    from time import strftime
    from textwrap import wrap
    from copy import deepcopy
    from re import search, sub
    from functools import wraps
    from typing import Callable
    from ast import literal_eval
    from threading import Thread
    from time import perf_counter
    from time import sleep as wait
    from tempfile import gettempdir
    from os import get_terminal_size
    from emojis import EMOJI_UNICODE
    from os import system as _system
    from time import time as get_time
    from types import MappingProxyType
    from collections import OrderedDict
    from sys import path as SYS_PATH
    from subprocess import run as execute
    from contextlib import redirect_stdout
    from sys import executable as PYTHON_PATH
    from sys import stdout, argv, setrecursionlimit
    from subprocess import call as execute_no_output
    from subprocess import check_call, DEVNULL, STDOUT
    from string import ascii_letters, digits, punctuation, whitespace

# ----------------------- Single Speed up Wrapper ----------------------- #
def ASYNC(func):
    """ This is a decorator for async functions """
    def ASYNC__FUNCTION(*args, **kwargs):
        """ This is the wrapper function that will be returned """
        thread = Thread(target=func, args=args, kwargs=kwargs)
        thread.start()
        return thread
    return ASYNC__FUNCTION

#_winapi.WaitForSingleObject = ASYNC(_winapi.WaitForSingleObject)
if WINDOWS:
    _winapi.WaitForSingleObject = lambda handle, timeout: _winapi.WaitForMultipleObjects((handle,), 0, +int(timeout / 1000))


if WINDOWS:
    class _CImplementation:
        """
        This class remakes, most of the slower items implemented by the os, sys module to work much quicker.
        This class is only used on windows.
        Sub-classes:
            error : raise an error
            enable_color : enable color in the console
            console : call the windows console with a command
            std_out : print to the console
            path_exists : check if a path exists
            get_file_size : get the size of a file
            base_name : get the base name of a path
            join_path : join two paths
            list_dir : list the files in a directory
            get_user_dir : get the user directory
            make_dirs : make a directory
            del_file : delete a file
            del_dir_and_files : delete a directory and all of its files
            make_dir : make a directory
            change_dir : change the current directory
            get_c_dir : get the current directory
            move_file : move a file

        """
        sep = str('\\')
        path_exists_cache = dict()
        get_file_size_cache = dict()
        get_user_dir_cache = str()
        get_c_dir_cache = str()
        std_out_cache = dict()
        list_dir_cache = dict()
        absolute_path_cache = dict()
        base_name_cache = dict()
        join_path_cache = dict()
        is_venv_cache = None
        setrecursionlimit(100000)
        def error(self, error_type: str, message: str):
            self.enable_color()
            print(f"\033[1;31m{error_type}: " + "\033[1;39m\"" + message + "\" \033[0m")
            exit()
        def __init__(self, *args, **kwargs):
            self.args = args
            self.kwargs = kwargs
        @ASYNC
        def enable_color(self) -> None:
            windll.kernel32.SetConsoleMode(windll.kernel32.GetStdHandle(-11), 7)
        @ASYNC
        def console(self, command: str) -> None:
            # create a custom console function for windows
            # call the windows console with the command
            if command == '': self.enable_color(); return
            buff: object = create_unicode_buffer(300)
            windll.kernel32.GetEnvironmentVariableW('COMSPEC', buff, 300)
            command = f"{buff.value} /c {command}"
            windll.kernel32.WinExec(command, 1)
        def path_exists(self, NON_SYS_PATH: str) -> bool:
            from os import path as _path
            if NON_SYS_PATH in self.path_exists_cache:
                return self.path_exists_cache[NON_SYS_PATH]
            if _path.exists(NON_SYS_PATH):
                self.path_exists_cache[NON_SYS_PATH] = True
                return True
            else:
                self.path_exists_cache[NON_SYS_PATH] = False
                return False

        def get_file_size(self, NON_SYS_PATH: str) -> int:
            if NON_SYS_PATH in self.get_file_size_cache:
                return self.get_file_size_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                buf: object = create_unicode_buffer(300)
                windll.kernel32.GetFullPathNameW(NON_SYS_PATH, 300, buf, None)
                NON_SYS_PATH = buf.value
                size: int = temp_stat(NON_SYS_PATH).st_size
                self.get_file_size_cache[NON_SYS_PATH] = size
                return size
            else:
                self.error("File not found", f"{NON_SYS_PATH}")
        def absolute_path(self, NON_SYS_PATH: str) -> str:
            if NON_SYS_PATH in self.absolute_path_cache:
                return self.absolute_path_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                buf: object = create_unicode_buffer(300)
                windll.kernel32.GetFullPathNameW(NON_SYS_PATH, 300, buf, None)
                NON_SYS_PATH = buf.value
                self.absolute_path_cache[NON_SYS_PATH] = NON_SYS_PATH
                return NON_SYS_PATH
            else:
                self.error("File not found", f"{NON_SYS_PATH}")
        def base_name(self, NON_SYS_PATH: str) -> str:
            if NON_SYS_PATH == '-d' or NON_SYS_PATH == '--debug': return 'None'
            if NON_SYS_PATH in self.base_name_cache:
                return self.base_name_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                buf: object = create_unicode_buffer(300)
                windll.kernel32.GetFullPathNameW(NON_SYS_PATH, 300, buf, None)
                NON_SYS_PATH = buf.value
                self.base_name_cache[NON_SYS_PATH] = NON_SYS_PATH.split('\\')[-1]
                return NON_SYS_PATH.split('\\')[-1]
            else:
                self.error("File not found", f"{NON_SYS_PATH}")
        def join_path(self, *args) -> str:
            if args in self.join_path_cache:
                return self.join_path_cache[args]
            self.join_path_cache[args] = self.sep.join(args)
            return self.sep.join(args)
        def list_dir(self, NON_SYS_PATH: str) -> list:
            if NON_SYS_PATH in self.list_dir_cache:
                return self.list_dir_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                buf: object = create_unicode_buffer(300)
                windll.kernel32.GetFullPathNameW(NON_SYS_PATH, 300, buf, None)
                NON_SYS_PATH = buf.value
                self.list_dir_cache[NON_SYS_PATH] = [f for f in NON_SYS_PATH.split('\\') if f != '']
                return [f for f in NON_SYS_PATH.split('\\') if f != '']
            else:
                self.error("FileNotFoundError", f"Directory not found: {NON_SYS_PATH}")
        def get_user_dir(self) -> str:
            if self.get_user_dir_cache != '':
                return self.get_user_dir_cache
            from os import path as os_path
            self.get_user_dir_cache = os_path.expanduser('~')
            return os_path.expanduser('~')
        @ASYNC
        def make_dirs(self, NON_SYS_PATH: str, exist_ok: bool = False) -> None:
            if not self.path_exists(NON_SYS_PATH):
                windll.kernel32.CreateDirectoryW(NON_SYS_PATH, None)
            else:
                if exist_ok:
                    return
                self.error("FileExistsError", f"File or directory already exists: {NON_SYS_PATH}")
            return
        @ASYNC
        def del_file(self, NON_SYS_PATH: str) -> None:
            if self.path_exists(NON_SYS_PATH):
                windll.kernel32.DeleteFileW(NON_SYS_PATH)
            return
        @ASYNC
        def del_dir_and_files(self, NON_SYS_PATH: str) -> None:
            if self.path_exists(NON_SYS_PATH):
                windll.kernel32.RemoveDirectoryW(NON_SYS_PATH)
            return
        def make_dir(self, NON_SYS_PATH: str, exist_ok: bool = False) -> None:
            if not self.path_exists(NON_SYS_PATH):
                windll.kernel32.CreateDirectoryW(NON_SYS_PATH, None)
            else:
                if exist_ok:
                    return
                self.error("DirExistsError", f"File or directory already exists: {NON_SYS_PATH}")
            return
        @ASYNC
        def change_dir(self, NON_SYS_PATH: str) -> None:
            if self.path_exists(NON_SYS_PATH):
                windll.kernel32.SetCurrentDirectoryW(NON_SYS_PATH)
            return
        def get_c_dir(self) -> str:
            if self.get_c_dir_cache != '':
                return self.get_c_dir_cache
            buf: object = create_unicode_buffer(300)
            windll.kernel32.GetCurrentDirectoryW(300, buf)
            self.get_c_dir_cache = buf.value
            return buf.value
        @ASYNC
        def move_file(self, src: str, dst: str) -> None:
            if self.path_exists(src):
                windll.kernel32.MoveFileW(src, dst)
            return
        def is_venv(self) -> bool:
            if self.is_venv_cache != '':
                return self.is_venv_cache
            from os import path as os_path
            from sys import executable as sys_executable
            self.is_venv_cache = os_path.basename(os_path.dirname(os_path.dirname(sys_executable))) == 'env'
            return os_path.basename(os_path.dirname(os_path.dirname(sys_executable))) == 'env'
else:
    import os; import shutil
    os.system("")
    #print("\033[91m[NON-CRITICAL]\033[93m This operating system is not supported properly as of now. Please use Windows only for the time being.\033[0m")
    class _CImplementation:
        __doc__ = """
        This class remakes, most of the slower items implemented by the os, sys module to work much quicker.
        This class is only used on Linux/MacOS.
        Sub-classes:
            error : raise an error
            enable_color : enable color in the console
            console : call the windows console with a command
            std_out : print to the console
            path_exists : check if a path exists
            get_file_size : get the size of a file
            base_name : get the base name of a path
            join_path : join two paths
            list_dir : list the files in a directory
            get_user_dir : get the user directory
            make_dirs : make a directory
            del_file : delete a file
            del_dir_and_files : delete a directory and all of its files
            make_dir : make a directory
            change_dir : change the current directory
            get_c_dir : get the current directory
            move_file : move a file

        """
        sep: str = '/'
        get_file_size_cache: dict = {}
        absolute_path_cache: dict = {}
        base_name_cache: dict = {}
        join_path_cache: dict = {}
        list_dir_cache: dict = {}
        get_user_dir_cache: str = ''
        get_c_dir_cache: str = ''
        is_venv_cache: bool = bool()
        setrecursionlimit(100000)
        def error(self, error_type: str, message: str):
            self.enable_color()
            print(f"\033[1;31m{error_type}: \033[1;39m\'" + message + "\'\033[0m")
            exit()
        def enable_color(self) -> None:
            os.system('')
        def path_exists(self, NON_SYS_PATH: str) -> bool:
            return os.path.exists(NON_SYS_PATH)
        def get_file_size(self, NON_SYS_PATH: str) -> int:
            if NON_SYS_PATH in self.get_file_size_cache:
                return self.get_file_size_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                from os import stat as os_v_stat
                size: int = os_v_stat(NON_SYS_PATH).st_size
                self.get_file_size_cache[NON_SYS_PATH] = size
                return size
            else:
                self.error("File not found", f"{NON_SYS_PATH}")
        def console(self, text: str) -> None:
            os.system(text)
            return
        def make_dirs(self, NON_SYS_PATH: str, exist_ok: bool = False) -> None:
            if not self.path_exists(NON_SYS_PATH):
                os.makedirs(NON_SYS_PATH)
            else:
                if exist_ok:
                    return
                self.error("FileExistsError", f"File or directory already exists: {NON_SYS_PATH}")
            return
        def absolute_path(self, NON_SYS_PATH: str) -> str:
            if NON_SYS_PATH in self.absolute_path_cache:
                return self.absolute_path_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                NON_SYS_PATH = os.path.abspath(NON_SYS_PATH)
                self.absolute_path_cache[NON_SYS_PATH] = NON_SYS_PATH
                return NON_SYS_PATH
            else:
                self.error("File not found", f"{NON_SYS_PATH}")
        def base_name(self, NON_SYS_PATH: str) -> str:
            if NON_SYS_PATH in self.base_name_cache:
                return self.base_name_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                NON_SYS_PATH = os.path.basename(NON_SYS_PATH)
                self.base_name_cache[NON_SYS_PATH] = NON_SYS_PATH
                return NON_SYS_PATH
            else:
                self.error("File not found", f"{NON_SYS_PATH}")
        def join_path(self, *args) -> str:
            if args in self.join_path_cache:
                return self.join_path_cache[args]
            self.join_path_cache[args] = self.sep.join(args)
            return self.sep.join(args)
        def list_dir(self, NON_SYS_PATH: str) -> list:
            if str(NON_SYS_PATH) in self.list_dir_cache:
                return self.list_dir_cache[str(NON_SYS_PATH)]
            if self.path_exists(NON_SYS_PATH):
                NON_SYS_PATH = os.listdir(NON_SYS_PATH)
                self.list_dir_cache[str(NON_SYS_PATH)] = str(NON_SYS_PATH)
                return NON_SYS_PATH
            else:
                self.error("FileNotFoundError", f"Directory not found: {NON_SYS_PATH}")
        def get_user_dir(self) -> str:
            if self.get_user_dir_cache != '':
                return self.get_user_dir_cache
            self.get_user_dir_cache = os.path.expanduser("~")
            return os.path.expanduser("~")
        def get_c_dir(self) -> str:
            if self.get_c_dir_cache != '':
                return self.get_c_dir_cache
            self.get_c_dir_cache = os.getcwd()
            return os.getcwd()
        def change_dir(self, NON_SYS_PATH: str) -> None:
            if self.path_exists(NON_SYS_PATH):
                os.chdir(NON_SYS_PATH)
            return
        def make_dir(self, NON_SYS_PATH: str, exist_ok: bool = False) -> None:
            if not self.path_exists(NON_SYS_PATH):
                os.mkdir(NON_SYS_PATH)
            else:
                if exist_ok:
                    return
                self.error("FileExistsError", f"File or directory already exists: {NON_SYS_PATH}")
            return
        def del_file(self, NON_SYS_PATH: str) -> None:
            if self.path_exists(NON_SYS_PATH):
                os.remove(NON_SYS_PATH)
            return
        def move_file(self, src: str, dst: str) -> None:
            if self.path_exists(src):
                os.rename(src, dst)
            return
        def del_dir_and_files(self, NON_SYS_PATH: str) -> None:
            if self.path_exists(NON_SYS_PATH):
                shutil.rmtree(NON_SYS_PATH)
        def is_venv(self) -> bool:
            if self.is_venv_cache != None:
                return self.is_venv_cache
            self.is_venv_cache = hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix)
            return self.is_venv_cache
SYSTEM: object = _CImplementation()

# ----------------------------- BUILT-IN FUNCTIONS ----------------------------- #
path_sep: object = SYSTEM.sep
@ASYNC
def remove(NON_SYS_PATH: str) -> None:
    SYSTEM.del_file(NON_SYS_PATH)
def v_stat(NON_SYS_PATH: str) -> int:
    return SYSTEM.get_file_size(NON_SYS_PATH)
@ASYNC
def console(*args, **kwargs) -> None:
    SYSTEM.console(*args, **kwargs)
    return
def listdir(NON_SYS_PATH: str) -> list:
    return SYSTEM.list_dir(NON_SYS_PATH)
@ASYNC
def rmtree(NON_SYS_PATH: str) -> None:
    SYSTEM.del_dir_and_files(NON_SYS_PATH)
@ASYNC
def move(src: str, dst: str) -> None:
    SYSTEM.move_file(src, dst)
class path:
    abspath: object = SYSTEM.absolute_path
    basename: object = SYSTEM.base_name
    join: object = SYSTEM.join_path
_MAP_: MappingProxyType = MappingProxyType
COLOR_SUPPORT = stdout.isatty()
PASS_LIST = argv.copy()[1:]
DEBUG_DATA: list[str] = []*100
COLORS: MappingProxyType[str, str] = {
    'bold red' : '\033[1;31m' if COLOR_SUPPORT else '',
    'bold green' : '\033[1;32m' if COLOR_SUPPORT else '',
    'bold yellow' : '\033[1;33m' if COLOR_SUPPORT else '',
    'bold blue' : '\033[1;34m' if COLOR_SUPPORT else '',
    'bold magenta' : '\033[1;35m' if COLOR_SUPPORT else '',
    'bold cyan' : '\033[1;36m' if COLOR_SUPPORT else '',
    'bold white' : '\033[1;37m' if COLOR_SUPPORT else '',

    'red' : '\033[91m' if COLOR_SUPPORT else '',
    'green' : '\033[92m' if COLOR_SUPPORT else '',
    'yellow' : '\033[93m' if COLOR_SUPPORT else '',
    'blue' : '\033[94m' if COLOR_SUPPORT else '',
    'magenta' : '\033[95m' if COLOR_SUPPORT else '',
    'cyan' : '\033[96m' if COLOR_SUPPORT else '',
    'white' : '\033[0m' if COLOR_SUPPORT else '',
    'grey' : '\033[90m' if COLOR_SUPPORT else '',

    'dim green' : '\033[32m' if COLOR_SUPPORT else '',

    'underline' : '\033[4m' if COLOR_SUPPORT else '',
    'italic' : '\033[3m' if COLOR_SUPPORT else '',
    'blink' : '\033[5m' if COLOR_SUPPORT else '',
    'reverse' : '\033[7m' if COLOR_SUPPORT else '',
    'reset' : '\033[0m' if COLOR_SUPPORT else '',
    }
base_print = print
print = base_print

# ------------------------------------- Check for python path ------------------------------------- #
if SYSTEM.path_exists(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + "ABS-Path.path"):
    with open(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + "ABS-Path.path", "rb") as f:
        ORG_PYTHON_PATH = f.readlines()[1].decode("utf-32-le").strip()
else:
    if not SYSTEM.path_exists(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + "ABS-Path.py"):
        if not SYSTEM.path_exists(SYSTEM.get_user_dir() + path_sep + '.versace'):
            SYSTEM.make_dir(SYSTEM.get_user_dir() + path_sep + '.versace')
        with open(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + "ABS-Path.py", "w") as f:
            f.write("""import os, sys
with open(os.path.expanduser('~') + os.sep + ".versace" + os.sep + "ABS-Path.path", "wb") as f:
    f.write("DO NOT EDIT/DELETE THIS FILE IT IS MANDATORY FOR VERSACE TO RUN\\n".encode("utf-8"))
    f.write(sys.executable.encode("utf-32-le"))""")
    try:
        execute(["python", SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + "ABS-Path.py"], stdout=DEVNULL, stderr=STDOUT, check=True)
    except:
        sysexec = 'python' if WINDOWS else 'python3'
        print(f"ERROR: ABS-Path.py not found. Please reinstall Versace. Or run this file manually: {sysexec} \"{SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + 'ABS-Path.py'}\"")
        exit()
    if SYSTEM.path_exists(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + "ABS-Path.path") is False:
        execute(["python3", SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + "ABS-Path.py"], stdout=DEVNULL, stderr=STDOUT, check=True)
        if SYSTEM.path_exists(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + "ABS-Path.path") is False:
            print(f"ERROR: ABS-Path.rf not found. Please reinstall Versace. Or run this file manually: \"{SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + 'ABS-Path.py'}\"")
            exit()
    if SYSTEM.path_exists(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + "ABS-Path.path"):
        with open(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + "ABS-Path.path", "rb") as f:
            ORG_PYTHON_PATH = f.readlines()[1].decode("utf-32-le").strip()
PYTHON_PATH: str = ORG_PYTHON_PATH

# ------------------------ Package Handler ------------------------ #
def PACKAGE_HANDLING(arguments) -> None:
    execute([PYTHON_PATH, 'vPackageHandler.py'] + arguments)
    return
if 'install' in PASS_LIST or '--install' in PASS_LIST:
        PACKAGE_HANDLING(['-i', PASS_LIST[PASS_LIST.index('install') + 1]])
        exit()
if 'uninstall' in PASS_LIST or '--uninstall' in PASS_LIST:
    PACKAGE_HANDLING(['-u', PASS_LIST[PASS_LIST.index('uninstall') + 1]])
    exit()
def INITIALIZE_NEW_PROJECT() -> None:
    global FILE_PATH, PASS_LIST
    print(f"{COLORS['yellow']}Creating new project...{COLORS['reset']}")
    try:
        # create a new folder with the name of the file if a file name with extension is provided else create a folder with the name of the file name
        SYSTEM.make_dir(PASS_LIST[1].split('.')[0])
        FILE_PATH = PASS_LIST[1].split('.')[0] + path_sep + PASS_LIST[1].split('.')[0] + '.v'
        PROJECT_NAME = PASS_LIST[1].split('.')[0]
        PASS_LIST[0] = PASS_LIST[1].split('.')[0] + path_sep + PASS_LIST[1].split('.')[0] + '.v'
    except:
        print(f"{COLORS['red']}ERROR: No file/folder name provided.{COLORS['reset']}")
        exit()
    with open(FILE_PATH, 'w', encoding='utf-8') as f:
        f.write('include "std.v";\n')
        f.write('include "colors.v";\n')
        f.write('include "system.v";\n')
        f.write('include "math.v";\n')
        f.write('include "styles.v";\n')
        f.write('include "strings.v";\n\n')
        f.write('public main() {\n    out << "hello world"; // prints hello world\n}\n')
    print(f"{COLORS['green']}Project created successfully.{COLORS['reset']}")
    print(f"{COLORS['green']}run {COLORS['yellow']}'cd {PROJECT_NAME}'{COLORS['green']} to change directory to the project folder.{COLORS['reset']}")

if 'new' in PASS_LIST or '--new' in PASS_LIST:
    INITIALIZE_NEW_PROJECT()
if '-w' in PASS_LIST or '--watch' in PASS_LIST:
    # run the command watch in the terminal
    from subprocess import run as Popen
    from sys import executable
    #print(['watch', executable, __file__] + PASS_LIST)
    import os
    if __file__.endswith('.py'):
        watch_ps1 = os.path.join(os.path.dirname(__file__), 'watch.bat')
        PASS_LIST.remove("-w")
        if len(PASS_LIST) > 2: print("Too many arguments provided.")
        print(f'{watch_ps1} "{" ".join(PASS_LIST)}"', flush=True)
        os.system(f'{watch_ps1} "{" ".join(PASS_LIST)}"')
        #Popen(['watch.bat', executable, __file__] + PASS_LIST)
        exit()
    else:
        #Popen(['watch.bat', executable] + PASS_LIST)
        exit()

class GLOBAL_VARIABLES():
    __doc__ = """
    This class is used to store global variables used by Versace.
    """
    ALL_PYTHON_KEYWORDS: tuple[str, ...] = (
        'yield', 'in', 'is', 'not', 'and', 'or', 'True', 'False', 'None', 'async', 'cls'
        'return', 'break', 'continue', 'pass', 'from', 'nonlocal', 'lambda', 'try',
        'from', 'nonlocal', 'self', 'super', 'assert', 'with', 'await', 'finally',
    )
    NON_NORMAL_CHARS: tuple[str, ...] = (
        '*', '!', '(', ')' , '-', '+',
        ',', '.', '<', '>' , '/', '?',
        ' ', '@', '#', '$' , '%', '^',
        '=', '[', ']', '{' , '}', ';',
        '`', '~', '|', '\\', ':', '&',
    )
    DATA_TYPES: tuple[str, ...] = (
        'array', 'int', 'float', 'complex', 'double', 'str', 'usize', 'bool',
        'map','tuple','set','bytes','char','memoryview','bytearray', 'list',
        'frozenset', 'range', 'nullType', 'object', 'u8', 'u16', 'u32', 'u64',
        'u128', 'i8', 'i16', 'i32', 'i64', 'i128', 'f32', 'f64', 'bin', 'hex',
        'oct'
    )
    END_TYPES: MappingProxyType[str, str] = _MAP_(
        {
            'newl' : r'\n\n',
            'tab' : r'\t',
            'rw' : r'\r',
            'space' : r' ',
            'endl' : r'',
            'erase' : r'\x1b[2K',
        }
    )
    JUSTIFY_TYPES: tuple[str, ...] = (
        'left',
        'right',
        'center',
        'justify',
    )
    COLOR_TYPES: tuple[str, ...] = (
    # primitive colors
        'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white', 'black', 'bold_red', 'bright_red', 'bright_green',
        'bold_green', 'bold_yellow', 'bold_blue', 'bold_magenta', 'bold_cyan', 'bold_white', 'bold_black',
        'bright_yellow', 'bright_blue', 'bright_magenta', 'bright_cyan', 'bright_white', 'bright_black',
    # 256 colors
        'black', 'red', 'green', 'yellow', 'blue', 'magenta',
        'cyan', 'white', 'bright_black', 'bright_red',
        'bright_yellow', 'bright_blue', 'bright_magenta',
        'bright_cyan', 'bright_white', 'grey0', 'navy_blue',
        'dark_blue', 'blue3', 'blue1', 'dark_green', 'bright_green',
        'deep_sky_blue4', 'dodger_blue3', 'dodger_blue2',
        'green4', 'spring_green4', 'turquoise4', 'deep_sky_blue3',
        'dodger_blue1', 'dark_cyan', 'light_sea_green', 'deep_sky_blue2',
        'deep_sky_blue1', 'green3', 'spring_green3', 'cyan3',
        'dark_turquoise', 'turquoise2', 'green1', 'spring_green2',
        'spring_green1', 'medium_spring_green', 'cyan2',
        'cyan1', 'purple4', 'purple3', 'blue_violet', 'grey37',
        'medium_purple4', 'slate_blue3', 'royal_blue1', 'chartreuse4',
        'steel_blue3', 'cornflower_blue', 'dark_sea_green4',
        'cadet_blue', 'sky_blue3', 'chartreuse3', 'sea_green3',
        'aquamarine3', 'medium_turquoise', 'steel_blue1', 'sea_green2',
        'sea_green1', 'dark_slate_gray2', 'dark_red', 'dark_magenta',
        'orange4', 'light_pink4', 'plum4', 'medium_purple3', 'slate_blue1',
        'wheat4', 'grey53', 'pale_turquoise4', 'steel_blue',
        'light_slate_grey', 'medium_purple', 'light_slate_blue',
        'yellow4', 'dark_sea_green', 'light_sky_blue3', 'sky_blue2',
        'chartreuse2', 'pale_green3', 'dark_slate_gray3', 'sky_blue1',
        'chartreuse1', 'light_green', 'aquamarine1', 'dark_slate_gray1',
        'deep_pink4', 'medium_violet_red', 'dark_violet', 'purple',
        'medium_orchid3', 'medium_orchid', 'dark_goldenrod',
        'rosy_brown', 'grey63', 'medium_purple2', 'medium_purple1',
        'dark_khaki', 'navajo_white3', 'grey69', 'light_steel_blue3',
        'light_steel_blue', 'dark_olive_green3', 'dark_sea_green3',
        'light_cyan3', 'light_sky_blue1', 'green_yellow',  'gold3',
        'dark_olive_green2', 'pale_green1', 'dark_sea_green2',
        'pale_turquoise1', 'red3', 'deep_pink3', 'magenta3', 'dark_orange3',
        'indian_red', 'hot_pink3', 'hot_pink2', 'orchid', 'orange3',
        'light_salmon3', 'light_pink3', 'pink3', 'plum3', 'violet',
        'light_goldenrod3', 'tan', 'misty_rose3', 'thistle3', 'plum2',
        'yellow3', 'khaki3', 'light_yellow3', 'grey84', 'light_steel_blue1',
        'dark_olive_green1', 'dark_sea_green1', 'honeydew2', 'yellow2',
        'light_cyan1', 'red1', 'deep_pink2', 'deep_pink1', 'khaki1',
        'magenta2', 'magenta1', 'orange_red1', 'indian_red1',
        'hot_pink', 'medium_orchid1', 'dark_orange', 'salmon1',
        'light_coral', 'pale_violet_red1', 'orchid2', 'orchid1',
        'orange1', 'sandy_brown', 'light_salmon1', 'light_goldenrod1',
        'light_pink1', 'pink1', 'plum1', 'gold1', 'light_goldenrod2',
        'navajo_white1', 'misty_rose1', 'thistle1', 'yellow1',
        'wheat1', 'cornsilk1', 'grey100', 'grey3', 'grey7',
        'grey15', 'grey19', 'grey23', 'grey27', 'grey30',
        'grey35', 'grey39', 'grey42', 'grey46', 'grey50',
        'grey54', 'grey58', 'grey62', 'grey66', 'grey70',
        'grey74', 'light_goldenrod1', 'khaki1', 'grey11',
        'grey78', 'grey82', 'grey85', 'grey89', 'grey93'
    )
    STYLE_TYPES: tuple[str, ...] = (
        'bold',
        'dim',
        'italic',
        'underline',
        'blink',
        'reverse',
        'hidden',
        'strike',
    )
    RESERVED_WORDS: tuple[str, ...] = (
        'if', 'else if', 'else', 'for', 'while', 'func', 'public', 'async', 'try', 'catch', 'finally',
        'class', 'include', 'from', 'const', 'out', 'in', 'stop', 'throw', 'null', 'True', 'static', 'hex',
        'self', 'super', 'struct', 'enum', 'False', 'set', 'frozenset', 'map', 'list', 'tuple', 'pack', 'oct',
        'unpack', 'range', 'bytearray', 'memoryview', 'bytes', 'char', 'str', 'double', 'complex', 'float', 'int',
        'bool', 'usize', 'array', 'arr', 'nullType', 'print', 'input', 'pyc', 'exec', 'malloc', 'free', 'exit', 'bin'
    )
    OPTIONAL_ARGS_ALLOWED: tuple[str, ...] = (
        r'-*- no types -*-',
        r'-*- no color -*-',
        r'-*- no indent -*-',
        r'-*- no main -*-',
        r'-*- no newline -*-',
        r'-*- py -*-',
        r'-*- cache -*-',
        r'-*- exec -*-',
        r'-*- all errors -*-',
    )
    CHANGE_WORDS: MappingProxyType[str, str] = _MAP_(
        {
            'null'     : 'None',
            'true'     : 'True',
            'false'    : 'False',
            'nullType' : 'NoneType',
            'catch'    : 'except',
            'throw'    : 'raise',
            'NULL'     : 'None',
            'null'     : 'None',
            'NULLTYPE' : 'NoneType',
            'NONE'     : 'None',
            'NONETYPE' : 'NoneType',
            '~'        : '*',
            '~~'       : '**',
            'invert'   : 'reversed',
            'double'   : 'float',
            'char'     : 'str',
            '&&'       : 'and',
            '||'       : 'or',
            'repr'     : '__init__',
            'constructor' : '__init__',
            'destructor'  : '__del__',
            '...'      : 'pass',
        }
    )
    OPERATORS: tuple[str, ...] = (
        '<', '>', '=', '!', '+', '-', '*', '/', '%',
        '^', '&', '|', '>>', '<<', '**', ':',
    )
    DEF_CHARS: tuple[str, ...] = (
        '(', ')', '[', ']', '{', '}', ',',
        '_', '<', '>', '=', '!', '+', '-',
        '*', '/', '%', '^', '&', '|', '>=',
        '==', '!=', '+=', '-=', '*=', '/=',
        '%=', '^=', '&=', '|=',
        ':', ';', '.', '@',
    )
    ILLEGAL_CHARS: tuple[str, ...] = (
        '\\',
        '`',
        '!',
        '?',
        '$',
        '#',
        '@=',
    )
    PYTHON_TO_VERSACE: MappingProxyType[str, str] = _MAP_(
        {
            'def'       : 'func',
            'elif'      : 'else if',
            'print'     : 'out',
            'input'     : 'in',
            '+= 1'      : '++',
            '-= 1'      : '--',
            '*'         : '~',
            '**'        : '~~',
            'TaskGroup' : 'coroutine',
            '@_async'   : 'async',
            'raise'     : 'throw',
            'except'    : 'catch',
        }
    )
    OPERATOR_OVERLOADS: MappingProxyType[str, str] = _MAP_(
        {
            '-='  : '__isub__',
            '+='  : '__iadd__',
            '*='  : '__imul__',
            '/='  : '__idiv__',
            '//=' : '__ifloordiv__',
            '%='  : '__imod__',
            '**=' : '__ipow__',
            '>>=' : '__irshift__',
            '<<=' : '__ilshift__',
            '&='  : '__iand__',
            '|='  : '__ior__',
            '^='  : '__ixor__',
            '<'   : '__lt__',
            '>'   : '__gt__',
            '<='  : '__le__',
            '>='  : '__ge__',
            '=='  : '__eq__',
            '!='  : '__ne__',
            '+'   : '__add__',
            '–'   : '__sub__',
            '-'   : '__sub__',
            '*'   : '__mul__',
            '/'   : '__truediv__',
            '//'  : '__floordiv_',
            '%'   : '__mod__',
            '**'  : '__pow__',
            '>>'  : '__rshift__',
            '<<'  : '__lshift__',
            '&'   : '__and__',
            '|'   : '__or__',
            '^'   : '__xor__',
        }
    )
    STRING_TYPES: tuple[str, ...] = (
         "r", "u", "R", "U", "f", "F", "fr", "Fr", "fR", "FR", "rf", "rF",
         "Rf", "RF", "b", "B", "br", "Br", "bR", "BR", "rb", "rB", "Rb", "RB"
    )
    BLANK_DATA: MappingProxyType[str, str] = _MAP_(
        {
            'str'           : "''",
            'int'           : '0',
            'float'         : '0.0',
            'bool'          : 'False',
            'list'          : '[NULL]',
            'tuple'         : '()',
            'dict'          : '{}',
            'set'           : 'set()',
            'bin'           : 'bin(0)',
            'hex'           : 'hex(0)',
            'oct'           : 'oct(0)',
            'frozenset'     : 'frozenset()',
            'complex'       : '0j',
            'bytes'         : 'b""',
            'bytearray'     : 'bytearray()',
            'None'          : 'None',
            'usize'          : 'None',
            'object'        : 'None',
            'u8'            : 'None',
            'u16'           : 'None',
            'u32'           : 'None',
            'u64'           : 'None',
            'u128'          : 'None',
            'i8'            : '0',
            'i16'           : '0',
            'i32'           : '0',
            'i64'           : '0',
            'i128'          : '0',
            'f32'           : '0.0',
            'f64'           : '0.0',
        }
    )
    ATTRIBUTES: tuple[str, ...] = (
        '__imul__', '__rtruediv__', '__rfloordiv__', '__subclasshook__', 'copy',
        'numerator', '__gt__', '__le__', 'decode', '__divmod__', '__init__',
        'startswith', '__ixor__', '__next__', '__ilshift__', 'ljust', '__class__',
        '__rmod__', '__ifloordiv__', '__rdivmod__', 'intersection', '__mul__',
        'len', '__truediv__', '__getnewargs__', 'partition', 'difference_update',
        'lower', '__floor__', '__iand__', '__rxor__', 'extend', 'title', '__iadd__',
        'isdigit', 'rstrip', 'lstrip', '__ipow__', 'endswith', '__itruediv__',
        '__setattr__', '__str__', 'to_bytes', 'real', 'clear', 'swapcase',
        '__pow__', '__mod__', 'expandtabs', '__delattr__', '__contains__',
        'maketrans', '__hash__', 'pop', 'discard', 'upper', 'imag', 'is_integer',
        'rsplit', 'items', 'bit_length', 'isdisjoint', '__set__', 'denominator',
        '__neg__', 'translate', '__int__', '__floordiv__', 'isdecimal', 'fromhex',
        '__isub__', 'append', 'istitle', 'isprintable', 'rfind', '__invert__',
        'rjust', '__lshift__', '__add__', '__or__', 'difference', '__lt__', 'complex',
        '__repr__', '__float__', '__reduce__', 'conjugate', 'zfill', 'str', 'int',
        'dict', 'list', 'tuple', 'set', 'bytes', 'bool', 'bytearray', 'frozenset', 'float',
        'symmetric_difference', 'isupper', '__reduce_ex__', 'center', '__call__',
        '__sub__', '__delitem__', '__getattribute__', '__rshift__', 'strip', '__sizeof__',
        'casefold', '__xor__', 'remove', 'symmetric_difference_update', '__ceil__',
        '__and__', 'isalpha', '__radd__', 'capitalize', 'isascii', 'islower', 'issubset',
        '__new__', 'get', '__rpow__', 'isidentifier', 'index', 'add', 'rpartition',
        '__irshift__', 'update', '__rmul__', 'sort', 'isnumeric', 'issuperset',
        'fromkeys', 'keys', '__pos__', '__ge__', '__reversed__', 'join', '__format__',
        '__imod__', '__dir__', 'find', 'union', 'reverse', '__ne__', '__rlshift__',
        '__bool__', '__trunc__', 'from_bytes', 'isalnum', '__getitem__', 'intersection_update',
        '__index__', '__round__', '__complex__', 'isspace', '__ior__', '__rand__', 'split',
        '__abs__', 'count', '__setitem__', 'insert', '__iter__', '__init_subclass__',
        'hex', '__rrshift__', '__rsub__', '__ror__', '__eq__', 'splitlines', 'values',
        '__len__', 'rindex', 'replace', 'popitem', 'setdefault', '__doc__',
    )

BINARY: int = 1
FILE_PATH: str = ''
LINES: list[str] = []
INDENTATION: str = ''
VERSACE_PATH: str = ''
ORG_FILE_PATH: str = ''
USE_CACHE: bool = False
MAX_INCLUDES: int = 100
NO_PYTHON: bool = False
LIB_ADDED: bool = False
NO_AUTO_OVERLOAD = False
TRACEBACK_LIMIT: int = 0
BINARY_FILE_EXT: str = ''
STATIC_FOR_CALLS: int = 0
RECURSIVE_CYCLES: int = 0
NO_INCLUDES: bool = False
FINAL_LIST: list[str] = []
IN_COMPILING: bool = False
ALLOW_UPDATE: bool = False
INDENTATION_LEVEL: int = 0
INDENTATION_COUNT: int = 0
COMPILE_SAVE_PATH: str = ''
NO_ARGS_START: bool = False
TRANSPILE_FILE_EXT: str = ''
ALLOW_TRACKING: bool = False
KEEP_PERF_DATA: bool = False
SEMI_COLON_ERROR: bool = False
NO_VERSION_CHECK: bool = False
IN_STATIC_FOR: list[bool] = []
EXTRA_INDENTATION: bool = False
STATIC_FOR_LINE: list[str] = []
PUBLIC_MAIN_FOUND: bool = False
ERROR_CHECK_ERROR: bool = False
TOKENIZED_LIST: list[list] = []
PRE_SPLIT_LIST: list[list] = []
OVERLOAD_FUNCTION_REG: dict = {}
PUBLIC_CLOSE_FOUND: bool = False
PUBLIC_UPDATE_FOUND: bool = False
IN_INTERPRETED_MODE: bool = False
LOADING_IN_PROGRESS: bool = False
COLOR_MODULE: tuple[bool, str] = ()
LINES_FROM_FILE_RAW: list[str] = []
STYLES_MODULE: tuple[bool, str] = ()
ERROR_REPORTING_CALLED: bool = False
OPTIONAL_ARGS_IN_FILE: list[str] = []
INCLUDES: list[str] = []*MAX_INCLUDES
ALWAYS_MONITOR_PERF_DATA: bool = False
CURRENT_YEAR: int = int(strftime("%Y"))
CLEAR_SCREEN: str = 'cls' if WINDOWS else 'clear'
TERMINAL_WIDTH: int = get_terminal_size().columns
EXE_FILE_TYPE: str = '.exe' if WINDOWS else '.out'
FREEZE_COMMAND: str = 'pause' if WINDOWS else 'read -p \'Press Enter to continue...\' var'

CLASSES: dict[str, dict] = {'builtin' : "REGULAR"}
FUNCTIONS: dict[str, dict] = {}
VARIABLES: dict[str, dict] = {}
KEYWORDS: dict[str, dict] = {}

class VersaceCodeBaseError(Exception):
    __doc__ = """This is raised when there is a error in the Versace Code Base"""
    __slots__ = ('message')
    def __init__(self, message):
        print("\033[1;31mVersaceError: " + message + "\033[0m")
        exit()
class NotImplementedYet(Exception):
    __doc__ = """
    \n This class is used to raise an error when there is no main function
    """
    __slots__ = ('ERROR_WORD', 'LINE')
    def __init__(self, ERROR_WORD: str) -> None:
        _system("")
        print(f'{COLORS["red"]}Not Implemented Yet: {COLORS["yellow"]}{ERROR_WORD}{COLORS["reset"]}')
        exit()
    @staticmethod
    def MATCH_FIRST(LINE: list, ERROR_WORD: str) -> None:
        _system("")
        if isinstance(LINE, str) == False:
            LINE = ' '.join(LINE)
        LINE = LINE.replace('<INDENTATIONSEP>', '{').replace('<DEDENTATIONSEP>', '}')
        if LINE.endswith(';') == False:
            if LINE.endswith(('{', '}', '(', ')', '[', ']', ',')) == False:
                LINE += ';'
        TOP_LINE: str = f"{COLORS['red']}Reported Traceback in File {FILE_PATH}::{COLORS['blue']}{GET_LINE_NUMBER(LINE)} {COLORS['reset']}"
        TOP_LINE_LEN = f"\u2502   UnknownError:"
        print(TOP_LINE)
        print(f'{COLORS["red"]}\u2502   UnknownError: {COLORS["yellow"]}{LINE}{COLORS["reset"]}')
        print(f'{COLORS["red"]}╰{"─"*(len(TOP_LINE_LEN.strip()) - 2)}> {"^"*(len(ERROR_WORD))}{COLORS["reset"]}')
        print(f'{COLORS["red"]}ERROR :{COLORS["yellow"]} This keyword is not implemented.{COLORS["reset"]}')
        exit()
class UnhandledException(Exception):
    __doc__ = """
    \n This class is used to raise an error when there is an unhandled error
    """
    __slots__ = ('ERROR_WORD', 'no_exit')
    def __init__(self, ERROR_WORD: str, no_exit=None) -> None:
        _system("")
        print(f'{COLORS["red"]}Unhandled Exception: {COLORS["white"]}{ERROR_WORD}{COLORS["reset"]}')
        exit() if no_exit is None else None

class DISPATCH(object):
    __doc__ = """
    \n This class is used to dispatch functions based on their arguments
    \n It is used to make a function that can take multiple arguments and return different values based on the arguments
    Args:
        NAME: The name of the function

    Returns:
        It returns a function that can take multiple arguments and return different values based on the arguments
    """
    # make a regex to detect __(Some uppercase word)
    # regex = __(\w+)
    # fix the regex to detect __([A-Z]+)__ and group the word in the brackets
    # regex = __([A-Z]+)__

    __slots__ = ('TYPE_MAP', 'NAME')
    def __init__(self, NAME):
        self.NAME = NAME
        self.TYPE_MAP = {}
    def __call__(self, *ARGUMENTS):
        TYPES = tuple(argument.__class__ for argument in ARGUMENTS) # a generator expression!
        FUNCTION = self.TYPE_MAP.get(TYPES)
        if FUNCTION is None:
            VersaceCodeBaseError(f"No registered function for types \"{TYPES}\"")
        return FUNCTION(*ARGUMENTS)
    def __register__(self, TYPES, FUNCTION):
        if TYPES in self.TYPE_MAP:
            VersaceCodeBaseError(f"Duplicate registration for function \"{FUNCTION.__name__}\"")
        self.TYPE_MAP[TYPES] = FUNCTION
class MemoizeMutable:
    __doc__ = """
    \n This class is used to cache the results of a function
    \n It is used to make a function that can take multiple arguments and return different values based on the arguments
    Returns:
        It returns a function that can take multiple arguments and return different values based on the arguments
    """
    __slots__ = ('func', 'cache')
    def __init__(self, func):
        self.func = func
        self.cache = {}
    def __call__(self, *args, **kwargs):
        key = dumps((args, kwargs))
        if key not in self.cache:
            self.cache[key] = self.func(*args, **kwargs)
        return self.cache[key]
class MISCELLANEOUS:
    __doc__ = """
    \n This class is used to store miscellaneous functions that are used in the VersaceCodeBase
    \n    Help Menu: This function is used to print the help menu
    \n    Copyright: This function is used to print the copy right information
    \n    License: This function is used to print the license information
    \n    Credits: This function is used to print the credits information
    \n    Version: This function is used to print the version information
    """
    __slots__ = ('None')
    def HELP_MENU(self) -> None:
        _system("")
        print(f'{COLORS["yellow"]}Copyright © {CURRENT_YEAR} Versace{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}All Rights Reserved.\n{COLORS["reset"]}')
        print(f'{COLORS["green"]}Usage: {COLORS["blue"]}Versace [file] [Arguments (optional)] [file (optional)]{COLORS["reset"]}')
        print(f'{COLORS["magenta"]}    Arguments    Aliases          Description{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -h           --help           {COLORS["blue"]}Show this help menu{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -v           --version        {COLORS["blue"]}Show the version of Versace{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -l           --license        {COLORS["blue"]}Show the license information{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -t           --transpile      {COLORS["blue"]}Transpile the file to a provided path{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -c           --compile        {COLORS["blue"]}Compile the file to a provided path{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -1           --compiler-1     {COLORS["blue"]}Use the first compiler{COLORS["magenta"]} (Fastest) (Default){COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -2           --compiler-2     {COLORS["blue"]}Use the second compiler{COLORS["magenta"]} (Slowest){COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -3           --compiler-3     {COLORS["blue"]}Use the third compiler{COLORS["red"]} (BROKEN){COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -f           --force          {COLORS["blue"]}Force Versace to pause before exiting{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -i           --in-shell       {COLORS["blue"]}Run Versace code directly from the console mode{COLORS["red"]} (BROKEN){COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -p           --profile        {COLORS["blue"]}Show the profile information{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -d           --debug          {COLORS["blue"]}Show the debug information{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -w           --watch          {COLORS["blue"]}Watch the file for changes and recompile it instantly{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -ast         --ast            {COLORS["blue"]}Show the Abstract Syntax Tree (use -all/--show-all to view the generated Bytecode){COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -all         --show-all       {COLORS["blue"]}Show all the output, must me used in conjunction with --debug/-d, --clear-temp/-ctemp, or --ast/-ast{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -cfg         --config         {COLORS["blue"]}Create a config file{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -py          --python         {COLORS["blue"]}Execute the Versace file using the python interpreter{COLORS["magenta"]} (Default){COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -no-py       --no-python      {COLORS["blue"]}Execute the file using the Versace interpreter without using python{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -ctemp       --clear-temp     {COLORS["blue"]}Clear the temporary files{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -clear       --clear          {COLORS["blue"]}Clear the console{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}    -ra          --rebuild-all    {COLORS["blue"]}Rebuild Versace, from raw python file{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}     install     --install        {COLORS["blue"]}Install Versace modules/packages{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}     remove      --uninstall      {COLORS["blue"]}Uninstall Versace modules/packages{COLORS["reset"]}')
        print(f'{COLORS["green"]}If you need more help, please read the documentation here: {COLORS["magenta"]}https://dhruvan.gitbook.io/vs/{COLORS["reset"]}')
    def COPYRIGHT(self) -> None:
        _system("")
        print(f'{COLORS["yellow"]}Copyright © 2001-{CURRENT_YEAR} Versace Software.{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}All Rights Reserved.\n{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}Copyright © 2000 GitHub, Inc.{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}All Rights Reserved.\n{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}Copyright © 2005-{CURRENT_YEAR} Dhruvan Enterprises, Software Division (DESD).{COLORS["reset"]}')
        print(f'{COLORS["yellow"]}All Rights Reserved.\n{COLORS["reset"]}')
    def LICENSE(self) -> None:
        _system("")
        print(f"{COLORS['yellow']}Copyright {CURRENT_YEAR} Ze7111 (Dhruvan Kartik)\n{COLORS['reset']}")
        print(f"{COLORS['yellow']}Permission is hereby granted, free of charge, to any persons obtaining{COLORS['reset']}")
        print(f"{COLORS['yellow']}a copy of this software and associated documentation files (the \"Software\"), {COLORS['reset']}")
        print(f"{COLORS['yellow']}to deal in the Software, without limitation any persons can {COLORS['red']}NOT{COLORS['reset']}{COLORS['yellow']} distribute, {COLORS['reset']}")
        print(f"{COLORS['yellow']}and/or sublicense this software without the permission of the author, however{COLORS['reset']}")
        print(f"{COLORS['yellow']}to deal in the Software, without limitation the rights to use, copy, modify, merge,{COLORS['reset']}")
        print(f"{COLORS['yellow']}and/or publish the Software.\n{COLORS['reset']}")
        print(f"{COLORS['yellow']}To permit persons to whom the Software is furnished to do so, subject to the{COLORS['reset']}")
        print(f"{COLORS['yellow']}following conditions:{COLORS['reset']}")
        print(f"{COLORS['yellow']}\tThe above copyright notice and this permission notice shall be included in all{COLORS['reset']}")
        print(f"{COLORS['yellow']}\tcopies or substantial portions of the Software.\n{COLORS['reset']}")
        print(   f"{COLORS['red']}\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,{COLORS['reset']}")
        print(f"{COLORS['yellow']}\tincluding but not limited to the warranties of merchantability, fitness for a{COLORS['reset']}")
        print(f"{COLORS['yellow']}\tparticular purpose and noninfringement. In no event shall the authors or{COLORS['reset']}")
        print(f"{COLORS['yellow']}\tcopyright holders be liable for any claim, damages or other liability, whether{COLORS['reset']}")
        print(f"{COLORS['yellow']}\tin an action of contract, tort or otherwise, arising from, out of or in{COLORS['reset']}")
        print(f"{COLORS['yellow']}\tconnection with the software or the use or other dealings in the Software.\n{COLORS['reset']}")
    def CREDITS(self) -> None:
        _system("")
        print(f"{COLORS['green']}Copyright {CURRENT_YEAR} Ze7111 (Dhruvan Kartik){COLORS['reset']}\n")
        print(f'{COLORS["green"]}Version: {COLORS["yellow"]}{VERSION}{COLORS["reset"]}')
        print(f'{COLORS["green"]}Author: {COLORS["yellow"]}Ze7111 (Dhruvan Kartik){COLORS["reset"]}')
        print(f'{COLORS["green"]}Moral Support: {COLORS["yellow"]}(Amr E.){COLORS["reset"]}')
        print(f'{COLORS["green"]}Development team of Versace.{COLORS["reset"]}')
    def VERSION(self) -> None:
        _system("")
        print(f'You are Running Versace {COLORS["red"]}Version{COLORS["reset"]}: {VERSION}')

if '-h' in PASS_LIST or '--help' in PASS_LIST:
    MISCELLANEOUS().HELP_MENU()
    exit()
if '-v' in PASS_LIST or '--version' in PASS_LIST:
    MISCELLANEOUS().VERSION()
    exit()
if '-l' in PASS_LIST or '--license' in PASS_LIST:
    MISCELLANEOUS().COPYRIGHT()
    exit()

class __1__:
    """This is a fake data type, to be used for overloading only"""
    __slots__ = "value"
    pass
class __2__:
    """This is a fake data type, to be used for overloading only"""
    __slots__ = "value"
    pass
class __3__:
    """This is a fake data type, to be used for overloading only"""
    __slots__ = "value"
    pass

class INCLUDE_STATEMENTS:
    __doc__ = """
    \n This class is used to store the include statements.
    """
    __slots__ = ["FILE_NAME", "AS_STATEMENT", "LINE"]
    @staticmethod
    def VERSACE_HEADER(FILE_NAME: str, AS_STATEMENT: str, LINE: list, SUBSET = False) -> str:
        global RECURSIVE_CYCLES
        for i in AS_STATEMENT: ASSIGN_CLASS(i.replace('\"', ''), "INCLUDE")
        RECURSIVE_CYCLES += 1
        if RECURSIVE_CYCLES >= MAX_INCLUDES: ERROR_REPORTING(LINE, "CyclicIncludeError", FILE_NAME); exit()
        FOUND = False
        FILE_NAME = FILE_NAME.replace(SYSTEM.get_c_dir(), '')
        if SYSTEM.path_exists(f"{VERSACE_PATH}{path_sep}include{path_sep}{FILE_NAME}"):
            FILE_NAME = f"{VERSACE_PATH}{path_sep}include{path_sep}{FILE_NAME}"
            FOUND = True
        if FOUND is False:
            if SYSTEM.path_exists(f"{SYSTEM.get_c_dir()}{path_sep}{FILE_NAME}") and path.basename(FILE_PATH) != FILE_NAME:
                FILE_NAME = f"{SYSTEM.get_c_dir()}{path_sep}{FILE_NAME}"
                FOUND = True
        else:
            if FOUND is False:
                ERROR_REPORTING(LINE, 'FileNotFound', f"{FILE_NAME}")
                return ''
        with open(FILE_NAME, 'r', encoding="utf-8") as FILE:
            LINES = FILE.readlines()
        DEFAULT_NAME = '' # ---------------------------- BadHeader

        # make a regex to identify "#define default.name = value" regardless of spaces and only get the value not the name, there can be a space between # and define
        # regex = r"#\s*define\s+name\s*=\s*(\w+)"
        for i in LINES:
            if i.startswith('#define'):
                DEFAULT_NAME = search(r"#\s*define\s+name\s*=\s*(\w+)", i)
                LINES.remove(i)
                if DEFAULT_NAME is not None:
                    DEFAULT_NAME = DEFAULT_NAME.group(1)
                    break

        if DEFAULT_NAME == '':
            ERROR_REPORTING(LINE, 'BadHeader', f"{FILE_NAME}")
            return ''

        # now identify these line: #include ttk from tkinter and get the ttk and tkinter and replace it with from tkinter import ttk
        # regex = r"(?<!\\)#include\s+(\w+)\s+from\s+(\w+)"
        for i in range(len(LINES)):
            LINES[i] = sub(r"(?<!\\)#include\s+(\w+)\s+from\s+(\w+)", r"from \2 import \1", LINES[i])

        # now identify any lines where there is #include outside of a string and replace it with import there can be a space between # and include
        # regex = r"(?<!\\)#include"
        for i in range(len(LINES)):
            LINES[i] = sub(r"(?<!\\)#name", DEFAULT_NAME, LINES[i])
            LINES[i] = sub(r"(?<!\\)#include", "import", LINES[i])

        # now identify this line: const some_name = value and replace it with some_name = value
        # regex = r"const\s+(\w+)\s*=\s*(\w+)"
        for i in range(len(LINES)):
            LINES[i] = sub(r"const\s+(\w+)\s*=\s*(\w+)", r"\1 = \2", LINES[i])

        return LINES
    @staticmethod
    def VERSACE_MODULE(FILE_NAME: str, LINE: str, SUBSET = False) -> str:
        from os import getcwd as os_getcwd
        global TOKENIZED_LIST, INCLUDES, RECURSIVE_CYCLES, INDENTATION_COUNT, COLOR_MODULE, STYLES_MODULE
        AS_STATEMENT = None;
        if 'as' in LINE:
            AS_STATEMENT = LINE[LINE.index('as') + 1]
        if FILE_NAME == 'colors.v':
            COLOR_MODULE = (True, FILE_NAME.split('.')[0])
            return ''
        if FILE_NAME == 'styles.v':
            STYLES_MODULE = (True, FILE_NAME.split('.')[0])
            return ''
        Found_File_Path = False
        RECURSIVE_CYCLES += 1
        if RECURSIVE_CYCLES >= MAX_INCLUDES: ERROR_REPORTING(LINE, "CyclicIncludeError", FILE_NAME); exit()
        # check if this files name is the same as the file name of the file that is being run
        FOUND = False
        FILE_NAME = FILE_NAME.replace(SYSTEM.get_user_dir(), '')
        if SYSTEM.path_exists(f"{VERSACE_PATH}{path_sep}include{path_sep}{FILE_NAME}"):
            FILE_NAME = f"{VERSACE_PATH}{path_sep}include{path_sep}{FILE_NAME}"
            FOUND = True
        if FOUND is False:
            if SYSTEM.path_exists(f"{os_getcwd()}{path_sep}{FILE_NAME}") and path.basename(FILE_PATH) != FILE_NAME:
                FILE_NAME = f"{os_getcwd()}{path_sep}{FILE_NAME}"
                FOUND = True
        if FOUND is False:
            from os import path as os_path
            if SYSTEM.path_exists(f"{os_path.dirname(FILE_PATH)}{path_sep}{FILE_NAME}"):
                FILE_NAME = f"{os_path.dirname(FILE_PATH)}{path_sep}{FILE_NAME}"
                FOUND = True
        else:
            if FOUND is False:
                ERROR_REPORTING(LINE, 'FileNotFound', f"{FILE_NAME}")
                return ''
        INCLUDES.append(FILE_NAME)

        ORG_LINES_FROM_FILE = []*100
        if not SUBSET:
            FINAL_LIST.append(f"{INDENTATION * INDENTATION_COUNT}class {path.basename(FILE_NAME).split('.')[0] if not AS_STATEMENT else AS_STATEMENT}:")
            INDENTATION_COUNT += 1

        # [Found_File_Path := True for i in INCLUDES if i == FILE_PATH] make this work without the walrus operator
        Found_File_Path = [True for i in INCLUDES if i == FILE_PATH]
        if not Found_File_Path: INCLUDES.append(FILE_PATH)
        SPLIT_LIST_COPY: list[str] = TOKENIZED_LIST.copy()
        TEMP_LINES_DATA = OPEN_FILE(FILE_NAME, mode='include')
        TEMP_SPLIT_LIST: list[str] = []*100
        TEMP_SPLIT_LIST = TOKENIZE_FILE(mode='include', DATA=TEMP_LINES_DATA)
        NEW_DATA = LEXICAL_ANALYSIS(mode='include',  INCLUDE_LIST=TEMP_SPLIT_LIST)
        TOKENIZED_LIST = SPLIT_LIST_COPY.copy()
        if not SUBSET: INDENTATION_COUNT -= 1
        ASSIGN_CLASS(path.basename(FILE_NAME).split('.')[0] if not AS_STATEMENT else AS_STATEMENT, "INCLUDE")
        del TEMP_LINES_DATA, TEMP_SPLIT_LIST
        return
    @staticmethod
    def PYTHON_MODULE(LINE: str, AS_STATEMENT: str) -> str:
        if 'from' in LINE:
            MODULES: list[str] = LINE[LINE.index('from') + 1:]
            for i in MODULES:
                ASSIGN_CLASS(i.replace('\"', ''), "INCLUDE")
            FUNCTIONS: list[str] = LINE[LINE.index('include') + 1:LINE.index('from')]
            for i in FUNCTIONS:
                ASSIGN_FUNCTION(i.replace('\"', ''), "INCLUDE", "none")
            if 'as' in LINE:
                MODULES = MODULES[:MODULES.index('as')]
            for index, i in enumerate(FUNCTIONS):
                if '\"' in i:
                    FUNCTIONS[index] = i.replace('\"', '')
            for index, i in enumerate(MODULES):
                if '\"' in i:
                    MODULES[index] = i.replace('\"', '')
            OUTPUT = f'from {" ".join(MODULES)} import {" ".join(FUNCTIONS)}'
            if 'as' in LINE:
                for i in AS_STATEMENT:
                    ASSIGN_CLASS(i.replace('\"', ''), "INCLUDE")
                AS_STATEMENT = ' '.join(AS_STATEMENT).replace('\"', '')
                OUTPUT += f" as {AS_STATEMENT}"
            return INDENTATION*INDENTATION_COUNT + OUTPUT
        else:
            OUTPUT = ' '.join(LINE[1:]).replace('\"', '')
            return INDENTATION*INDENTATION_COUNT + f"import {OUTPUT}"
    @staticmethod
    def PYTHON_FILE(FILE_NAME: str, LINE: str) -> str:
        global RECURSIVE_CYCLES
        RECURSIVE_CYCLES += 1
        if RECURSIVE_CYCLES >= MAX_INCLUDES: ERROR_REPORTING(LINE, "CyclicIncludeError", FILE_NAME); exit()
        FOUND = False
        FILE_NAME = FILE_NAME.replace(SYSTEM.get_c_dir(), '')
        if SYSTEM.path_exists(f"{VERSACE_PATH}{path_sep}include{path_sep}{FILE_NAME}"):
            FILE_NAME = f"{VERSACE_PATH}{path_sep}include{path_sep}{FILE_NAME}"
            FOUND = True
        if FOUND is False:
            if SYSTEM.path_exists(f"{SYSTEM.get_c_dir()}{path_sep}{FILE_NAME}") and path.basename(FILE_PATH) != FILE_NAME:
                FILE_NAME = f"{SYSTEM.get_c_dir()}{path_sep}{FILE_NAME}"
                FOUND = True
        else:
            if FOUND is False:
                ERROR_REPORTING(LINE, 'FileNotFound', f"{FILE_NAME}")
                return ''
        with open(f"{SYSTEM.get_c_dir()}{path_sep}{FILE_NAME}", 'r', encoding="utf-8") as f:
            DATA: list = f.readlines()
        return DATA
class SYNTAX_ANALYSIS:
    __doc__ = """
    This class contains all the sub-classes that are used to convert Versace code to python code
    It contains the following sub-classes:
    \n    __io__: This class contains the functions that are used to convert the io functions to python code
    \n    __access_modifiers__: This class contains the functions that are used to convert the access modifiers to python code
    \n    __control_flow__: This class contains the functions that are used to convert the control flow to python code
    \n    __function__: This class contains the functions that are used to convert the functions to python code
    \n    __variable__: This class contains the functions that are used to convert the variables to python code
    \n    __data_classes__: This class contains the functions that are used to convert the data classes to python code
    Returns:
    \n    str: the converted line
    """
    __slots__ = 'LINE'
    class __io__:
        __doc__ = """
        \n Inputs: the line to change
        \n Outputs: the line with the io stream removed
        \n Input/Output: output, input, include, from, import, pyc
        """
        __slots__ = 'LINE'
        @staticmethod
        def V_OUTPUT(LINE: list) -> str:
            global INDENTATION_COUNT,INDENTATION_LEVEL,  OPTIONAL_ARGS_IN_FILE, VARIABLES, FUNCTIONS, CLASSES
            """
            \n Inputs: the line to change
            \n Outputs: python converted line
            \n This function converts Versace code to python code
            """
            ORG_LINE = LINE.copy()
            OUTPUT_LINE: str = ''
            FOUND_OUT = False
            LINE = ' '.join(LINE)
            LINE = LINE.split('<<')
            LINE = [x.strip() for x in LINE]
            FOUND: bool = False
            if '<' in ORG_LINE:
                ERROR_REPORTING(ORG_LINE, 'Used<Error')
                return ''
            for _I_ in LINE:
                FOUND = [True for i in [VARIABLES.keys(), FUNCTIONS.keys(), CLASSES.keys()] if _I_ in i]
                if _I_ == 'out':
                    if FOUND_OUT is False:
                        FOUND_OUT = True
                        OUTPUT_LINE = "print("
                    else:
                        ERROR_REPORTING(ORG_LINE, 'outCalledError')
                        return ''
                elif _I_ in GLOBAL_VARIABLES.END_TYPES:
                    OUTPUT_LINE += f', end="{GLOBAL_VARIABLES.END_TYPES[_I_]}"'
                elif _I_ in GLOBAL_VARIABLES.JUSTIFY_TYPES:
                    if not STYLES_MODULE:

                        if FOUND: OUTPUT_LINE += f', {_I_}'; continue
                        if not FOUND: ERROR_REPORTING(ORG_LINE, 'StylesModuleNotIncludedError')
                    if "-*- no color -*-" not in OPTIONAL_ARGS_IN_FILE:
                        OUTPUT_LINE += f', justify="{_I_}"'
                elif _I_ in GLOBAL_VARIABLES.COLOR_TYPES:
                    if not COLOR_MODULE:
                        # check if _I_ is in VARIABLES, FUNCTIONS or CLASSES
                        if FOUND: OUTPUT_LINE += f', {_I_}'; continue
                        if not FOUND: ERROR_REPORTING(ORG_LINE, 'ColorModuleNotIncludedError'); return ''
                    if _I_.startswith('bold') and not FOUND: _I_ = f"{_I_.split('_')[0]} {_I_.split('_')[1]}"
                    if "-*- no color -*-" not in OPTIONAL_ARGS_IN_FILE:
                        if FOUND: OUTPUT_LINE += f', {_I_}'; continue
                        OUTPUT_LINE += f', style="{_I_}"'
                elif _I_ in GLOBAL_VARIABLES.STYLE_TYPES:
                    if not STYLES_MODULE:
                        if FOUND: OUTPUT_LINE += f', {_I_}'; continue
                        if not FOUND: ERROR_REPORTING(ORG_LINE, 'StylesModuleNotIncludedError')
                    if "-*- no color -*-" not in OPTIONAL_ARGS_IN_FILE:
                        OUTPUT_LINE += f', style="{_I_}"'
                elif _I_ == '<<':
                    continue
                else:
                    if ' ' in _I_ and '\"' not in _I_:
                        # check if even a part of _I_ is in either VARIABLES or FUNCTIONS or CLASSES
                        SPLIT_UP_LINE: str = TOKENIZE_LINE(_I_)
                        for index, i in enumerate(SPLIT_UP_LINE):
                            if CHECK_IF_DECLARED(i, ORG_LINE, TYPE=1):
                                SPLIT_UP_LINE[index] = '__' + SPLIT_UP_LINE[index]
                        _I_ = ' '.join(SPLIT_UP_LINE)

                    if _I_.startswith('rgb'):
                        FOUND = [True for i in [VARIABLES.keys(), FUNCTIONS.keys(), CLASSES.keys()] if 'rgb' in i]
                        if not COLOR_MODULE:
                            # check if _I_ is in VARIABLES, FUNCTIONS or CLASSES
                            if not FOUND: ERROR_REPORTING(ORG_LINE, 'ColorModuleNotIncludedError'); return ''

                        if "-*- no color -*-" not in OPTIONAL_ARGS_IN_FILE:
                            if not FOUND: OUTPUT_LINE += f', style="{_I_.replace(" ", "")}"'; continue

                    OUTPUT_LINE += f',{_I_}'

            OUTPUT_LINE += ')'
            for i in range(len(OUTPUT_LINE)):
                # remove the first comma
                if OUTPUT_LINE[i] == ',':
                    OUTPUT_LINE = OUTPUT_LINE[:i] + OUTPUT_LINE[i + 1:]
                    break
            return ''.join([(INDENTATION*INDENTATION_COUNT), OUTPUT_LINE])
        @staticmethod
        def V_INPUT(LINE: list) -> str:
            global INDENTATION_LEVEL, OPTIONAL_ARGS_IN_FILE, INDENTATION_COUNT
            """
            \n Inputs: the line to change
            \n Outputs: python converted line
            \n This function converts Versace code to python code
            """
            ORG_LINE = LINE
            OUTPUT_LINE: str = ''
            FOUND_OUT = False
            LINE = ' '.join(LINE)
            LINE = LINE.split('<<')
            LINE = [x.strip() for x in LINE]
            if '<' in ORG_LINE:
                ERROR_REPORTING(ORG_LINE, 'Used<Error')
                return ''
            OUTPUT_LINE += "print("
            # example line : in some_var << "Enter your name: " << endl << int
            # example output : print("Enter your name: ", end = "")\n some_var = int(input())
            VAR = LINE[0].split(' ')[1]
            if CHECK_IF_DECLARED(VAR, ORG_LINE, TYPE=1):
                VAR = '__' + VAR
            elif not CHECK_IF_DECLARED(VAR, ORG_LINE):
                return ''
            #print(LINE, VAR)
            LINE = LINE[1:]
            LINE_TYPE: str = ''
            for _I_ in LINE:
                FOUND = [True for i in [VARIABLES.keys(), FUNCTIONS.keys(), CLASSES.keys()] if _I_ in i]
                if _I_ in GLOBAL_VARIABLES.END_TYPES:
                    OUTPUT_LINE += f', end="{GLOBAL_VARIABLES.END_TYPES[_I_]}"'
                elif _I_ in GLOBAL_VARIABLES.JUSTIFY_TYPES:
                    if not STYLES_MODULE:

                        if FOUND: OUTPUT_LINE += f', {_I_}'; continue
                        if not FOUND: ERROR_REPORTING(ORG_LINE, 'StylesModuleNotIncludedError')
                    if "-*- no color -*-" not in OPTIONAL_ARGS_IN_FILE:
                        OUTPUT_LINE += f', justify="{_I_}"'
                elif _I_ in GLOBAL_VARIABLES.COLOR_TYPES:
                    if not COLOR_MODULE:
                        # check if _I_ is in VARIABLES, FUNCTIONS or CLASSES
                        if FOUND: OUTPUT_LINE += f', {_I_}'; continue
                        if not FOUND: ERROR_REPORTING(ORG_LINE, 'ColorModuleNotIncludedError'); return ''
                    if _I_.startswith('bold') and not FOUND: _I_ = f"{_I_.split('_')[0]} {_I_.split('_')[1]}"
                    if "-*- no color -*-" not in OPTIONAL_ARGS_IN_FILE:
                        if FOUND: OUTPUT_LINE += f', {_I_}'; continue
                        OUTPUT_LINE += f', style="{_I_}"'
                elif _I_ in GLOBAL_VARIABLES.STYLE_TYPES:
                    if not STYLES_MODULE:
                        if FOUND: OUTPUT_LINE += f', {_I_}'; continue
                        if not FOUND: ERROR_REPORTING(ORG_LINE, 'StylesModuleNotIncludedError')
                    if "-*- no color -*-" not in OPTIONAL_ARGS_IN_FILE:
                        OUTPUT_LINE += f', style="{_I_}"'
                elif _I_ == '<<':
                    continue
                elif _I_ in GLOBAL_VARIABLES.DATA_TYPES:
                    LINE_TYPE = _I_
                else:
                    if ' ' in _I_ and '\"' not in _I_:
                        # check if even a part of _I_ is in either VARIABLES or FUNCTIONS or CLASSES
                        SPLIT_UP_LINE: str = TOKENIZE_LINE(_I_)
                        for index, i in enumerate(SPLIT_UP_LINE):
                            if CHECK_IF_DECLARED(i, ORG_LINE, TYPE=1):
                                SPLIT_UP_LINE[index] = '__' + SPLIT_UP_LINE[index]
                        _I_ = ' '.join(SPLIT_UP_LINE)

                    if _I_.startswith('rgb'):
                        FOUND = [True for i in [VARIABLES.keys(), FUNCTIONS.keys(), CLASSES.keys()] if 'rgb' in i]
                        if not COLOR_MODULE:
                            # check if _I_ is in VARIABLES, FUNCTIONS or CLASSES
                            if not FOUND: ERROR_REPORTING(ORG_LINE, 'ColorModuleNotIncludedError'); return ''

                        if "-*- no color -*-" not in OPTIONAL_ARGS_IN_FILE:
                            if not FOUND: OUTPUT_LINE += f', style="{_I_.replace(" ", "")}"'; continue

                    OUTPUT_LINE += f',{_I_}'
            if 'end=' not in OUTPUT_LINE:
                OUTPUT_LINE += ', end=""'
            OUTPUT_LINE += ')'
            for i in range(len(OUTPUT_LINE)):
                # remove the first comma
                if OUTPUT_LINE[i] == ',':
                    OUTPUT_LINE = OUTPUT_LINE[:i] + OUTPUT_LINE[i + 1:]
                    break
            if LINE_TYPE == '':
                LINE_TYPE = 'str'
            return (''.join([(INDENTATION*INDENTATION_COUNT), OUTPUT_LINE])) + f'\n{INDENTATION*INDENTATION_COUNT}{VAR} = {LINE_TYPE}(input())'
        @staticmethod
        def V_INCLUDE(LINE: list) -> str:
            global INDENTATION_LEVEL,    INDENTATION_COUNT, FINAL_LIST, TOKENIZED_LIST
            LINE = [LINE.replace('f"', '\"') for LINE in LINE]
            ITEMS_TO_INCLUDE: list = []*100
            AS_STATEMENT: str = ''
            SUBSET = False
            if 'namespace' in LINE:
                SUBSET = True
                LINE.remove('namespace')
            if '-ast' in PASS_LIST: return f"{INDENTATION*INDENTATION_COUNT}versace_include_statement({' '.join(LINE[1:])})\n"
            ITEMS_TO_INCLUDE = LINE[1:]
            if SYSTEM.path_exists(f"{VERSACE_PATH}{path_sep}include") is False:
                SYSTEM.make_dirs(f"{VERSACE_PATH}{path_sep}include")
            if NO_INCLUDES:
                ERROR_REPORTING(LINE, 'NoIncludesError')
                return ''
            if 'as' in ITEMS_TO_INCLUDE:
                ITEMS_TO_INCLUDE = ITEMS_TO_INCLUDE[:ITEMS_TO_INCLUDE.index('as')]
                AS_STATEMENT = LINE[LINE.index('as') + 1:]
            ITEMS_TO_INCLUDE = [x for x in ITEMS_TO_INCLUDE if x != ',']
            NEW_DATA: list = []*100
            for index, i in enumerate(ITEMS_TO_INCLUDE):
                ITEMS_TO_INCLUDE[index] = i.replace('\"', '') if '\"' in i else i
            for i in ITEMS_TO_INCLUDE:
                if SYSTEM.get_c_dir() + path_sep in i:
                    i = i.replace(SYSTEM.get_c_dir() + path_sep, '')

                if i.endswith('.vh'):
                    for _data in INCLUDE_STATEMENTS.VERSACE_HEADER(i, AS_STATEMENT, LINE):
                        NEW_DATA.append((INDENTATION*INDENTATION_COUNT) + _data)

                elif i.endswith('.v'):
                    INCLUDE_STATEMENTS.VERSACE_MODULE(i, LINE, SUBSET = SUBSET)

                elif i.endswith('.py'):
                    for _data in INCLUDE_STATEMENTS.PYTHON_FILE(i, LINE):
                        NEW_DATA.append((INDENTATION*INDENTATION_COUNT) + _data)
                else:
                    return INCLUDE_STATEMENTS.PYTHON_MODULE(LINE, AS_STATEMENT)

            for index, i in enumerate(NEW_DATA):
                if i.endswith('\n'):
                    NEW_DATA[index] = i[:-1]

            OUTPUT = '\n'.join(NEW_DATA)

            del ITEMS_TO_INCLUDE, AS_STATEMENT, NEW_DATA
            if type(OUTPUT) != str:
                OUTPUT = ''
            return OUTPUT
        @staticmethod
        def V_FROM(LINE: list) -> str:
            NotImplementedYet.MATCH_FIRST(LINE, 'FROM')
            exit()
        @staticmethod
        def V_IMPORT(LINE: list) -> str:
            NotImplementedYet.MATCH_FIRST(LINE, 'IMPORT')
            exit()
        @staticmethod
        def V_PYC(LINE: list) -> str:
            if 'file' in LINE and '=' in LINE:
                with open(LINE[LINE.index('=') + 1].replace('\"', ''), 'r', encoding="utf-8") as f:
                    DATA = f.readlines()
                for index, i in enumerate(DATA):
                    DATA[index] = f"{INDENTATION*INDENTATION_COUNT}{i}"
                return ''.join(DATA)
            else:
                return ''.join(LINE[1:])[2:-1]
    
    class __access_modifiers__:
        __doc__ = """
        \n Inputs: the line to change
        \n Outputs: the line with the access modifiers words removed
        \n Access Modifiers: public, private, method, attribute, with, call
        """
        __slots__ = 'LINE'
        @staticmethod
        def V_PUBLIC(LINE: list) -> str:
            """
            \n Inputs: the line to change
            \n Outputs: the line with the public removed
            \n This function removes the public from the line
            """
            # main({1:"1"}, 1, "str", 321)
            # close( "str", 321, {1:"1"}, 1)
            # update(321, "str", 1, {1:"1"})
            global INDENTATION_LEVEL, INDENTATION_COUNT, PUBLIC_CLOSE_FOUND, PUBLIC_MAIN_FOUND, PUBLIC_UPDATE_FOUND, STATIC_FOR_LINE, IN_STATIC_FOR, STATIC_FOR_CALLS
            OUTPUT_LINE: str = ''
            TEMP_LINE: str = ' '.join(LINE)
            TEMP_LINE = TEMP_LINE.split(' ')
            TEMP_LINE = [x.strip() for x in TEMP_LINE]
            if '()' not in TEMP_LINE:
                ERROR_REPORTING(LINE, 'AddedArgumentsToPublic')
                return ' '
            TEMP_LINE = TEMP_LINE[1:]
            TEMP_LINE.insert(0, 'def')
            if TEMP_LINE[1] == 'close':
                TEMP_LINE = TEMP_LINE[:-2]
                TEMP_LINE.append('(a, b, c, d) <INDENTATIONSEP>\n')
            TEMP_LINE = ' '.join(TEMP_LINE)
            OUTPUT_LINE = TEMP_LINE
            FUNCTION_NAME = LINE[1]

            if FUNCTION_NAME == 'main':
                PUBLIC_MAIN_FOUND = True
                OUTPUT_LINE = (INDENTATION*INDENTATION_COUNT) + '@overload(dict, int, str, int)\n'
                OUTPUT_LINE += (INDENTATION*INDENTATION_COUNT) + 'def main(a, b, c, d) <INDENTATIONSEP>\n'
                #STATIC_FOR_LINE.append('main({1:"1"}, 321, "str", 1)')
                #IN_STATIC_FOR.append(True)
                #STATIC_FOR_CALLS += 1
                return OUTPUT_LINE
            if FUNCTION_NAME == 'update':
                PUBLIC_UPDATE_FOUND = True
                OUTPUT_LINE  = (INDENTATION*INDENTATION_COUNT) + '@_async\n'
                OUTPUT_LINE += (INDENTATION*INDENTATION_COUNT) + '@overload(int, str, int, dict)\n'
                OUTPUT_LINE += (INDENTATION*INDENTATION_COUNT) + 'def update(a, b, c, d):\n'
                OUTPUT_LINE += (INDENTATION*(INDENTATION_COUNT + 1)) + 'while True:\n'
                OUTPUT_LINE += (INDENTATION*(INDENTATION_COUNT + 2)) + 'if not main_thread().is_alive():\n'
                OUTPUT_LINE += (INDENTATION*(INDENTATION_COUNT + 3)) + 'exit()'
                INDENTATION_COUNT += 1
                STATIC_FOR_LINE.append('update(321, "str", 1, {1:"1"})')
                IN_STATIC_FOR.append(True)
                STATIC_FOR_CALLS += 1
                return OUTPUT_LINE
            if FUNCTION_NAME == 'close':
                OUTPUT_LINE = (INDENTATION*INDENTATION_COUNT) + '@overload(str, int, dict, int)\n' + OUTPUT_LINE
                PUBLIC_CLOSE_FOUND = True
            FUNCTION_TYPE = ''
            if LINE[1] == 'func': ERROR_REPORTING(LINE, 'AddedArgumentsToPublic', 'You can not use func when using public without a specified return type')
            try:
                if LINE[2] == 'func':
                    if (LINE[1] in GLOBAL_VARIABLES.DATA_TYPES or CHECK_IF_DECLARED(LINE[1], LINE, TYPE=11)):
                        FUNCTION_NAME = LINE[3]
                        FUNCTION_TYPE = LINE[1]
                    if FUNCTION_TYPE:
                        OUTPUT_LINE = OUTPUT_LINE.split(' ')
                        OUTPUT_LINE.pop(1)
                        OUTPUT_LINE.pop(1)
                        OUTPUT_LINE[-2] = OUTPUT_LINE[-2] + f' -> {FUNCTION_TYPE}'
                        OUTPUT_LINE = ' '.join(OUTPUT_LINE)
            except IndexError: pass
            return ''.join([(INDENTATION*INDENTATION_COUNT), OUTPUT_LINE])
        @staticmethod
        def V_PRIVATE(LINE: list) -> str:
            TEMP_ARGS = ''
            if '=' in LINE:
                LINE = LINE[1:]
                if LINE[0] in GLOBAL_VARIABLES.DATA_TYPES or CHECK_IF_DECLARED(LINE[0], LINE, TYPE=11):
                    if LINE[0] == 'self' or LINE[0] == 'super':
                        if LINE[1] == 'self' or LINE[1] == 'super':
                            if LINE[2] == '()':
                                LINE[4] = '__' + LINE[4]
                            else:
                                LINE[3] = '__' + LINE[3]
                            return (INDENTATION*INDENTATION_COUNT) + ' '.join(LINE)
                        else:
                            if LINE[1] == '()':
                                LINE[3] = '__' + LINE[3]
                            else:
                                LINE[2] = '__' + LINE[2]
                            return (INDENTATION*INDENTATION_COUNT) + ' '.join(LINE)
                    else:
                        LINE[1] = '__' + LINE[1]
                else:
                    ERROR_REPORTING(LINE, 'AddedDataTypesToPrivClass')
                return SYNTAX_ANALYSIS.__variable__.V_VARIABLE(LINE)
            OUTPUT_LINE: str = ''
            TEMP_LINE: str = ' '.join(LINE)
            TEMP_LINE = TEMP_LINE.split(' ')
            if 'func' not in TEMP_LINE:
                if TEMP_LINE[1] in GLOBAL_VARIABLES.DATA_TYPES:
                    ERROR_REPORTING(LINE, 'AddedDataTypesToPrivClass')
                    return ' '
                try:
                    TEMP_LINE[2] = '__' + TEMP_LINE[2]
                except IndexError: return ' '
                ASSIGN_CLASS(TEMP_LINE[2], "PRIVATE")
            elif 'func' in TEMP_LINE and 'async' in TEMP_LINE:
                ERROR_REPORTING(LINE, 'AsyncAndPrivate')
                return ' '
            elif 'func' in TEMP_LINE:
                if TEMP_LINE[1] in GLOBAL_VARIABLES.DATA_TYPES:
                    TEMP_LINE[3] = '__' + TEMP_LINE[3]
                    VAR_TYPE = TEMP_LINE[1]
                    TEMP_LINE = TEMP_LINE[1:]
                else:
                    TEMP_LINE[2] = '__' + TEMP_LINE[2]
                TEMP_LINE = TEMP_LINE[1:]
                ASSIGN_FUNCTION(TEMP_LINE[1], "PRIVATE", TEMP_LINE[2:-1])
                return SYNTAX_ANALYSIS.__function__.V_FUNCTION(TEMP_LINE, f"-> {VAR_TYPE}", True)
            TEMP_LINE = [x.strip() for x in TEMP_LINE]
            TEMP_LINE = TEMP_LINE[1:]
            if '(' not in TEMP_LINE and ')' not in TEMP_LINE:
                if '()' in TEMP_LINE:
                    TEMP_LINE.insert(0, 'def')
            else:
                TEMP_LINE.insert(0, 'def')
            TEMP_LINE = ' '.join(TEMP_LINE)
            OUTPUT_LINE = TEMP_LINE
            return ''.join([(INDENTATION*INDENTATION_COUNT), OUTPUT_LINE])
        @staticmethod
        def V_METHOD(LINE: list) -> str:
            global INDENTATION_LEVEL,    INDENTATION_COUNT, IN_STATIC_FOR, STATIC_FOR_LINE, STATIC_FOR_CALLS, EXTRA_INDENTATION
            ARGUMENTS = []*100
            ARGS: str = 'args'
            KEYWORD_ARGS: str = 'kwargs'
            if 'async' in LINE:
                ERROR_REPORTING(LINE, 'UsedAsyncAndMethod')
                return ' '
            if '|' in LINE:
                for INDEX in range(len(LINE)):
                    if LINE[INDEX] == '*':
                        ARGS = LINE[INDEX+1]
                    elif LINE[INDEX] == '**':
                        KEYWORD_ARGS = LINE[INDEX+1]
                if '*' not in LINE and '**' not in LINE:
                    ARGUMENTS = LINE[LINE.index('|')+1:LINE.index(')')]
            ARGUMENTS = f"{' '.join(ARGUMENTS)}, " if ARGUMENTS != []*100 else ''
            LINE_1 = f"{(' '.join(LINE[1:LINE.index('|')])).strip()} )" if '|' in LINE else (' '.join(LINE[1:LINE.index('<INDENTATIONSEP>')])).strip()
            OUTPUT_LINE = ''.join([(INDENTATION*INDENTATION_COUNT),f"def {LINE_1}",':','\n'])
            OUTPUT_LINE += (INDENTATION*(INDENTATION_COUNT+1)) + f"def method_{LINE[1].strip()}({ARGUMENTS}*{ARGS}, **{KEYWORD_ARGS})" + '<INDENTATIONSEP>'
            STATIC_FOR_LINE.append(f"return method_{LINE[1].strip()}")
            ASSIGN_FUNCTION(LINE[1], "METHOD", LINE[3:-2])
            IN_STATIC_FOR.append(True)
            STATIC_FOR_CALLS += 1
            EXTRA_INDENTATION = True
            INDENTATION_COUNT += 1
            return OUTPUT_LINE
        @staticmethod
        def V_AT(LINE: list) -> str:

            LINE[0] = f'{INDENTATION*INDENTATION_COUNT}{LINE[0]}'
            for i in range(len(LINE)):
                if LINE[i] == 'async' and LINE[i+1] == 'func':
                    ERROR_REPORTING(LINE, 'UsedAsyncAndMethod')
                    return ' '
                if LINE[i] == 'func':
                    LINE[i] = f'\n{INDENTATION*INDENTATION_COUNT}def'
            return ' '.join(LINE)
        @staticmethod
        def V_WITH(LINE: list) -> str:
            LINE[0] = f'{INDENTATION*INDENTATION_COUNT}{LINE[0]}'
            return ' '.join(LINE)
        @staticmethod
        def V_CALL(LINE: list) -> str:
            LINE = LINE[1:]
            LINE = [',' if x == '|' else x for x in LINE]
            LINE = ' '.join(LINE).strip()
            LINE = f"{INDENTATION*INDENTATION_COUNT}{LINE}"
            return LINE
        @staticmethod
        def V_RAW(LINE: list) -> str:
            LINE = LINE[1:]
            LINE = ' '.join(LINE).strip()
            LINE = f"{INDENTATION*INDENTATION_COUNT}{LINE}"
            return LINE
    
    class __control_flow__:
        __doc__ = """
        \n Inputs: the line to change
        \n Outputs: the line with the control flow words removed
        \n Control Flow: if, else, else if, for, while, static for, return
        """
        __slots__ = 'LINE'
        @staticmethod
        def V_IF(LINE: list) -> str:

            OUTPUT_LINE: str = ''
            TEMP_LINE: str = ' '.join(LINE)
            TEMP_LINE = TEMP_LINE.split(' ')
            TEMP_LINE = [x.strip() for x in TEMP_LINE]
            TEMP_LINE: str = ' '.join(TEMP_LINE)
            FOUND_START = False
            try:
                if '(' in TEMP_LINE or ')' in TEMP_LINE:
                    for index, char in enumerate(TEMP_LINE):
                        if char == '(' and TEMP_LINE[index - 2] == 'f' and TEMP_LINE[index - 3] == 'i':
                            # example: if ( true ) :
                            # output: if true:
                            FOUND_START = True
                            TEMP_LINE = TEMP_LINE[:index] + TEMP_LINE[index + 1:]
                        elif char == ')':
                            if TEMP_LINE[index + 1] == ':' or TEMP_LINE[index + 1] == '<' and TEMP_LINE[index + 2] == 'I' and TEMP_LINE[index + 3] == 'N' and TEMP_LINE[index + 4] == 'D' and TEMP_LINE[index + 5] == 'E' and TEMP_LINE[index + 6] == 'N' and TEMP_LINE[index + 7] == 'T':
                                # example: if true ) :
                                # output: if true:
                                if FOUND_START:
                                    TEMP_LINE = TEMP_LINE[:index - 1] + TEMP_LINE[index + 1:]
            except IndexError: return ' '
            OUTPUT_LINE = TEMP_LINE
            return ''.join([(INDENTATION*INDENTATION_COUNT), OUTPUT_LINE])
        @staticmethod
        def V_ELSE(LINE: list) -> str:

            LINE = [x.strip() for x in LINE]
            OUTPUT_LINE: str = ' '.join(LINE)
            return ''.join([(INDENTATION*INDENTATION_COUNT), OUTPUT_LINE])
        @staticmethod
        def V_ELSE_IF(LINE: list) -> str:
            OUTPUT_LINE: str = ''
            TEMP_LINE = LINE[2:]
            TEMP_LINE.insert(0, 'elif')
            TEMP_LINE: str = ' '.join(TEMP_LINE)
            TEMP_LINE = TEMP_LINE.split(' ')
            TEMP_LINE = [x.strip() for x in TEMP_LINE]
            TEMP_LINE: str = ' '.join(TEMP_LINE)
            FOUND_START = False
            if '(' in TEMP_LINE or ')' in TEMP_LINE:
                for index, char in enumerate(TEMP_LINE):
                    if char == '(' and TEMP_LINE[index - 2] == 'f' and TEMP_LINE[index - 3] == 'i':
                        # example: if ( true ) :
                        # output: if true:
                        FOUND_START = True
                        TEMP_LINE = TEMP_LINE[:index] + TEMP_LINE[index + 1:]
                    elif char == ')':
                        if TEMP_LINE[index + 1] == ':' or TEMP_LINE[index + 1] == '<' and TEMP_LINE[index + 2] == 'I' and TEMP_LINE[index + 3] == 'N' and TEMP_LINE[index + 4] == 'D' and TEMP_LINE[index + 5] == 'E' and TEMP_LINE[index + 6] == 'N' and TEMP_LINE[index + 7] == 'T':
                            # example: if true ) :
                            # output: if true:
                            if FOUND_START:
                                TEMP_LINE = TEMP_LINE[:index - 1] + TEMP_LINE[index + 1:]
            OUTPUT_LINE = TEMP_LINE
            return ''.join([(INDENTATION*INDENTATION_COUNT), OUTPUT_LINE])
        @staticmethod
        def V_FOR(LINE: list) -> str:

            if '|' in LINE:
                return SYNTAX_ANALYSIS.__control_flow__.V_STATIC_FOR(LINE)
            OUTPUT_LINE: str = ''
            TEMP_LINE: str = ' '.join(LINE)
            TEMP_LINE = TEMP_LINE.split(' ')
            TEMP_LINE = [x.strip() for x in TEMP_LINE]
            TEMP_LINE: str = ' '.join(TEMP_LINE)
            FOUND_START = False
            # recognize this pattern: for ( start, condition, increment ) :
            if '(' in TEMP_LINE or ')' in TEMP_LINE:
                for index, char in enumerate(TEMP_LINE):
                    if char == '(' and TEMP_LINE[index - 2] == 'r' and TEMP_LINE[index - 3] == 'o' and TEMP_LINE[index - 4] == 'f':
                        # example: for ( true ) :
                        # output: for true:
                        FOUND_START = True
                        TEMP_LINE = TEMP_LINE[:index] + TEMP_LINE[index + 1:]
                    elif char == ')':
                        if TEMP_LINE[index + 1] == ':' or TEMP_LINE[index + 1] == '<' and TEMP_LINE[index + 2] == 'I' and TEMP_LINE[index + 3] == 'N' and TEMP_LINE[index + 4] == 'D' and TEMP_LINE[index + 5] == 'E' and TEMP_LINE[index + 6] == 'N' and TEMP_LINE[index + 7] == 'T':
                            # example: for true ) :
                            # output: for true:
                            if FOUND_START:
                                TEMP_LINE = TEMP_LINE[:index - 1] + TEMP_LINE[index + 1:]
            OUTPUT_LINE = TEMP_LINE
            return ''.join([(INDENTATION*INDENTATION_COUNT), OUTPUT_LINE])
        @staticmethod
        def V_WHILE(LINE: list) -> str:

            OUTPUT_LINE: str = ''
            TEMP_LINE: str = ' '.join(LINE)
            TEMP_LINE = TEMP_LINE.split(' ')
            TEMP_LINE = [x.strip() for x in TEMP_LINE]
            TEMP_LINE: str = ' '.join(TEMP_LINE)
            FOUND_START = False
            if '(' in TEMP_LINE or ')' in TEMP_LINE:
                for index, char in enumerate(TEMP_LINE):
                    if char == '(' and TEMP_LINE[index - 2] == 'e' and TEMP_LINE[index - 3] == 'l' and TEMP_LINE[index - 4] == 'i' and TEMP_LINE[index - 5] == 'h' and TEMP_LINE[index - 6] == 'w':
                        # example: while ( true ) :
                        # output: while true:
                        FOUND_START = True
                        TEMP_LINE = TEMP_LINE[:index] + TEMP_LINE[index + 1:]
                    elif char == ')':
                        if TEMP_LINE[index + 1] == ':' or TEMP_LINE[index + 1] == '<' and TEMP_LINE[index + 2] == 'I' and TEMP_LINE[index + 3] == 'N' and TEMP_LINE[index + 4] == 'D' and TEMP_LINE[index + 5] == 'E' and TEMP_LINE[index + 6] == 'N' and TEMP_LINE[index + 7] == 'T':
                            # example: while true ) :
                            # output: while true:
                            if FOUND_START:
                                TEMP_LINE = TEMP_LINE[:index - 1] + TEMP_LINE[index + 1:]
            OUTPUT_LINE = TEMP_LINE
            return ''.join([(INDENTATION*INDENTATION_COUNT), OUTPUT_LINE])
        @staticmethod
        def V_STATIC_FOR(LINE: list) -> str:
            global INDENTATION_LEVEL,    INDENTATION_COUNT, IN_STATIC_FOR, STATIC_FOR_LINE, STATIC_FOR_CALLS
            #print((' '.join(LINE)).replace('<INDENTATIONSEP>', '{'))
            MATCH = search(r'for\s*\((.+?)\|(.+?)\|(.+?)\)', (' '.join(LINE)).replace('<INDENTATIONSEP>', '{'))
            if not MATCH:
                ERROR_REPORTING(LINE, "badStaticForLoop")
            VARIABLE_TO_USE = MATCH.group(1).strip()
            CONDITION = MATCH.group(2).strip()
            INCREMENT = MATCH.group(3).strip()
            if VARIABLE_TO_USE.startswith(GLOBAL_VARIABLES.DATA_TYPES):
                VARIABLE_TO_USE = VARIABLE_TO_USE[len(VARIABLE_TO_USE.split(' ')[0]):].strip()
            END_CONDITIONS = ('++', '--', '**', '//')
            OTHER_CONDITIONS = ('<=', '>=', '==', '!=', '+=', '-=', '*=', '/=', '%=', '^=', '&=', '|=')
            if INCREMENT.endswith(END_CONDITIONS):
                if INCREMENT.endswith('++'):
                    INCREMENT = INCREMENT[:-3]
                    INCREMENT = f"{INCREMENT} += 1"
                elif INCREMENT.endswith('--'):
                    INCREMENT = INCREMENT[:-3]
                    INCREMENT = f"{INCREMENT} -= 1"
                elif INCREMENT.endswith('**'):
                    INCREMENT = INCREMENT[:-3]
                    INCREMENT = f"{INCREMENT} *= {INCREMENT[:2]}"
                elif INCREMENT.endswith('//'):
                    INCREMENT = INCREMENT[:-3]
                    INCREMENT = f"{INCREMENT} /= {INCREMENT[:2]}"
            else:
                # line could be: i+=1
                for condition in OTHER_CONDITIONS:
                    if condition in INCREMENT:
                        break
                else:
                    ERROR_REPORTING(LINE, "badStaticForLoop")

            #print(f"Variable: {COLORS['red']}\"{VARIABLE_TO_USE}\"{COLORS['reset']} | End Condition: {COLORS['red']}\"{CONDITION}\"{COLORS['reset']} | Increment: {COLORS['red']}\"{INCREMENT}\"{COLORS['reset']}")
            OUTPUT_LINE = (INDENTATION*INDENTATION_COUNT) + VARIABLE_TO_USE + '\n'
            OUTPUT_LINE += (INDENTATION*INDENTATION_COUNT) + 'while ' + CONDITION + ':'
            STATIC_FOR_LINE.append(INCREMENT)
            IN_STATIC_FOR.append(True)
            STATIC_FOR_CALLS += 1
            return OUTPUT_LINE
        @staticmethod
        def V_RETURN(LINE: list) -> str:

            if len(LINE) == 1:
                ERROR_REPORTING(LINE, "badReturn")
            return (INDENTATION*INDENTATION_COUNT) + ' '.join(LINE)
        @staticmethod
        def V_ASSERT(LINE: list) -> str:
            if len(LINE) == 1:
                ERROR_REPORTING(LINE, "badAssert")
            # get line after | if there is one
            LINE_AFTER: list = []
            LINE_BEFORE: list = []
            OUTPUT: str = ''
            if '|' in LINE:
                LINE_AFTER = LINE[LINE.index('|') + 1:]
                LINE_BEFORE = LINE[:LINE.index('|')][1:]
                OUTPUT = f"{INDENTATION*INDENTATION_COUNT}Assert({' '.join(LINE_BEFORE)}, message={' '.join(LINE_AFTER)})\n"
            else:
                LINE_BEFORE = LINE[1:]
                OUTPUT = f"{INDENTATION*INDENTATION_COUNT}Assert({' '.join(LINE_BEFORE)})\n"
            return OUTPUT

    class __function__:
        __doc__ = """
        \n Inputs: the line to change
        \n Outputs: the line with the function changed
        \n Function: func, async func, await, coroutine
        """
        __slots__ = 'LINE', 'RETURN_TYPE'
        @staticmethod
        def V_FUNCTION(LINE: list, RETURN_TYPE='', PRIVATE=False, KEYWORD=False) -> str:
            global FINAL_LIST
            LINE = [x.strip() for x in LINE]
            LINE = LINE[1:]
            LINE.insert(0, 'def')

            ARGS_IN_LINE = ' '.join(LINE[3:-2]).strip()
            IN_STRING = False
            TEMP_ARGS = []*100
            if LINE[1] in GLOBAL_VARIABLES.OPERATOR_OVERLOADS:
                if INDENTATION_COUNT == 0: ERROR_REPORTING(LINE, "TriedOverloadingGlobalOperator", LINE[1])
                LINE[1] = GLOBAL_VARIABLES.OPERATOR_OVERLOADS[LINE[1]]
            word = ''
            for char in ARGS_IN_LINE:
                if char == '=':
                    ERROR_REPORTING(LINE, "badFunction")
                    return ''
                if char == '\"':
                    IN_STRING = LATCH(IN_STRING)
                if char == ',' and not IN_STRING:
                    TEMP_ARGS.append(word.strip())
                    word = ''
                else:
                    word += char
            TEMP_ARGS.append(word.strip())
            TYPES_IN_ARGS = []
            OUTPUT_LINE = ''
            if [True for x in TEMP_ARGS if '|' in x]:
                ERROR_REPORTING(LINE, "badFunction")
            for index in range(len(TEMP_ARGS)):
                TYPES_IN_ARGS.append(TEMP_ARGS[index].split(' ')[0])
                if TEMP_ARGS[index] == '': continue
                if TEMP_ARGS[index].startswith('*'): continue
                if TEMP_ARGS[index].startswith(GLOBAL_VARIABLES.DATA_TYPES) or CHECK_IF_DECLARED(TEMP_ARGS[index].split(' ')[0], LINE, 11, "badFunction"):
                    try:
                        TEMP_ARGS[index] = DATA_TYPE_TOKENS[TEMP_ARGS[index].split(' ')[0]](TOKENIZE_LINE(TEMP_ARGS[index])).strip() if TEMP_ARGS[index].split(' ')[0] in tuple(DATA_TYPE_TOKENS.keys()) else SYNTAX_ANALYSIS.__variable__.V_VARIABLE(TOKENIZE_LINE(TEMP_ARGS[index])).strip()
                    except:
                        ERROR_REPORTING(LINE, "badFunction")
            TYPES_IN_ARGS = [x for x in TYPES_IN_ARGS if x != '']
            REPLACE_TYPES = {
                'array' : 'array',
                'int' : 'int',
                'float' : 'float',
                'complex' : 'complex',
                'double' : 'double',
                'str' : 'str',
                'usize' : 'usize',
                'bool' : 'bool',

                'map' : 'map',
                'tuple' : 'tuple',
                'set' : 'set',
                'bytes' : 'bytes',
                'char' : 'char',
                'memoryview' : 'memoryview',
                'bytearray' : 'bytearray',
                'list' : 'list',

                'frozenset' : 'frozenset',
                'range' : 'range',
                'nullType' : 'nullType',
                'object' : 'object',
                'u8' : 'u8',
                'u16' : 'u16',
                'u32' : 'u32',
                'u64' : 'u64',

                'u128' : 'u128',
                'i8' : 'i8',
                'i16' : 'i16',
                'i32' : 'i32',
                'i64' : 'i64',
                'i128' : 'i128',
                'f32' : 'f32',
                'f64' : 'f64',
                'bin' : 'bin',
                'hex' : 'hex',

                'oct' : 'oct',

                'map' : 'dict',

                'array' : 'tuple',
                'int' : 'int',

                'u8' : 'int',
                'u16' : 'int',
                'u32' : 'int',
                'u64' : 'int',
                'u128' : 'int',
                'i8' : 'int',
                'i16' : 'int',
                'i32' : 'int',
                'i64' : 'int',
                'i128' : 'int',
                'f32' : 'float',
                'f64' : 'float',
                'usize' : 'type',
                'NULL' : 'None',
                'null' : 'None',
            } # if not in this dict, it is of type 'any'
            TYPES_IN_ARGS = [REPLACE_TYPES[x] if x in REPLACE_TYPES else 'any' for x in TYPES_IN_ARGS]
            WRAPPING = False
            WRAPPED_LINES = []
            if TYPES_IN_ARGS and not NO_AUTO_OVERLOAD:
                if not PRIVATE and INDENTATION_COUNT == 0:
                    try:
                        if FINAL_LIST[-1].startswith('@'):
                            WRAPPING = True
                            WRAPPED_LINES.append(FINAL_LIST[-1])
                            FINAL_LIST.pop()
                            for line in reversed(FINAL_LIST):
                                if line.startswith('@'):
                                    WRAPPED_LINES.append(line)
                                    FINAL_LIST.pop()
                                else: break
                    except: pass
                    OUTPUT_LINE = f'{INDENTATION*INDENTATION_COUNT}@overload({", ".join(TYPES_IN_ARGS)})\n'
                    if WRAPPING:
                        WRAPPED_LINES[-1] = WRAPPED_LINES[-1] + '\n'
                        OUTPUT_LINE += '\n'.join(WRAPPED_LINES)
                OUTPUT_LINE += ''.join([(INDENTATION*(INDENTATION_COUNT)), ' '.join(LINE[:2]), '(', ', '.join(TEMP_ARGS), ') ', RETURN_TYPE, ' '.join(LINE[-1:])])
            else:
                OUTPUT_LINE = ''.join([(INDENTATION*(INDENTATION_COUNT)), ' '.join(LINE[:2]), '(', ', '.join(TEMP_ARGS), ') ', RETURN_TYPE, ' '.join(LINE[-1:])])
            if not all([PRIVATE, KEYWORD]):
                if RETURN_TYPE.startswith('->'):
                    RETURN_TYPE = RETURN_TYPE[2:].strip()
                ASSIGN_FUNCTION(LINE[1], "REGULAR", ' '.join(LINE[2:-1]), RETURN_TYPE=RETURN_TYPE if RETURN_TYPE else 'None')
            elif KEYWORD and not PRIVATE:
                if RETURN_TYPE.startswith('->'):
                    RETURN_TYPE = RETURN_TYPE[2:].strip()
                ASSIGN_FUNCTION(LINE[1], "KEYWORD", ' '.join(LINE[2:-1]), RETURN_TYPE=RETURN_TYPE if RETURN_TYPE else 'None')
            return OUTPUT_LINE
        @staticmethod
        def V_ASYNC_FUNCTION(LINE: list) -> str:

            LINE = [x.strip() for x in LINE]
            if 'method' in LINE:
                ERROR_REPORTING(LINE, 'UsedAsyncAndMethod')
            LINE = LINE[2:]
            LINE.insert(0, 'def')
            ARGS_IN_LINE = ' '.join(LINE[3:-2]).strip()
            IN_STRING = False
            TEMP_ARGS = []*100
            word = ''
            for char in ARGS_IN_LINE:
                if char == '\"':
                    IN_STRING = LATCH(IN_STRING)
                if char == ',' and not IN_STRING:
                    TEMP_ARGS.append(word.strip())
                    word = ''
                else:
                    word += char
            TEMP_ARGS.append(word.strip())
            for index in range(len(TEMP_ARGS)):
                if TEMP_ARGS[index].startswith(GLOBAL_VARIABLES.DATA_TYPES):
                    TEMP_ARGS[index] = DATA_TYPE_TOKENS[TEMP_ARGS[index].split(' ')[0]](TOKENIZE_LINE(TEMP_ARGS[index]))
            OUTPUT_LINE = ''.join([(INDENTATION*INDENTATION_COUNT), ' '.join(LINE[:2]), '(', ', '.join(TEMP_ARGS), ') ', ' '.join(LINE[-1:])])
            ASSIGN_FUNCTION(LINE[1], "ASYNC", ' '.join(LINE[2:-1]))
            return ''.join([((INDENTATION*INDENTATION_COUNT) + '@_async\n'), OUTPUT_LINE])
        @staticmethod
        def V_AWAIT(LINE: list) -> str:

            OUTPUT_LINE = ''
            LINE = [x.strip() for x in LINE]
            LINE = LINE[1:]
            if '|' in LINE:
                LINE = ' '.join(LINE).split('|')
                for index in range(len(LINE)):
                    LINE[index] += '.join()'
                    OUTPUT_LINE += (INDENTATION*INDENTATION_COUNT) + LINE[index].strip() + '\n'
                return OUTPUT_LINE
            else:
                LINE.append('.join()')
                return (INDENTATION*INDENTATION_COUNT) + ' '.join(LINE)
        @staticmethod
        def V_COROUTINE(LINE: list) -> str:

            RELEASE_POOL: str = ''
            ARGUMENTS: list = []*100
            FUNCTIONS: list = []*100
            AWAIT: bool = False
            OUTPUT_LINE: str = ''
            T_ARGUMENTS: str = ''
            C_LINE = LINE.copy()
            if LINE[1] == 'await':
                AWAIT = True
                LINE.pop(1)
            if 'auto_clear' in LINE and '=' in LINE:
                RELEASE_POOL = f'TaskGroup.autorelease_pool({LINE[-1]})'
                try:
                    if isinstance(eval(LINE[-1]), bool): return (INDENTATION*INDENTATION_COUNT) + RELEASE_POOL
                    else: ERROR_REPORTING(C_LINE, "InvalidDynamicTask")
                except Exception:
                    ERROR_REPORTING(C_LINE, "InvalidDynamicTask")
                    return ''
                return (INDENTATION*INDENTATION_COUNT) + RELEASE_POOL
            elif 'clear' in LINE and '()' in LINE:
                return (INDENTATION*INDENTATION_COUNT) + 'TaskGroup.clear()'
            elif 'exec' in LINE:
                return (INDENTATION*INDENTATION_COUNT) + f'TaskGroup.execute({" ".join(LINE[3:-1]).replace("|", ",")})'
            elif 'delete' in LINE:
                return (INDENTATION*INDENTATION_COUNT) + f'TaskGroup.remove({" ".join(LINE[3:-1]).replace("|", ",")})'
            elif '|' in LINE or ( '(' in LINE and ')' in LINE ):
                LINE = LINE[1:]
                LINE = ' '.join(LINE).split('|') if '|' in LINE else LINE
                LINE = [x.strip() for x in LINE]
                if LINE[1] == '(' and LINE[-1] == ')':
                    ARGUMENTS.append(' '.join(LINE[2:-1]))
                    FUNCTIONS.append(LINE[0])
                else:
                    for i in range(len(LINE)):
                        if '(' in LINE[i] and ')' in LINE[i]:
                            for index, char in enumerate(LINE[i]):
                                if char == '(':
                                    T_ARGUMENTS = LINE[i][index+1:]
                                    break
                            # now do the same loop in reverse
                            for index, char in enumerate(LINE[i][::-1]):
                                if char == ')':
                                    T_ARGUMENTS += LINE[i][:index]
                                    break
                            ARGUMENTS.append(T_ARGUMENTS[:-1].strip())
                            T_ARGUMENTS = ''
                            FUNCTIONS.append(LINE[i].split('(')[0].strip())
                for i, j in zip(FUNCTIONS, ARGUMENTS):
                    j = f", {j}" if j != '' else ''
                    OUTPUT_LINE += (INDENTATION*INDENTATION_COUNT) + f"TaskGroup.add({i}{j})\n"
                return OUTPUT_LINE
            elif LINE.count('()') == 1:
                return (INDENTATION*INDENTATION_COUNT) + f"TaskGroup.add(task={LINE[1]})"
            else:
                ERROR_REPORTING(C_LINE, 'InvalidDynamicTask')
                return ' '
        @staticmethod
        def V_KEYWORD(LINE: list, CALL=False) -> str:
            global KEYWORDS, TOKENS, TOKEN_KEYS
            if '<<' in LINE:
                if LINE[0] not in tuple(KEYWORDS.keys()):
                    ERROR_REPORTING(LINE, 'InvalidKeyword')
                    return ''
                FINAL_ARGS = []
                for i in LINE[1:]:
                    if i != '<<':
                        FINAL_ARGS.append(i)
                FINAL_ARGS = FINAL_ARGS[0:]
                return INDENTATION*INDENTATION_COUNT + LINE[0] + '(' + ', '.join(FINAL_ARGS) + ')'
            else:
                LINE[0] = 'func' if LINE[0] == 'keyword' else LINE[0]
                KEYWORDS[LINE[1]] = LINE[3:-2]
                TOKENS[LINE[1]] = SYNTAX_ANALYSIS.__function__.V_KEYWORD
                TOKEN_KEYS = tuple(list(TOKEN_KEYS) + [LINE[1]])
                return SYNTAX_ANALYSIS.__function__.V_FUNCTION(LINE, KEYWORD=True)
    class __variable__:
        __doc__ = """
        \n Inputs: the line to change
        \n Outputs: the line with the variable changed
        \n Variable: <all types>, const, reference, kernel variables, let
        """
        __slots__ = 'LINE'
        @staticmethod
        def V_VARIABLE(LINE: list, SET_TYPE=None) -> str:
            FUNCTION_RETURN_TYPES: _MAP_ = ({
                'map'   : 'dict',
                'list'  : 'list',
                'array' : 'tuple',
                'set'   : 'set',
                'usize' : 'int',
                'i8'    : 'int',
                'i16'   : 'int',
                'i32'   : 'int',
                'i64'   : 'int',
                'i128'  : 'int',
                'u8'    : 'int',
                'u16'   : 'int',
                'u32'   : 'int',
                'u64'   : 'int',
                'u128'  : 'int',
                'f32'   : 'float',
                'f64'   : 'float'
            })

            KERNEL_DATA_TYPES: _MAP_ = ({
                'i8'    : 'int',
                'i16'   : 'int',
                'i32'   : 'int',
                'i64'   : 'int',
                'i128'  : 'int',
                'u8'    : 'int',
                'u16'   : 'int',
                'u32'   : 'int',
                'u64'   : 'int',
                'u128'  : 'int',
                'f32'   : 'float',
                'f64'   : 'float',
            })

            if 'func' == LINE[1]:
                SET_TYPE = LINE[0]
                if SET_TYPE in tuple(FUNCTION_RETURN_TYPES.keys()):
                    SET_TYPE = FUNCTION_RETURN_TYPES[SET_TYPE]

                SET_TYPE = f"-> {SET_TYPE}"
                return SYNTAX_ANALYSIS.__function__.V_FUNCTION(LINE[1:], RETURN_TYPE=SET_TYPE)
            if 'enum' == LINE[1]:
                SET_TYPE = LINE[0]
                if SET_TYPE in tuple(FUNCTION_RETURN_TYPES.keys()):
                    SET_TYPE = FUNCTION_RETURN_TYPES[SET_TYPE]
                return SYNTAX_ANALYSIS.__data_classes__.V_ENUM(LINE[1:], TYPE=LINE[0])
            if 'struct' == LINE[1]:
                SET_TYPE = LINE[0]
                if SET_TYPE in tuple(FUNCTION_RETURN_TYPES.keys()):
                    SET_TYPE = FUNCTION_RETURN_TYPES[SET_TYPE]
                return SYNTAX_ANALYSIS.__data_classes__.V_STRUCT(LINE[1:])

            def __CHECK_KERNEL_VARIABLES(DATA: list):
                # example: ['i32', 'a', '=', '10']
                # check the data after the equal sign
                DATA_TYPE: str = DATA[0]
                MULTI_DATA: bool = False
                ASSIGNMENT: bool = False
                if '=' in DATA:
                    ASSIGNMENT = True
                    LINE_BEFORE_EQUAL: list = DATA[:DATA.index('=')]
                    LINE_AFTER_EQUAL: list = DATA[DATA.index('=') + 1:]

                MAX_MIN_VALUES: _MAP_ = ({
                    'i8'  : (127, -128),
                    'i16' : (32767, -32768),
                    'i32' : (2147483647, -2147483648),
                    'i64' : (9223372036854775807, -9223372036854775808),
                    'i128': (170141183460469231731687303715884105727, -170141183460469231731687303715884105728),
                    'u8'  : (255, 0),
                    'u16' : (65535, 0),
                    'u32' : (4294967295, 0),
                    'u64' : (18446744073709551615, 0),
                    'u128': (340282366920938463463374607431768211455, 0),
                    'f32' : (3.4028235e+38, -3.4028235e+38),
                    'f64' : (1.7976931348623157e+308, -1.7976931348623157e+308)
                })

                if '=' in DATA and '|' in DATA:
                    MULTI_DATA = True
                    VARIABLES: list = LINE_BEFORE_EQUAL[1::2]
                    VARIABLES = [x.strip() for x in VARIABLES]
                    # get the values
                    VALUES: list = ' '.join(LINE_AFTER_EQUAL).split('|')
                    VALUES = [x.strip() for x in VALUES]
                copyi = ''
                if MULTI_DATA:
                    for i in VALUES:
                        copyi = i + ' '
                        try:
                            if i.startswith('0x'):
                                i = int(i, 16)
                            elif i.startswith('0b'):
                                i = int(i, 2)
                            elif i.startswith('0o'):
                                i = int(i, 8)
                            else:
                                copyi = ''
                                i = int(i)
                            if i > MAX_MIN_VALUES[DATA_TYPE][0] or i < MAX_MIN_VALUES[DATA_TYPE][1]:
                                #ERROR_REPORTING(DATA, 'ValueOutOfRange')
                                ERROR_REPORTING(DATA, 'InvalidValue', f"{copyi}{COLORS['yellow']}({i}){COLORS['red']}", f"Must be between {COLORS['yellow']}{MAX_MIN_VALUES[DATA_TYPE][0]}{COLORS['red']} and {COLORS['yellow']}{MAX_MIN_VALUES[DATA_TYPE][1]}{COLORS['red']}", copyi)
                        except (ValueError, TypeError, SyntaxError, UnboundLocalError, IndexError): pass
                elif ASSIGNMENT:
                    try:
                        if i.startswith('0x'):
                            copyi = LINE_AFTER_EQUAL[0] + ' '
                            i = int(i, 16)
                        elif i.startswith('0b'):
                            copyi = LINE_AFTER_EQUAL[0] + ' '
                            i = int(i, 2)
                        elif i.startswith('0o'):
                            copyi = LINE_AFTER_EQUAL[0] + ' '
                            i = int(i, 8)
                        else:
                            i = int(i)
                        if int(LINE_AFTER_EQUAL[0]) > MAX_MIN_VALUES[DATA_TYPE][0] or int(LINE_AFTER_EQUAL[0]) < MAX_MIN_VALUES[DATA_TYPE][1]:
                            ERROR_REPORTING(DATA, 'InvalidValue', f"{copyi}{COLORS['yellow']}({i}){COLORS['red']}", f"Must be between {COLORS['yellow']}{MAX_MIN_VALUES[DATA_TYPE][0]}{COLORS['red']} and {COLORS['yellow']}{MAX_MIN_VALUES[DATA_TYPE][1]}{COLORS['red']}", copyi)
                    except (ValueError, TypeError, SyntaxError, UnboundLocalError, IndexError): pass





            if LINE[0] in tuple(KERNEL_DATA_TYPES.keys()):
                __CHECK_KERNEL_VARIABLES(LINE)

            if LINE[0] in tuple(FUNCTION_RETURN_TYPES.keys()):
                LINE[0] = FUNCTION_RETURN_TYPES[LINE[0]]

            def __RETURN_BLANK_DATA(VAR: list):
                try: BLANK_DATA = GLOBAL_VARIABLES.BLANK_DATA[VAR[0]]
                except KeyError: ERROR_REPORTING(VAR, 'InvalidDataType')
                ASSIGN_VARIABLE(VAR[1], VAR[0], BLANK_DATA)
                return f'{INDENTATION*INDENTATION_COUNT}{VAR[1]}: {VAR[0]} = {BLANK_DATA}'



            def FIX_LENGTH_OF_LIST(LINE_BEFORE_EQUAL):
                """
                LINE_BEFORE_EQUAL = ['list', '*', '[', '10', ']', 'a']
                or
                LINE_BEFORE_EQUAL = ['list', '*', '[', 'len', '(', 'hf', ')', ']', 'a', ',', 'b', ',', 'c']
                output 1:
                    a: list = fixed_list(10)
                output 2:
                    a: list = fixed_list(len(hf))
                    b: list = fixed_list(len(hf))
                    c: list = fixed_list(len(hf))
                NOTE: ANYTHING CAN BE THE MULTIPLIER, NOT JUST A NUMBER OR LEN()
                """
                for i in reversed(range(len(LINE_BEFORE_EQUAL))):
                    if LINE_BEFORE_EQUAL[i] == ']':
                        break
                MULTIPLIER = ' '.join(LINE_BEFORE_EQUAL[3:i])
                ASSIGN_VARIABLE(LINE_BEFORE_EQUAL[i+1::2], "list", f"fixed_list({MULTIPLIER})")
                return '\n'.join(f'{INDENTATION*INDENTATION_COUNT}{x}: list = fixed_list({MULTIPLIER})' for x in LINE_BEFORE_EQUAL[i+1::2])

            def __MULTI_VAR_W_VALUES(LINE_BEFORE_EQUAL, LINE_AFTER_EQUAL):
                """
                example line that will fall into this category:
                LINE_BEFORE_EQUAL = ['int', 'a', ',', 'b', ',', 'c']
                LINE_AFTER_EQUAL = ['10', '|', '10', '|', '10']
                or
                LINE_BEFORE_EQUAL = ['int', 'a', ',', 'b', ',', 'c']
                LINE_AFTER_EQUAL = ['{', 'f"1"', ':', '2', ',', 'f"6"', ':', '2', '}']
                NOTE: There can be any number of variables and values in the line, but the number of variables and values must be the same
                """
                DATA_TYPE: str = LINE_BEFORE_EQUAL[0]

                # get the variables
                VARIABLES: list = LINE_BEFORE_EQUAL[1::2]
                VARIABLES = [x.strip() for x in VARIABLES]

                # get the values
                VALUES: list = ' '.join(LINE_AFTER_EQUAL).split('|')
                VALUES = [x.strip() for x in VALUES]

                # check if the number of variables and values are the same
                if len(VARIABLES) != len(VALUES):
                    ERROR_REPORTING(LINE, 'InvalidNumberOfVariablesToValues')
                    return ''

                OUTPUT: str = ''
                FINAL_DATA: str = ''

                for i in range(len(VARIABLES)):
                    FINAL_DATA = CHECK_DATA_TYPE(LINE, DATA_TYPE, VALUES[i])
                    if FINAL_DATA == 'None': break
                    if FINAL_DATA != '':
                        OUTPUT += f'{INDENTATION*INDENTATION_COUNT}{VARIABLES[i]}: {DATA_TYPE} = {FINAL_DATA}\n'
                        ASSIGN_VARIABLE(VARIABLES[i], DATA_TYPE, FINAL_DATA)
                return OUTPUT if FINAL_DATA != 'None' else ''

            def __MULTI_VAR_WO_VALUES(LINE_BEFORE_EQUAL):
                """
                example line that will fall into this category:
                LINE_BEFORE_EQUAL = ['int', 'a', ',', 'b', ',', 'c']
                """
                DATA_TYPE: str = LINE_BEFORE_EQUAL[0]
                VARIABLES: list = LINE_BEFORE_EQUAL[1::2]
                VARIABLES = [x.strip() for x in VARIABLES]
                OUTPUT: str = ''
                NO_BLANK: bool = False
                try: BLANK_DATA: str = GLOBAL_VARIABLES.BLANK_DATA[DATA_TYPE]
                except KeyError: NO_BLANK = True
                for i in VARIABLES:
                    if NO_BLANK:
                        OUTPUT += f'{INDENTATION*INDENTATION_COUNT}{i}: {DATA_TYPE} = {DATA_TYPE}()\n'
                        ASSIGN_VARIABLE(i, DATA_TYPE, f'{DATA_TYPE}()')
                    else:
                        ASSIGN_VARIABLE(i, DATA_TYPE, BLANK_DATA)
                        OUTPUT += f'{INDENTATION*INDENTATION_COUNT}{i}: {DATA_TYPE} = {BLANK_DATA}\n'
                return OUTPUT
            def __MULTI_VAR_W1_VALUE(LINE_BEFORE_EQUAL, LINE_AFTER_EQUAL, TYPE=None):
                """
                example line that will fall into this category:
                LINE_BEFORE_EQUAL = ['int', 'a', ',', 'b', ',', 'c']
                LINE_AFTER_EQUAL = ['10']
                """
                DATA_TYPE: str = LINE_BEFORE_EQUAL[0]
                VARIABLES: list = LINE_BEFORE_EQUAL[1::2]
                VARIABLES = [x.strip() for x in VARIABLES]
                if not TYPE:
                    FINAL_DATA: str = CHECK_DATA_TYPE(LINE, DATA_TYPE, ' '.join(LINE_AFTER_EQUAL))
                    if FINAL_DATA == 'None': return ''
                else:
                    FINAL_DATA: str = ' '.join(LINE_AFTER_EQUAL)
                OUTPUT: str = ''
                for i in VARIABLES:
                    OUTPUT += f'{INDENTATION*INDENTATION_COUNT}{i}: {DATA_TYPE} = {FINAL_DATA}\n'
                    ASSIGN_VARIABLE(i, DATA_TYPE, FINAL_DATA)
                return OUTPUT
            def __SIMPLE_SINGLE_VAR_VALUE(LINE_BEFORE_EQUAL, LINE_AFTER_EQUAL, TYPE=None):
                """
                example line that will fall into this category:
                LINE_BEFORE_EQUAL = ['int', 'a']
                LINE_AFTER_EQUAL = ['10']
                """
                DATA_TYPE: str = LINE_BEFORE_EQUAL[0]
                VARIABLE: str = LINE_BEFORE_EQUAL[1]
                if not TYPE:
                    FINAL_DATA: str = CHECK_DATA_TYPE(LINE, DATA_TYPE, ' '.join(LINE_AFTER_EQUAL))
                    if FINAL_DATA == 'None': return ''
                else:
                    FINAL_DATA: str = ' '.join(LINE_AFTER_EQUAL)
                OUTPUT: str = ''
                OUTPUT += f'{INDENTATION*INDENTATION_COUNT}{VARIABLE}: {DATA_TYPE} = {FINAL_DATA}'
                ASSIGN_VARIABLE(VARIABLE, DATA_TYPE, FINAL_DATA)
                return OUTPUT

            if '=' in LINE:
                LINE_BEFORE_EQUAL: list = LINE[:LINE.index('=')]
                LINE_AFTER_EQUAL: list = LINE[LINE.index('=') + 1:]
                MULTI_VAR_WITH_VALUE: bool = False
                MULTI_VAR_WITH_1_VALUE: bool = False
                try:
                    if LINE_AFTER_EQUAL[0] == 'new':
                        LINE_AFTER_EQUAL = LINE_AFTER_EQUAL[1:]

                        if CHECK_IF_DECLARED(LINE_AFTER_EQUAL[0], LINE, TYPE=11):
                            if ',' in LINE_BEFORE_EQUAL:
                                return __MULTI_VAR_W1_VALUE(LINE_BEFORE_EQUAL, LINE_AFTER_EQUAL, TYPE="INSTANCE")
                            else:
                                return __SIMPLE_SINGLE_VAR_VALUE(LINE_BEFORE_EQUAL, LINE_AFTER_EQUAL, TYPE="INSTANCE")
                        else:
                            return ''
                except IndexError:
                    pass

                if 'list' == LINE[0] and '*' == LINE[1]:
                    FUNCTION_RETURN_TYPES = {v: k for k, v in FUNCTION_RETURN_TYPES.items()}
                    if LINE[0] in tuple(FUNCTION_RETURN_TYPES.keys()): LINE[0] = FUNCTION_RETURN_TYPES[LINE[0]]
                    ERROR_REPORTING(LINE, 'InvalidListDeclaration')
                    return ''
                if '*' == LINE[1]:
                    FUNCTION_RETURN_TYPES = {v: k for k, v in FUNCTION_RETURN_TYPES.items()}
                    if LINE[0] in tuple(FUNCTION_RETURN_TYPES.keys()): LINE[0] = FUNCTION_RETURN_TYPES[LINE[0]]
                    ERROR_REPORTING(LINE, 'CanNotFixSize'); return ''

                if '|' in LINE_AFTER_EQUAL:
                    MULTI_VAR_WITH_VALUE = True if ',' in LINE_BEFORE_EQUAL else False

                if ',' in LINE_BEFORE_EQUAL:
                    MULTI_VAR_WITH_1_VALUE = True if '|' not in LINE_AFTER_EQUAL else False

                #print(MULTI_VAR_WITH_VALUE, MULTI_VAR_WITH_1_VALUE, LINE_BEFORE_EQUAL, LINE_AFTER_EQUAL)

                if MULTI_VAR_WITH_VALUE is True:
                    return __MULTI_VAR_W_VALUES(LINE_BEFORE_EQUAL, LINE_AFTER_EQUAL)
                elif MULTI_VAR_WITH_1_VALUE is True:
                    return __MULTI_VAR_W1_VALUE(LINE_BEFORE_EQUAL, LINE_AFTER_EQUAL)
                else:
                    return __SIMPLE_SINGLE_VAR_VALUE(LINE_BEFORE_EQUAL, LINE_AFTER_EQUAL)
            else:
                if 'list' == LINE[0] and '*' == LINE[1]: return FIX_LENGTH_OF_LIST(LINE)
                if '*' == LINE[1]:
                    FUNCTION_RETURN_TYPES = {v: k for k, v in FUNCTION_RETURN_TYPES.items()}
                    if LINE[0] in tuple(FUNCTION_RETURN_TYPES.keys()): LINE[0] = FUNCTION_RETURN_TYPES[LINE[0]]
                    ERROR_REPORTING(LINE, 'CanNotFixSize'); return ''

                if ',' in LINE:
                    return __MULTI_VAR_WO_VALUES(LINE)
                else:
                    return __RETURN_BLANK_DATA(LINE)
        @staticmethod
        def V_CONSTANT(LINE: list) -> str:
            if INDENTATION_COUNT != 0: ERROR_REPORTING(LINE, 'ConstCallOutsideGlobal')
            return SYNTAX_ANALYSIS.__variable__.V_VARIABLE(LINE[1:], SET_TYPE='constant')
        @staticmethod
        def V_REFERENCE(LINE: list) -> str:
            # check if what is after the = is declared
            if '=' in LINE:
                for index, char in enumerate(LINE):
                    if char == '(':
                        break
                VAR_NAME: str = LINE[index - 1]
                if CHECK_IF_DECLARED(VAR_NAME, LINE, ERROR='InvalidReference') is False:
                    if VAR_NAME != 'pack' or VAR_NAME != 'unpack' or VAR_NAME != 'frozenset' or VAR_NAME != 'exec' or VAR_NAME != 'malloc' or VAR_NAME != 'free':
                        return ' '
                OUTPUT_LINE: str = (' '.join(LINE))[4:]
                # remove the first 4 characters from output line
                return ''.join([(INDENTATION*INDENTATION_COUNT), OUTPUT_LINE])
            else:
                for i in range(len(LINE)):
                    if LINE[i] == 'ref':
                        LINE[i] = 'global'
                        break
                OUTPUT_LINE: str = ' '.join(LINE)
                return ''.join([(INDENTATION*INDENTATION_COUNT), OUTPUT_LINE])
        @staticmethod
        def V_KERNEL_VARS(LINE: list) -> str:
            return SYNTAX_ANALYSIS.__variable__.V_VARIABLE(LINE, SET_TYPE='kernel')
        @staticmethod
        def V_LETTER(LINE: list) -> str:
            if CHECK_IF_DECLARED(LINE[1], LINE, TYPE=11, ERROR='VariableNotDeclared') is False:
                return ' '
            ITEM = CHECK_IF_DECLARED(LINE[1], LINE, TYPE=11, ERROR='VariableNotDeclared', RETURN_ITEM=True)
            try:
                if ITEM[1]['type'] == 'constant':
                    ERROR_REPORTING(LINE, 'AssignedValueToConstant')
                    return ' '
            except IndexError: pass
            return f'{INDENTATION*INDENTATION_COUNT}{" ".join(LINE[1:])}'
        @staticmethod
        def V_FINAL(LINE: list) -> str:
            OUTPUT = LINE[1:] + [':', 'Final']
            if '=' in OUTPUT:
                ERROR_REPORTING(LINE, 'TriedToAssignValueToFinal')
                return ' '
            if 'ptr' in LINE and '<' in LINE and '>' in LINE:
                # line: final<ptr> var_name
                VAR_NAME = LINE[LINE.index('>')+1]
                return f'{INDENTATION*INDENTATION_COUNT}{VAR_NAME} = {VAR_NAME}[0]'
            return f'{INDENTATION*INDENTATION_COUNT}{" ".join(OUTPUT)}'
        @staticmethod
        def V_COPY(LINE: list) -> str:
            # line: copy var_name = new_var_name
            # output: new_var_name = var_name
            # create a regex to get the var name and the new var name
            if len(LINE) != 5:
                ERROR_REPORTING(LINE, 'InvalidCopySyntax')
                return ' '
            VAR_NAME = LINE[1]
            NEW_VAR_NAME = LINE[4]
            return f'{INDENTATION*INDENTATION_COUNT}{NEW_VAR_NAME} = copy({VAR_NAME})'
        @staticmethod
        def V_REMOVE(LINE: list) -> str:
            # line: rem var_name
            # output: del var_name
            if len(LINE) <= 1:
                ERROR_REPORTING(LINE, 'InvalidRemoveSyntax')
                return ' '
            LINE[0] = 'del'
            return f'{INDENTATION*INDENTATION_COUNT}{" ".join(LINE)}'
        @staticmethod
        def V_TYPE(LINE: list) -> str:
            if len(LINE) <= 1 or len(LINE) >= 3:
                if'=' not in LINE:
                    ERROR_REPORTING(LINE, 'InvalidTypeSyntax')
                    return ' '
            if '=' in LINE:
                LINE.pop(0)
                ASSIGN_CLASS(LINE[0], "TYPE")
                return f'{INDENTATION*INDENTATION_COUNT}{" ".join(LINE)}'
            LINE.append(':')
            LINE[0] = 'class'
            LINE.append('pass')
            if '=' not in LINE: ASSIGN_CLASS(LINE[1], "TYPE")
            return f'{INDENTATION*INDENTATION_COUNT}{" ".join(LINE)}'
        @staticmethod
        def V_SELF(LINE: list) -> str:
            return f'{INDENTATION*INDENTATION_COUNT}{" ".join(LINE)}'
        @staticmethod
        def V_SUPER(LINE: list) -> str:
            return f'{INDENTATION*INDENTATION_COUNT}{" ".join(LINE)}'
    class __data_classes__:
        __doc__ = """
        \n Inputs: the line to change
        \n Outputs: the line with the changes
        \n Variable: struct, static, enum, class
        """
        __slots__ = 'LINE', 'TYPE'
        @staticmethod
        def V_STRUCT(LINE: list) -> str:
            if '=' in LINE:
                ERROR_REPORTING(LINE, 'TriedToAssignValueToDataClass')
                return ' '
            ORG_LINE: str = LINE.copy()
            LINE[0] = f'{INDENTATION*INDENTATION_COUNT}class'
            OUTPUT_LINE: str = ' '.join(LINE)
            OUTPUT_LINE = f"{INDENTATION*INDENTATION_COUNT}@dataclass(slots=True)\n" + OUTPUT_LINE
            ASSIGN_CLASS(ORG_LINE[1], "STRUCT")
            return OUTPUT_LINE
        @staticmethod
        def V_STATIC(LINE: list) -> str:
            # remove the first word
            ORG_LINE = LINE.copy()
            if 'enum' in LINE:
                ORG_LINE: str = LINE.copy()
                LINE = LINE[1:]
                LINE[0] = f'{INDENTATION*INDENTATION_COUNT}class'
                OUTPUT_LINE: str = ' '.join(LINE)
                ASSIGN_CLASS(ORG_LINE[2], "STATIC ENUM")
                return OUTPUT_LINE
            elif 'struct' in LINE:
                ORG_LINE: str = LINE.copy()
                LINE = LINE[1:]
                LINE[0] = f'{INDENTATION*INDENTATION_COUNT}class'
                OUTPUT_LINE: str = ' '.join(LINE)
                OUTPUT_LINE = f"{INDENTATION*INDENTATION_COUNT}@dataclass(slots=True)\n" + OUTPUT_LINE
                ASSIGN_CLASS(ORG_LINE[1], "STATIC STRUCT")
                return OUTPUT_LINE
            LINE[0] = ''
            LINE = [ x for x in LINE if x != '' ]
            LINE.append(': Final')
            OUTPUT_LINE: str = ' '.join(LINE)
            # get the value of the variable
            try:
                VAR_VALUE = GET_VARIABLE(LINE[0], 0)
            except KeyError:
                ERROR_REPORTING(ORG_LINE, 'VariableNotDeclared', LINE[0])
                return ' '
            ASSIGN_VARIABLE(LINE[0], "STATIC", GET_VARIABLE(LINE[0], 0))
            return ''.join([(INDENTATION*INDENTATION_COUNT), OUTPUT_LINE])
        @staticmethod
        def V_ENUM(LINE: list, TYPE=None) -> str:
            # enum.IntEnum
            if TYPE == None:
                ORG_LINE: str = LINE.copy()
                LINE[0] = f'{INDENTATION*INDENTATION_COUNT}class'
                OUTPUT_LINE: str = ' '.join(LINE)
                ASSIGN_CLASS(ORG_LINE[1], "ENUM")
                return OUTPUT_LINE
            else:
                if TYPE == 'int':
                    TYPE = 'IntEnum'
                elif TYPE == 'str':
                    TYPE = 'StrEnum'
                else:
                    LINE.insert(0, TYPE)
                    ERROR_REPORTING(LINE, 'InvalidEnumType')
                    return ' '
                ORG_LINE: str = LINE.copy()
                LINE[0] = f'{INDENTATION*INDENTATION_COUNT}class'
                LINE[1] = LINE[1] + f'(enum.{TYPE})'
                OUTPUT_LINE: str = ' '.join(LINE)
                ASSIGN_CLASS(ORG_LINE[1], "ENUM")
                return OUTPUT_LINE
        @staticmethod
        def V_CLASS(LINE: list) -> str:
            LINE = [x.strip() for x in LINE]
            if 'extends' in LINE:
                VAR_TO_CHECK = LINE[LINE.index('extends') + 1]
                LINE[LINE.index('extends')] = '('
                LINE.insert(-1, ')')
                FOUND: bool = False
                FOUND = True if VAR_TO_CHECK in tuple(CLASSES.keys()) else FOUND
                if FOUND is False:
                    ERROR_REPORTING(LINE, "InvalidExtends", VAR_TO_CHECK)
                    LINE[2] = ''
                    LINE[3] = ''
                    ASSIGN_CLASS(LINE[1], "REGULAR")
                    (INDENTATION*INDENTATION_COUNT) + ' '.join(LINE)
                else: FOUND = True
            ASSIGN_CLASS(LINE[1], "REGULAR")
            return (INDENTATION*INDENTATION_COUNT) + ' '.join(LINE)
        @staticmethod
        def V_POINTER(LINE: list) -> str:
            # TODO: add error reporting, if the variable is not declared, assign it to the variable, and other checks
            for index, i in enumerate(LINE):
                if i == '=':
                    break
            VAR_VAL = ' '
            if len(LINE) >= index+2:
                if LINE[index+1] == 'new':
                    VAR_VAL = ' '.join(LINE[index+2:])
                else:
                    VAR_VAL = ' '.join(LINE[index+1:])
            OUTPUT_LINE: str = ' '
            OUTPUT_LINE = f"{INDENTATION*INDENTATION_COUNT}{LINE[1]} = [{VAR_VAL}]"
            if 'ref' in LINE and '<' in LINE and '>' in LINE:
                OUTPUT_LINE = f"{INDENTATION*INDENTATION_COUNT}{LINE[4]} = {VAR_VAL}"
            elif len(LINE) >= index+2:
                if LINE[index+1] == 'new':
                    OUTPUT_LINE = f"{INDENTATION*INDENTATION_COUNT}{LINE[1]}[0] = {VAR_VAL}"
            return OUTPUT_LINE

KEYWORD_TOKENS: dict[str, object] = {
    # ------------------------------ ACCESS MODIFIERS ------------------------------- #
    'public'           : SYNTAX_ANALYSIS. __access_modifiers__ .V_PUBLIC        ,
    'priv'             : SYNTAX_ANALYSIS. __access_modifiers__ .V_PRIVATE       ,
    'method'           : SYNTAX_ANALYSIS. __access_modifiers__ .V_METHOD        ,
    'with'             : SYNTAX_ANALYSIS. __access_modifiers__ .V_WITH          ,
    'call'             : SYNTAX_ANALYSIS. __access_modifiers__ .V_CALL          ,
    'raw'              : SYNTAX_ANALYSIS. __access_modifiers__ .V_RAW           ,
    # -------------------------------- CONTROL FLOW --------------------------------- #
    'if'               : SYNTAX_ANALYSIS.   __control_flow__   .V_IF            ,
    'else'             : SYNTAX_ANALYSIS.   __control_flow__   .V_ELSE          ,
    'else if'          : SYNTAX_ANALYSIS.   __control_flow__   .V_ELSE_IF       ,
    'for'              : SYNTAX_ANALYSIS.   __control_flow__   .V_FOR           ,
    'while'            : SYNTAX_ANALYSIS.   __control_flow__   .V_WHILE         ,
    'return'           : SYNTAX_ANALYSIS.   __control_flow__   .V_RETURN        ,
    'assert'           : SYNTAX_ANALYSIS.   __control_flow__   .V_ASSERT        ,
    # -------------------------------- DATA CLASSES --------------------------------- #
    'class'            : SYNTAX_ANALYSIS.   __data_classes__   .V_CLASS         ,
    'struct'           : SYNTAX_ANALYSIS.   __data_classes__   .V_STRUCT        ,
    'static'           : SYNTAX_ANALYSIS.   __data_classes__   .V_STATIC        ,
    'enum'             : SYNTAX_ANALYSIS.   __data_classes__   .V_ENUM          ,
    'ptr'              : SYNTAX_ANALYSIS.   __data_classes__   .V_POINTER       ,
    # --------------------------------- FUNCTIONS ----------------------------------- #
    'func'             : SYNTAX_ANALYSIS.     __function__     .V_FUNCTION      ,
    'async'            : SYNTAX_ANALYSIS.     __function__     .V_ASYNC_FUNCTION,
    'keyword'          : SYNTAX_ANALYSIS.     __function__     .V_KEYWORD       ,
    'await'            : SYNTAX_ANALYSIS.     __function__     .V_AWAIT         ,
    'coroutine'        : SYNTAX_ANALYSIS.     __function__     .V_COROUTINE     ,
    # --------------------------------- VARIABLES ----------------------------------- #
    'const'            : SYNTAX_ANALYSIS.     __variable__     .V_CONSTANT      ,
    'ref'              : SYNTAX_ANALYSIS.     __variable__     .V_REFERENCE     ,
    'copy'             : SYNTAX_ANALYSIS.     __variable__     .V_COPY          ,
    'let'              : SYNTAX_ANALYSIS.     __variable__     .V_LETTER        ,
    'final'            : SYNTAX_ANALYSIS.     __variable__     .V_FINAL         ,
    'rem'              : SYNTAX_ANALYSIS.     __variable__     .V_REMOVE        ,
    'type'             : SYNTAX_ANALYSIS.     __variable__     .V_TYPE          ,
    # ------------------------------- INPUT/OUTPUT ---------------------------------- #
    'out'              : SYNTAX_ANALYSIS.        __io__        .V_OUTPUT        ,
    'in'               : SYNTAX_ANALYSIS.        __io__        .V_INPUT         ,
    'include'          : SYNTAX_ANALYSIS.        __io__        .V_INCLUDE       ,
    'import'           : SYNTAX_ANALYSIS.        __io__        .V_IMPORT        ,
    'from'             : SYNTAX_ANALYSIS.        __io__        .V_FROM          ,
    'pyc'              : SYNTAX_ANALYSIS.        __io__        .V_PYC           ,
    # ------------------------------ End of Tokens ---------------------------------- #
    }
METHOD_CALL_TOKENS: dict[str, object] = {
    # --------------------------------- METHODS ------------------------------------- #
    '@'                : SYNTAX_ANALYSIS. __access_modifiers__ .V_AT            ,
    # ------------------------------ End of Tokens ---------------------------------- #
    }
DATA_TYPE_TOKENS: dict[str, object] = {
    # -------------------------------- DATA TYPES ----------------------------------- #
    'int'              : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'float'            : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'complex'          : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'double'           : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'str'              : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'usize'            : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'bool'             : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'list'             : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'map'              : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'array'            : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'bin'              : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'hex'              : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'oct'              : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'set'              : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'bytes'            : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'object'           : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'char'             : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'memoryview'       : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'bytearray'        : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'frozenset'        : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'range'            : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'None'             : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'NoneType'         : SYNTAX_ANALYSIS.     __variable__     .V_VARIABLE      ,
    'super'            : SYNTAX_ANALYSIS.     __variable__     .V_SUPER         ,
    'self'             : SYNTAX_ANALYSIS.     __variable__     .V_SELF          ,
    # ----------------------------- KERNEL VARIABLES -------------------------------- #
    'u8'               : SYNTAX_ANALYSIS.     __variable__     .V_KERNEL_VARS   ,
    'u16'              : SYNTAX_ANALYSIS.     __variable__     .V_KERNEL_VARS   ,
    'u32'              : SYNTAX_ANALYSIS.     __variable__     .V_KERNEL_VARS   ,
    'u64'              : SYNTAX_ANALYSIS.     __variable__     .V_KERNEL_VARS   ,
    'u128'             : SYNTAX_ANALYSIS.     __variable__     .V_KERNEL_VARS   ,
    'i8'               : SYNTAX_ANALYSIS.     __variable__     .V_KERNEL_VARS   ,
    'i16'              : SYNTAX_ANALYSIS.     __variable__     .V_KERNEL_VARS   ,
    'i32'              : SYNTAX_ANALYSIS.     __variable__     .V_KERNEL_VARS   ,
    'i64'              : SYNTAX_ANALYSIS.     __variable__     .V_KERNEL_VARS   ,
    'i128'             : SYNTAX_ANALYSIS.     __variable__     .V_KERNEL_VARS   ,
    'f32'              : SYNTAX_ANALYSIS.     __variable__     .V_KERNEL_VARS   ,
    'f64'              : SYNTAX_ANALYSIS.     __variable__     .V_KERNEL_VARS   ,
    # ------------------------------ End of Tokens ---------------------------------- #
    }

TOKENS: dict[str, object] = KEYWORD_TOKENS | METHOD_CALL_TOKENS | DATA_TYPE_TOKENS
TOKEN_KEYS = tuple(TOKENS.keys())

def memoize(func) -> Callable:
    memo = {}
    def helper(*args):
        if args not in memo:
            memo[args] = func(*args)
        return memo[args]
    return helper

# ----------- Wrapper Functions ----------- #
def MEMOIZE(func) -> Callable:
    @wraps(func)
    def MEMOIZE__FUNCTION(*args, **kwargs):
        KEY = args + tuple(kwargs.items())
        if KEY not in MEMOIZE__FUNCTION.cache:
            MEMOIZE__FUNCTION.cache[KEY] = func(*args, **kwargs)
        return MEMOIZE__FUNCTION.cache[KEY]
    MEMOIZE__FUNCTION.cache: OrderedDict = OrderedDict()
    return MEMOIZE__FUNCTION
def OVERLOAD(*TYPES) -> Callable:
    def __register__(FUNCTION):
        NAME = FUNCTION.__name__
        D_INST = OVERLOAD_FUNCTION_REG.get(NAME)
        if D_INST is None:
            D_INST = OVERLOAD_FUNCTION_REG[NAME] = DISPATCH(NAME)
        D_INST.__register__(TYPES, FUNCTION)
        return D_INST
    return __register__
def EXEC_TIME(fn) -> Callable:
    """
    A decorator that prints the execution time for the decorated function. (in this case the INITIALIZER function)
    """
    def wrapper_function(*args, **kwargs):
        start_time = perf_counter()
        # invoking the wrapped function and getting the return value.
        value = fn(*args, **kwargs)
        time_diff = perf_counter() - start_time
        # round the time difference to 5 decimal places
        time_diff = round(time_diff, 5)
        temp_time_diff = str(time_diff).split('.')
        from random import randint
        amount = randint(1, 9)
        # check what the first number is in temp_time_diff[1]
        while True:
            if int(temp_time_diff[1][0]) - amount < 0:
                amount -= 1
            else: break
        if amount <= 0:
            amount = 0
        amount = f"0.{amount}"
        amount = float(amount)
        if time_diff-amount <= 0.0:
            amount = 0.0
        # get the exit code of the process
        from sys import platform
        from os import getpid
        if platform == 'win32':
            value = console(f"taskkill /F /T /PID {getpid()}")
        else:
            value = console(f"kill -9 {getpid()}")
        if value == None: value = 0
        if ALWAYS_MONITOR_PERF_DATA or '-p' in PASS_LIST:
            SHOW_PERF_DATA(time_diff, amount, TERMINAL_WIDTH)
        if KEEP_PERF_DATA:
            SAVE_PERF_DATA(time_diff, amount, TERMINAL_WIDTH)
        return value
    return wrapper_function

# ---------- Initializer Functions ---------- #
@MEMOIZE
def INITIALIZE() -> None:
    __doc__ = """
    \n Inputs: None
    \n Outputs: None
    \n This is the first stage of the Versace compiler.
    \n This stage is used to get the config data and the Versace code.
    \n It also checks if the required modules are installed. and saves that information to a .pkg file.
    """
    REQUIRED_MODULES = {'psutil', 'astpretty', 'rich', 'pyinstaller', 'sv-ttk', 'pygments', 'pyyaml'}
    # check if the user is using a environment
    if SYSTEM.is_venv():
        print(f"{COLORS['red']}[WARNING]{COLORS['yellow']} You are using a virtual environment. You may need to reinstall the following modules manually. \n\t{COLORS['magenta']}1) psutil\n\t2) astpretty\n\t3) rich\n\t4) pyinstaller\n\t5) sv-ttk\n{COLORS['reset']}")

    if SYSTEM.path_exists(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + 'base' + path_sep + 'packages.pkg'):
        with open(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + 'base' + path_sep + 'packages.pkg', 'r') as f:
            INSTALLED_MODULES = eval(f.read())
        MISSING_MODULES = REQUIRED_MODULES - INSTALLED_MODULES
        if MISSING_MODULES:
            _system("")
            remove(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + 'base' + path_sep + 'packages.pkg')
            print(f"{COLORS['red']}The following modules are missing: {MISSING_MODULES}{COLORS['reset']}")
            print(f"{COLORS['red']}Re-run Versace to install them and try again.{COLORS['reset']}")
            exit(1)
    if SYSTEM.path_exists(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + 'base' + path_sep + 'packages.pkg') is False:
        from pkg_resources import working_set
        _system("")
        REQUIRED_MODULES = {'psutil', 'astpretty', 'rich', 'pyinstaller', 'sv-ttk', 'pygments', 'cx_Freeze', 'pyyaml'}
        INSTALLED_MODULES = {pkg.key for pkg in working_set}
        MISSING_MODULES = REQUIRED_MODULES - INSTALLED_MODULES

        if MISSING_MODULES:
            PYTHON_PATH = ORG_PYTHON_PATH
            check_call([PYTHON_PATH, '-m', 'pip', 'install', *MISSING_MODULES], stdout=DEVNULL)
            print(f"{COLORS['green']}Installed MISSING MODULES modules successfully{COLORS['reset']}")

    if SYSTEM.path_exists(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + 'base' + path_sep + 'packages.pkg'):
        if v_stat(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + 'base' + path_sep + 'packages.pkg') == 0:
            remove(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + 'base' + path_sep + 'packages.pkg')
    if SYSTEM.path_exists(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + 'base') is False:
        SYSTEM.make_dirs(SYSTEM.get_user_dir() + path_sep + '.versace', exist_ok=True)
        SYSTEM.make_dirs(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + 'base', exist_ok=True)
    if SYSTEM.path_exists(SYSTEM.get_user_dir() + path_sep + '.versace' + path_sep + 'base' + path_sep + 'packages.pkg') is False:
        with open(f"{SYSTEM.get_user_dir()}{path_sep}.versace{path_sep}base{path_sep}packages.pkg", "w", encoding="utf-8") as f:
            f.write(str(INSTALLED_MODULES))
            f.close()
@MEMOIZE
def READ_SYS_ARGS() -> None:
    CONFIG_DATA_SHOULD = ( \
        'always_monitor_perf_data', 'max_includes', 'traceback_limit', 'no_python',
        'allow_update', 'versace_path', 'no_args_start', 'keep_perf_data',
        'binary', 'use_cache', 'indentation', 'no_includes', 'python_path',
        'allow_tracking', 'binary_file_ext', 'no_version_check', 'transpile_file_ext',
    )

    _system("")

    if SYSTEM.path_exists(f"{SYSTEM.get_c_dir()}{path_sep}.versace.cfg"):
        with open(f"{SYSTEM.get_c_dir()}{path_sep}.versace.cfg", "r", encoding="utf-8") as f:
            CONFIG_DATA = f.read()
            f.close()
        for i in CONFIG_DATA_SHOULD:
            if i not in CONFIG_DATA:
                if '-cfg' in PASS_LIST:
                    with open(f"{SYSTEM.get_c_dir()}{path_sep}.versace.cfg", "w", encoding="utf-8") as f:
                        f.write(CREATE_CONFIG_FILE(f))
                        f.close()
                    print(f"{COLORS['red']}Run Versace again to apply the changes.{COLORS['reset']}"); exit()
                raise VersaceCodeBaseError(f"Config file is missing key: {i} \n{COLORS['yellow']}Add the missing key to the config file or delete the config file and create a new one with the {COLORS['green']}'-cfg'{COLORS['yellow']} flag{COLORS['reset']}")
        READ_CONFIG(CONFIG_DATA, FILE_PATH=f"{SYSTEM.get_c_dir()}{path_sep}.versace.cfg")

    else:
        if SYSTEM.path_exists(f"{SYSTEM.get_user_dir()}{path_sep}.versace{path_sep}base{path_sep}default-versace.cfg") is False:
            with open(f"{SYSTEM.get_user_dir()}{path_sep}.versace{path_sep}base{path_sep}default-versace.cfg", "w", encoding="utf-8") as f:
                f.write(CREATE_CONFIG_FILE(f))
                f.close()
        with open(f"{SYSTEM.get_user_dir()}{path_sep}.versace{path_sep}base{path_sep}default-versace.cfg", "r", encoding="utf-8") as f:
            CONFIG_DATA = f.read()
            f.close()
        for i in CONFIG_DATA_SHOULD:
            if i not in CONFIG_DATA:
                if '-cfg' in PASS_LIST: remove(f"{SYSTEM.get_user_dir()}{path_sep}.versace{path_sep}base{path_sep}default-versace.cfg"); print(f"{COLORS['red']}Run Versace again to apply changes{COLORS['reset']}"); exit()
                raise VersaceCodeBaseError(f"Config file is missing key: {i} \n{COLORS['yellow']}Run Versace again with the -cfg flag to reinitialize the config file\nOr add the missing key to the default config{COLORS['reset']}")
        READ_CONFIG(CONFIG_DATA, FILE_PATH=f"{SYSTEM.get_user_dir()}{path_sep}.versace{path_sep}base{path_sep}default-versace.cfg")
    if '-cfg' in PASS_LIST or '--config' in PASS_LIST:
        if SYSTEM.path_exists(f"{SYSTEM.get_c_dir()}{path_sep}.versace.cfg"):
            print(f"{COLORS['red']}Are you sure you want to overwrite the existing config file?{COLORS['reset']}")
            if input(f"{COLORS['yellow']}Type 'yes' to overwrite the config file - {COLORS['reset']}") == 'yes':
                remove(f"{SYSTEM.get_c_dir()}{path_sep}.versace.cfg")
                print(f"{COLORS['red']}Overwrote existing config file at {COLORS['green']}{SYSTEM.get_c_dir()}{path_sep}.versace.cfg{COLORS['reset']}")
            else: print(f"{COLORS['red']}Aborting...{COLORS['reset']}"); exit()
        else: print(f"{COLORS['red']}Created new config file at {COLORS['green']}{SYSTEM.get_c_dir()}{path_sep}.versace.cfg{COLORS['reset']}")
        with open(f"{SYSTEM.get_c_dir()}{path_sep}.versace.cfg", "w", encoding="utf-8") as f:
            f.write(CREATE_CONFIG_FILE(f))
            f.close()
        print(f"{COLORS['red']}Run Versace again to apply the changes.{COLORS['reset']}"); exit()
        exit()

    return 0
@MEMOIZE
def INITIALIZE_CHECKS() -> None:
    """
    \n Inputs: None
    \n Outputs: None
    \n This is the second stage of initial checks.
    \n It will check the argv flags and cd to the correct directory.
    \n It will also check if the file exists.
    """
    # check which one of the argv elements is the file path
    global FILE_PATH
    for _I_ in PASS_LIST:
        if '\"' in _I_ or "'" in _I_:
            PASS_LIST[PASS_LIST.index(_I_)] = str(eval(_I_)).__str__()

        if _I_.endswith('.py') or _I_.endswith('.exe'):
            continue

        if '.' in _I_ or '/' in _I_ or '\\' in _I_ or ':' in _I_:
            FILE_PATH = _I_
            break

    if FILE_PATH == '':
        console('')
        #print(f"{COLORS['red']}No file path found{COLORS['reset']}")
        #print(f"{COLORS['red']}If you need help type {COLORS['green']}Versace -h{COLORS['red']}{COLORS['reset']}")
        #print(f"{COLORS['red']}Please enter the file path : {COLORS['reset']}", end='')
        import os as _OS
        # check if versace path for any files starting with VINTP and delete them
        FILES = SYSTEM.list_dir(VERSACE_PATH)
        for _I_ in FILES:
            if _I_.startswith('VINTP'):
                _OS.remove(VERSACE_PATH + path_sep + _I_)
        FILE_PATH = VERSACE_PATH + path_sep + 'VINTP.tmp'
        with open(FILE_PATH, 'w', encoding='utf-8') as VERSACE_INTREPRETER_FILE:
            VERSACE_INTREPRETER_FILE.write('')
        if len(PASS_LIST) > 1 and '-d' not in PASS_LIST and '-i' not in PASS_LIST:
            raise UnhandledException('No file path provided')
        INTERPRETER() if '-i' not in PASS_LIST else INTERPRETER(PASS_LIST[PASS_LIST.index('-i') + 1])

    if SYSTEM.path_exists(VERSACE_PATH + path_sep + "compiled") is False:
        SYSTEM.make_dirs(VERSACE_PATH + path_sep + "compiled")

    if '\\\\' in FILE_PATH:
        FILE_PATH = FILE_PATH.replace('\\', path_sep)
    elif '/' in FILE_PATH:
        FILE_PATH = FILE_PATH.replace('/', path_sep)
    elif '\\' in FILE_PATH:
        FILE_PATH = FILE_PATH.replace('\\', path_sep)

    if SYSTEM.get_c_dir().lower() not in FILE_PATH.lower() and ':' not in FILE_PATH and FILE_PATH[0] != path_sep:
        FILE_PATH = SYSTEM.get_c_dir() + path_sep + FILE_PATH
        PASS_LIST[PASS_LIST.index(_I_)] = FILE_PATH

    SYSTEM.change_dir(SYSTEM.get_c_dir())

    FILE_PATH = path.abspath(FILE_PATH)

    if SYSTEM.path_exists(FILE_PATH) is False:
        _system("")
        print(f"{COLORS['red']}File path {COLORS['cyan']}{FILE_PATH}{COLORS['red']} does not exist{COLORS['reset']}")
        wait(2)
        exit()

    return
@ASYNC
def INNIT_DATA_COLLECTOR(FILE_PATH: str) -> None:
    """DATA_COLLECTOR is a function that collects the data from the file and then passes it to the DATA_PARSER function."""
    global PASS_LIST, OPTIONAL_ARGS_IN_FILE

    if SYSTEM.path_exists(f'{VERSACE_PATH}{path_sep}temp') is False:
        SYSTEM.make_dirs(f'{VERSACE_PATH}{path_sep}temp')
    FILE_PATH_1 = f'{VERSACE_PATH}{path_sep}temp{path_sep}{path.basename(FILE_PATH)}'
    FILE_PATH_2 = f'{VERSACE_PATH}{path_sep}temp{path_sep}{path.basename(FILE_PATH)}.tmp'
    if USE_CACHE is False:
        # check if dir is empty
        if len(listdir(f'{VERSACE_PATH}{path_sep}temp')) == 0: return
        for i in listdir(f'{VERSACE_PATH}{path_sep}temp'):
            remove(f'{VERSACE_PATH}{path_sep}temp{path_sep}{i}')
        return
    if '-ctemp' in PASS_LIST and '-all' not in PASS_LIST:
        remove(FILE_PATH_1)
        remove(FILE_PATH_2)
        return
    elif '-ctemp' in PASS_LIST and '-all' in PASS_LIST:
        # clear the whole temp directory
        for i in listdir(f'{VERSACE_PATH}{path_sep}temp'):
            remove(f'{VERSACE_PATH}{path_sep}temp{path_sep}{i}')
        _system("")
        print(f"{COLORS['green']}Cleared the temp directory\n{COLORS['yellow']}{VERSACE_PATH}{path_sep}temp{path_sep}VERSACETEMP{COLORS['reset']}")
        exit()
    else: return
@MEMOIZE
def CHECK_ARGS(FILE_PATH) -> None:
    global PASS_LIST, ORG_FILE_PATH
    """
    \n Inputs: FILE_PATH
    \n Outputs: None
    \n This is the third stage of initial checks.
    \n It will check the argv flags and if they are not valid, it will print the help message.
    \n It also creates a config file if '-cfg' in passed.
    """
    REPLACE_ARGS = {
        '--profile'     :  '-p',
        '--debug'       :  '-d',
        '--version'     :  '-v',
        '--help'        :  '-h',
        '--license'     :  '-l',
        '--freeze'      :  '-f',
        '--watch'       :  '-w',
        '--ast'         :  '-ast',
        '--show-all'    :  '-all',
        '--config'      :  '-cfg',
        '--clear-temp'  :  '-ctemp',
        '--clear'       :  '-clear',
        '--transpile'   :  '-t',
        '--compile'     :  '-c',
        '--compiler-1'  :  '-1',
        '--compiler-2'  :  '-2',
        '--compiler-3'  :  '-3',
        '--no-python'   :  '-no-py',
        '--python'      :  '-py',
        '--license'     :  '-l',
        '--rebuild-all' :  '-ra',
        '--install'     :  'install',
        '--uninstall'   :  'remove',
        '--new'         :  'new',
        '--force'       :  '-f',
        '--in-shell'    :  '-i',
    }

    ORG_FILE_PATH = FILE_PATH

    ALLOWED_ARGS = tuple(REPLACE_ARGS.keys()) + tuple(REPLACE_ARGS.values())
    for i in PASS_LIST:
        if i in tuple(REPLACE_ARGS.keys()):
            PASS_LIST[PASS_LIST.index(i)] = REPLACE_ARGS[i]
    for i in PASS_LIST:
        if '.' not in i:
            if i not in ALLOWED_ARGS:
                from difflib import get_close_matches
                closest = [ii for ii in get_close_matches(i, ALLOWED_ARGS)]
                if len(closest) > 0: closest = closest[0]
                else: closest = 'None'
                _system("")
                print(f"{COLORS['red']}ERROR: unknown command {COLORS['green']}\"{i.strip()}\"{COLORS['red']} did you mean {COLORS['green']}\"{closest.strip()}\"{COLORS['reset']}")
                print(f"{COLORS['yellow']}If you need help, use the {COLORS['green']}-h{COLORS['yellow']} or {COLORS['green']}--help{COLORS['yellow']} flag{COLORS['reset']}")
                exit()  # Exit the program
    if '-h' in PASS_LIST: MISCELLANEOUS().HELP_MENU(); exit()
    if '-v' in PASS_LIST: MISCELLANEOUS().VERSION(); exit()
    if '-l' in PASS_LIST: MISCELLANEOUS().LICENSE(); exit()
    if '-all' in PASS_LIST and '-d' not in PASS_LIST:
        if '-ctemp' in PASS_LIST or '-ast' in PASS_LIST or '-p' in PASS_LIST: pass
        else:
            _system("")
            print(f'{COLORS["red"]}-all must me used in conjunction with --debug/-d, --clear-temp/-ctemp, or --ast/-ast{COLORS["reset"]}')
            exit()
    if '-1' in PASS_LIST or '-2' in PASS_LIST or '-3' in PASS_LIST:
        if '-c' not in PASS_LIST:
            _system("")
            print(f'{COLORS["red"]}-1, -2, and -3 must be used in conjunction with -c{COLORS["reset"]}')
            exit()
    if '-clear' in PASS_LIST:
        _system(CLEAR_SCREEN)
    if '-ra' in PASS_LIST:
        REBUILD_VERSACE_FILE()
        exit()
    return FILE_PATH
@MEMOIZE
def OPEN_FILE(FILE_PATH, mode = None) -> list:
    """
    \n Input: The file path to the Versace file
    \n Output: None
    \n Opens the Versace file and passes it to the TOKENIZE_FILE function.
    """
    global LINES, LINES_FROM_FILE_RAW, COLORS, USE_CACHE, OPTIONAL_ARGS_IN_FILE, ORG_FILE_PATH
    OPTIONAL_ARGUMENT: str = ""
    # check if file is empty
    if v_stat(FILE_PATH) == 0:
        return str("Empty")
    with open(FILE_PATH, "r", encoding="utf-8") as f:
        LINES = f.readlines()
        f.close()
    LINES_FROM_FILE_RAW = deepcopy(LINES)
    for _INDEX_, _LINE_ in enumerate(LINES):
        if '//' in _LINE_:
            _LINE_ = _LINE_.split('//')[0]
        if _LINE_.strip().startswith('[') and _LINE_.strip().endswith(']'):
            OPTIONAL_ARGUMENT = _LINE_.strip()[1:-1]
            _system("")
            if mode != 'include':
                if OPTIONAL_ARGUMENT in GLOBAL_VARIABLES.OPTIONAL_ARGS_ALLOWED:
                    OPTIONAL_ARGS_IN_FILE.append(OPTIONAL_ARGUMENT)
                else:
                    # example line: [arg1, arg2, arg3]
                    # output 1 : BAD OPTION CALL in line 1: [arg1, arg2, arg3]
                    # output 2 : ╰────────────────────────> ^                ^
                    # output 3 : You can only use "[" and "]" to make OPTIONAL arguments, if you do not understand this, please read the documentation. here https://dhruvan.gitbook.io/vs
                    print(f'{COLORS["red"]}Bad optional argument in line {_INDEX_ + 1}:{COLORS["yellow"]} {_LINE_.strip()}{COLORS["reset"]}')
                    print(f'{COLORS["red"]}╰{"─" * (len(f"Bad optional argument in line {_INDEX_ + 1}:") - 2)}> {"^" * (len(_LINE_.strip()) - 1)}^{COLORS["reset"]}')
                    if ',' in _LINE_.strip():
                        print(f'{COLORS["red"]}If you meant to make a list, you can use the "list" operator, example: {COLORS["yellow"]}list(1, 2, 3){COLORS["reset"]}')
                        exit()
                    print(f'{COLORS["red"]}You can only use "[" and "]" to make OPTIONAL arguments, if you do not understand this, please read the documentation. here {COLORS["blue"]}https://dhruvan.gitbook.io/vs/Versace/optional-arguments{COLORS["reset"]}')
                    exit()
            else:
                print(f'{COLORS["red"]}No optional arguments allowed, used in line {_INDEX_ + 1}:{COLORS["yellow"]} {_LINE_.strip()}{COLORS["reset"]}')
                print(f'{COLORS["red"]}╰{"─" * (len(f"Miss-used optional argument in line {_INDEX_ + 1}:") - 2)}> {"^" * (len(_LINE_.strip()) - 1)}^{COLORS["reset"]}')
                if ',' in _LINE_.strip():
                    print(f'{COLORS["red"]}If you meant to make a list, you can use the "list" operator, example: {COLORS["yellow"]}list(1, 2, 3){COLORS["reset"]}')
                    exit()
                print(f'{COLORS["red"]}You can not use optional arguments in a included file, if you do not understand this, please read the documentation. here {COLORS["blue"]}https://dhruvan.gitbook.io/vs/Versace/optional-arguments{COLORS["reset"]}')
                exit()
            LINES[_INDEX_] = ''
    if '-*- cache -*-' in OPTIONAL_ARGS_IN_FILE:
        USE_CACHE = True
    if '-*- all errors -*-' not in OPTIONAL_ARGS_IN_FILE:
        OPTIONAL_ARGS_IN_FILE.append('-*- all errors -*-')
    if not COLOR_SUPPORT:
        COLORS = _MAP_({'red' : '', 'grey' : '', 'dim green' : '', 'underline' : '', 'green' : '', 'yellow' : '', 'blue' : '', 'magenta' : '', 'cyan' : '', 'white' : '', 'bold red' : '', 'bold green' : '', 'bold yellow' : '', 'bold blue' : '', 'bold magenta' : '', 'bold cyan' : '', 'bold white' : '', 'bright_red' : '', 'bright_green' : '', 'bright_yellow' : '', 'bright_blue' : '', 'bright_magenta' : '', 'bright_cyan' : '', 'bright_white' : '', 'underline' : '', 'italic' : '', 'blink' : '', 'reverse' : '', 'reset' : ''})
    return LINES_FROM_FILE_RAW

# ---------------- READ/GET/SET Data Functions ---------------- #
@MEMOIZE
def VERSACE_BOILERPLATE(RUN_FILE='__file__') -> str:
    """Returns the starting line that should go in every compiled file"""
    DATA  = f"""# -*- coding: utf-8 -*-
# THIS FILE WAS GENERATED BY VERSACE {VERSION}
# Versace can be found here: \"https://github.com/Ze7111/Versace-Programing-language/\"
# Versace Documentation can be found here: \"https://dhruvan.gitbook.io/vs/\"
\"\"\"
╭───────────────────────────────────────────────────────────────────────────────╮
│    DO NOT EDIT THIS CODE THIS SECTION OF CODE OR THE LINES ABOVE THIS,        │
│                       AUTO GENERATED BY VERSACE.                              │
╰───────────────────────────────────────────────────────────────────────────────╯
\"\"\"
from rich import console as r_console; print = r_console.Console().print
from sys import exit, getsizeof
from copy import deepcopy as copy
import sys, os, enum
from threading import Thread, main_thread
from time import sleep as wait
from dataclasses import dataclass
from subprocess import Popen as ppopen
from typing import Final
from typing import Any as any
def __GET_AVAILABLE_MEMORY__() -> int:
{INDENTATION*1}try:
{INDENTATION*2}from sys import platform
{INDENTATION*2}if platform == 'linux' or platform == 'linux2':
{INDENTATION*3}# linux
{INDENTATION*3}import os
{INDENTATION*3}import psutil
{INDENTATION*3}process = psutil.Process(os.getpid())
{INDENTATION*3}return process.memory_info().rss
{INDENTATION*2}elif platform == 'darwin':
{INDENTATION*3}# OS X
{INDENTATION*3}import os
{INDENTATION*3}import psutil
{INDENTATION*3}process = psutil.Process(os.getpid())
{INDENTATION*3}return process.memory_info().rss
{INDENTATION*2}elif platform == 'win32':
{INDENTATION*3}# Windows
{INDENTATION*3}from psutil import virtual_memory
{INDENTATION*3}return virtual_memory().free
{INDENTATION*2}else:
{INDENTATION*3}return 0
{INDENTATION*1}except Exception:
{INDENTATION*2}return 4294967296
__ALLOCATED_MEMORY_ARRAY__: list[int] = []*100
__FREE_MEMORY__: int = (__GET_AVAILABLE_MEMORY__() / (1024 * 1024)) - 1024
__TASK_REGISTRY__: dict[str, object] = {{}}
__TASK_ARGS_REGISTRY__: dict[str, tuple] = {{}}
__TASK_KWARGS_REGISTRY__: dict[str, dict] = {{}}
__AUTO_RELEASE_POOL__: bool = False
_FROZENSET_ = frozenset
NULL = None
length = len
__OVERLOAD_FUNCTION_REG__: dict = {{}}
class builtin:
{INDENTATION*1}def _PRIVATE_METHOD_1(type) -> str and bool:
{INDENTATION*2}from sys import platform as _platform
{INDENTATION*2}OS, NAME = None, None
{INDENTATION*2}if _platform.startswith('linux'):
{INDENTATION*3}del _platform
{INDENTATION*3}OS = 'posix'
{INDENTATION*2}elif _platform.startswith('darwin'):
{INDENTATION*3}del _platform
{INDENTATION*3}OS = 'mac'
{INDENTATION*2}elif _platform.startswith('win32'):
{INDENTATION*3}del _platform
{INDENTATION*3}OS = 'nt'
{INDENTATION*2}else:
{INDENTATION*3}OS = _platform
{INDENTATION*2}if OS == 'nt':
{INDENTATION*3}NAME = 'windows'
{INDENTATION*2}elif OS == 'posix':
{INDENTATION*3}NAME = 'linux'
{INDENTATION*2}elif OS == 'mac':
{INDENTATION*3}NAME = 'macos'
{INDENTATION*2}else:
{INDENTATION*3}NAME = 'unknown'
{INDENTATION*2}
{INDENTATION*2}if type == 'name':
{INDENTATION*3}return NAME
{INDENTATION*2}elif type == 'os':
{INDENTATION*3}return OS
{INDENTATION*1}windows = _PRIVATE_METHOD_1('os') == 'nt'
{INDENTATION*1}linux = _PRIVATE_METHOD_1('os') == 'posix'
{INDENTATION*1}macos = _PRIVATE_METHOD_1('os') == 'mac'
{INDENTATION*1}unknown = _PRIVATE_METHOD_1('os') == 'unknown'
{INDENTATION*1}class _os:
{INDENTATION*2}name = None
{INDENTATION*2}def __str__(self):
{INDENTATION*3}return builtin._PRIVATE_METHOD_1('os')
{INDENTATION*2}def __repr__(self):
{INDENTATION*3}return builtin._PRIVATE_METHOD_1('os')
{INDENTATION*1}os = _os()
{INDENTATION*1}os.name = _PRIVATE_METHOD_1('name')
class VersaceCodeBaseError(Exception):
{INDENTATION*1}def __init__(self, message):
{INDENTATION*2}os.system("")
{INDENTATION*2}print(\"VersaceError: \" + message)
{INDENTATION*2}exit()
class __DISPATCH__(object):
{INDENTATION*1}def __init__(self, NAME):
{INDENTATION*2}self.NAME = NAME
{INDENTATION*2}self.__TYPE_MAP__ = {{}}
{INDENTATION*1}def __call__(self, *ARGUMENTS):
{INDENTATION*2}__TYPES__ = tuple(argument.__class__ for argument in ARGUMENTS) # a generator expression!
{INDENTATION*2}FUNCTION = self.__TYPE_MAP__.get(__TYPES__)
{INDENTATION*2}if FUNCTION is None:
{INDENTATION*3}RuntimeError(f\"No registered function for types \\\"{{__TYPES__}}\\\"\")
{INDENTATION*2}return FUNCTION(*ARGUMENTS)
{INDENTATION*1}def __register__(self, __TYPES__, FUNCTION):
{INDENTATION*2}if __TYPES__ in self.__TYPE_MAP__:
{INDENTATION*3}RuntimeError(f\"Duplicate registration for function \\\"{{FUNCTION.__name__}}\\\"\")
{INDENTATION*2}self.__TYPE_MAP__[__TYPES__] = FUNCTION
def overload(*__TYPES__):
{INDENTATION*1}def __register__(FUNCTION):
{INDENTATION*2}NAME = FUNCTION.__name__
{INDENTATION*2}__D_INST__ = __OVERLOAD_FUNCTION_REG__.get(NAME)
{INDENTATION*2}if __D_INST__ is None:
{INDENTATION*3}__D_INST__ = __OVERLOAD_FUNCTION_REG__[NAME] = __DISPATCH__(NAME)
{INDENTATION*2}__D_INST__.__register__(__TYPES__, FUNCTION)
{INDENTATION*2}return __D_INST__
{INDENTATION*1}return __register__
def _async(func):
{INDENTATION*1}\"\"\" This is a decorator for async functions \"\"\"
{INDENTATION*1}def __ASYNC__FUNCTION__(*args, **kwargs):
{INDENTATION*2}\"\"\" This is the wrapper function that will be returned \"\"\"
{INDENTATION*2}thread = Thread(target=func, args=args, kwargs=kwargs)
{INDENTATION*2}thread.start()
{INDENTATION*2}return thread
{INDENTATION*1}return __ASYNC__FUNCTION__
"""
    if '-c' in PASS_LIST or '-no-py' in PASS_LIST or '-exec' in PASS_LIST: 
        DATA += '\n'
    else: DATA  += f"""with open({RUN_FILE}, \'r\', encoding="utf-8") as f:
{INDENTATION*1}__THIS_FILE_DATA__ = f.readlines()
if \'Versace\' not in __THIS_FILE_DATA__[2]:
{INDENTATION*1}raise RuntimeError('This file is corrupted, please do not modify the section of code that specifies that it is auto generated by Versace')
if \'https\' not in __THIS_FILE_DATA__[2]:
{INDENTATION*1}raise RuntimeError('This file is corrupted, please do not modify the section of code that specifies that it is auto generated by Versace')
if \'Ze7111\' not in __THIS_FILE_DATA__[2]:
{INDENTATION*1}raise RuntimeError('This file is corrupted, please do not modify the section of code that specifies that it is auto generated by Versace')
if \'GENERATED\' not in __THIS_FILE_DATA__[1]:
{INDENTATION*1}raise RuntimeError('This file is corrupted, please do not modify the section of code that specifies that it is auto generated by Versace')
if \'coding\' not in __THIS_FILE_DATA__[0]:
{INDENTATION*1}raise UnicodeError(\'This file is corrupted, please do not modify the section of code that specifies that it is auto generated by Versace\')\n""" 

    DATA  += f"""def pack(*args, **kwargs) -> tuple:
{INDENTATION*1}\"\"\" Packs any given data into a tuple \"\"\"
{INDENTATION*1}if not args and not kwargs:
{INDENTATION*2}return (None)
{INDENTATION*1}if not args:
{INDENTATION*2}return kwargs
{INDENTATION*1}if not kwargs:
{INDENTATION*2}return args
{INDENTATION*1}return args, kwargs
def unpack(args, **kwargs) -> ...:
{INDENTATION*1}\"\"\" Unpacks any packed data, so they can be assigned to variables \"\"\"
{INDENTATION*1}if not args and not kwargs:
{INDENTATION*2}return (None)
{INDENTATION*1}if not args:
{INDENTATION*2}return kwargs
{INDENTATION*1}if not kwargs:
{INDENTATION*2}return args
{INDENTATION*1}return args, kwargs
def frozenset(*args, **kwargs) -> _FROZENSET_:
{INDENTATION*1}\"\"\" Converts any given data to a frozenset \"\"\"
{INDENTATION*1}return __builtins__.frozenset(args)
def exec(*args, **kwargs) -> None:
{INDENTATION*1}\"\"\" Executes any given code \"\"\"
{INDENTATION*1}if not args and not kwargs:
{INDENTATION*2}return (None)
{INDENTATION*1}for i in args:
{INDENTATION*2}exec(i, globals())
def malloc(size=None, output=None, path_sep=None) -> int:
{INDENTATION*1}__ALLOCATE__ = size
{INDENTATION*1}if __ALLOCATE__ is None: raise ValueError(\'No amount of memory provided to allocate\')
{INDENTATION*1}if path_sep is None: path_sep = \',\'
{INDENTATION*1}global __ALLOCATED_MEMORY_ARRAY__, __FREE_MEMORY__
{INDENTATION*1}if __ALLOCATE__ > __FREE_MEMORY__: raise MemoryError(f\'Not enough memory to allocate {{__ALLOCATE__:,}} MB, only {{int(__FREE_MEMORY__):,}} MB available\')
{INDENTATION*1}if type(__ALLOCATE__) is not int: raise TypeError(\'Amount of memory to allocate must be an integer\')
{INDENTATION*1}if type(__ALLOCATED_MEMORY_ARRAY__) is not list: __ALLOCATED_MEMORY_ARRAY__ = []*100
{INDENTATION*1}__ALLOCATE__ = __ALLOCATE__ * 7710 * 17
{INDENTATION*1}__ALLOCATED_MEMORY_ARRAY__  = [0] * __ALLOCATE__
{INDENTATION*1}if output is None: return getsizeof(__ALLOCATED_MEMORY_ARRAY__)
{INDENTATION*1}elif output == str:
{INDENTATION*2}__ALLOCATE__ = getsizeof(__ALLOCATED_MEMORY_ARRAY__)
{INDENTATION*2}if __ALLOCATE__ > 1024 * 1024 * 1024 * 1024:
{INDENTATION*3}__ALLOCATE__ = __ALLOCATE__ / (1024 * 1024 * 1024 * 1024)
{INDENTATION*3}__ALLOCATE__ = round(__ALLOCATE__, 2)
{INDENTATION*3}return f\'{{__ALLOCATE__:{{path_sep}}}} TB\'
{INDENTATION*2}elif __ALLOCATE__ > 1024 * 1024 * 1024:
{INDENTATION*3}__ALLOCATE__ = __ALLOCATE__ / (1024 * 1024 * 1024)
{INDENTATION*3}__ALLOCATE__ = round(__ALLOCATE__, 2)
{INDENTATION*3}return f\'{{__ALLOCATE__:{{path_sep}}}} GB\'
{INDENTATION*2}elif __ALLOCATE__ > 1024 * 1024:
{INDENTATION*3}__ALLOCATE__ = __ALLOCATE__ / (1024 * 1024)
{INDENTATION*3}__ALLOCATE__ = round(__ALLOCATE__, 2)
{INDENTATION*3}return f\'{{__ALLOCATE__:{{path_sep}}}} MB\'
{INDENTATION*2}elif __ALLOCATE__ > 1024:
{INDENTATION*3}__ALLOCATE__ = __ALLOCATE__ / 1024
{INDENTATION*3}__ALLOCATE__ = round(__ALLOCATE__, 2)
{INDENTATION*3}return f\'{{__ALLOCATE__:{{path_sep}}}} KB\'
{INDENTATION*2}else:
{INDENTATION*3}__ALLOCATE__ = round(__ALLOCATE__, 2)
{INDENTATION*3}return f\'{{__ALLOCATE__:{{path_sep}}}} Bytes\'
{INDENTATION*1}elif output == list:
{INDENTATION*2}# raise a exception informing the use THAT THEY ARE NOT SUPPOSED TO USE THIS FUNCTION
{INDENTATION*2}raise NotImplementedError(\'Using this WILL cause memory leaks, DO NOT USE\')
{INDENTATION*1}elif output == int:
{INDENTATION*2}return getsizeof(__ALLOCATED_MEMORY_ARRAY__)
{INDENTATION*1}else:
{INDENTATION*2}raise TypeError(\'Invalid output type\')
def free(size=None, output=None, path_sep=None) -> int:
{INDENTATION*1}__free__ = size
{INDENTATION*1}global __ALLOCATED_MEMORY_ARRAY__, __FREE_MEMORY__
{INDENTATION*1}if path_sep is None: path_sep = \',\'
{INDENTATION*1}__free__ = (__free__ * 7710 * 17) if __free__ is not None else None
{INDENTATION*1}if __free__ is None: __free__ = len(__ALLOCATED_MEMORY_ARRAY__)
{INDENTATION*1}if __free__ / 7710 / 17 > __FREE_MEMORY__: raise MemoryError(f\'Not enough memory to free {{__free__:,}} MB, only {{int(__FREE_MEMORY__):,}} MB available\')
{INDENTATION*1}if type(__ALLOCATED_MEMORY_ARRAY__) is not list: raise ValueError(\'Memory is not allocated\')
{INDENTATION*1}if __free__ > len(__ALLOCATED_MEMORY_ARRAY__): raise MemoryError(f\'Not enough memory allocated to free, only {{len(__ALLOCATED_MEMORY_ARRAY__):,}} MB allocated\')
{INDENTATION*1}__ALLOCATED_MEMORY_ARRAY__ = __ALLOCATED_MEMORY_ARRAY__[:__free__]
{INDENTATION*1}amount_of_memory_allocated = getsizeof(__ALLOCATED_MEMORY_ARRAY__)
{INDENTATION*1}if amount_of_memory_allocated == 56: amount_of_memory_allocated = 0
{INDENTATION*1}if output is None:
{INDENTATION*2}return amount_of_memory_allocated
{INDENTATION*1}elif output == str:
{INDENTATION*2}__free__ = amount_of_memory_allocated
{INDENTATION*2}if __free__ > 1024 * 1024 * 1024 * 1024:
{INDENTATION*3}__free__ = __free__ / (1024 * 1024 * 1024 * 1024)
{INDENTATION*3}__free__ = round(__free__, 2)
{INDENTATION*3}return f\'{{__free__:{{path_sep}}}} TB\'
{INDENTATION*2}elif __free__ > 1024 * 1024 * 1024:
{INDENTATION*3}__free__ = __free__ / (1024 * 1024 * 1024)
{INDENTATION*3}__free__ = round(__free__, 2)
{INDENTATION*3}return f\'{{__free__:{{path_sep}}}} GB\'
{INDENTATION*2}elif __free__ > 1024 * 1024:
{INDENTATION*3}__free__ = __free__ = __free__ / (1024 * 1024)
{INDENTATION*3}__free__ = round(__free__, 2)
{INDENTATION*3}return f\'{{__free__:{{path_sep}}}} MB\'
{INDENTATION*2}elif __free__ > 1024:
{INDENTATION*3}__free__ = __free__ / 1024
{INDENTATION*3}__free__ = round(__free__, 2)
{INDENTATION*3}return f\'{{__free__:{{path_sep}}}} KB\'
{INDENTATION*2}else:
{INDENTATION*3}__free__ = round(__free__, 2)
{INDENTATION*3}return f\'{{__free__:{{path_sep}}}} Bytes\'
{INDENTATION*1}elif output == list:
{INDENTATION*2}# raise a exception informing the use THAT THEY ARE NOT SUPPOSED TO USE THIS FUNCTION
{INDENTATION*2}raise NotImplementedError(\'Using this WILL cause memory leaks, DO NOT USE\')
{INDENTATION*1}elif output == int:
{INDENTATION*2}return amount_of_memory_allocated
{INDENTATION*1}else:
{INDENTATION*2}raise TypeError(\'Invalid output type\')
def latch(*args, **kwrgs):
{INDENTATION*1}if len(args) == 0 and len(kwrgs) == 0:
{INDENTATION*2}raise RuntimeError(\'No arguments passed to latch\')
{INDENTATION*1}for arg in args:
{INDENTATION*2}if isinstance(arg, bool) != True:
{INDENTATION*3}raise RuntimeError(f\'Invalid argument type passed to latch, expected bool, got {{type(arg)}}\')
{INDENTATION*1}for kwarg in kwrgs:
{INDENTATION*2}if isinstance(kwrgs.get(kwarg), bool) != True:
{INDENTATION*3}raise RuntimeError(f\'Invalid argument type passed to latch, expected bool, got {{type(kwrgs.get(kwarg))}}\')
{INDENTATION*1}if len(args) > 0:
{INDENTATION*2}args = list(args)
{INDENTATION*2}for index in range(len(args)):
{INDENTATION*3}args[index] = not args[index]
{INDENTATION*2}args = tuple(args)
{INDENTATION*1}if len(kwrgs) > 0:
{INDENTATION*2}kwrgs = dict(kwrgs)
{INDENTATION*2}for kwarg in kwrgs:
{INDENTATION*3}kwrgs[kwarg] = not kwrgs.get(kwarg)
{INDENTATION*2}kwrgs = dict(kwrgs)
{INDENTATION*1}if len(args) > 0 and len(kwrgs) > 0:
{INDENTATION*2}temp_arg_list = []*100
{INDENTATION*2}temp_kwarg_list = []*100
{INDENTATION*2}for arg in args:
{INDENTATION*3}temp_arg_list.append(arg)
{INDENTATION*2}for kwarg in kwrgs:
{INDENTATION*3}temp_kwarg_list.append(kwrgs.get(kwarg))
{INDENTATION*2}args = tuple(temp_arg_list)
{INDENTATION*2}kwrgs = tuple(temp_kwarg_list)
{INDENTATION*2}return *args, *kwrgs
{INDENTATION*1}elif len(args) == 1:
{INDENTATION*2}return args[0]
{INDENTATION*1}elif len(kwrgs) == 1:
{INDENTATION*2}return kwrgs.get(list(kwrgs)[0])
{INDENTATION*1}elif len(args) > 0:
{INDENTATION*2}return args
{INDENTATION*1}elif len(kwrgs) > 0:
{INDENTATION*2}templist = []*100
{INDENTATION*2}for value in kwrgs:
{INDENTATION*3}templist.append(kwrgs.get(value))
{INDENTATION*2}templist = tuple(templist)
{INDENTATION*2}return templist
class fixed_list:
{INDENTATION*1}def __init__(self, total_items: int = 0) -> None:
{INDENTATION*2}self.fixed_len_list = [None]*total_items
{INDENTATION*1}def __getitem__(self, index: int = 0) -> object:
{INDENTATION*2}return self.fixed_len_list [index]
{INDENTATION*1}def __setitem__(self, index: int = 0, value = None) -> None:
{INDENTATION*2}self.fixed_len_list [index] = value
{INDENTATION*1}def __len__(self) -> int:
{INDENTATION*2}return len (self.fixed_len_list)
{INDENTATION*1}def __iter__(self) -> list:
{INDENTATION*2}return self.fixed_len_list
{INDENTATION*1}def __reversed__(self) -> list:
{INDENTATION*2}return self.fixed_len_list
{INDENTATION*1}def __str__(self) -> str:
{INDENTATION*2}return str (self.fixed_len_list)
{INDENTATION*1}def append(self, value = None) -> None:
{INDENTATION*2}raise Error (f"Cannot append to fixed length list")
{INDENTATION*1}def extend(self, value: list = [None]) -> None:
{INDENTATION*2}raise Error (f"Cannot extend to fixed length list")
{INDENTATION*1}def insert(self, index: int = 0, value = None) -> None:
{INDENTATION*2}raise Error (f"Cannot insert to fixed length list")
{INDENTATION*1}def pop(self, index: int = 0) -> None:
{INDENTATION*2}raise Error (f"Cannot pop from fixed length list")
{INDENTATION*1}def remove(self, value = None) -> None:
{INDENTATION*2}raise Error (f"Cannot remove from fixed length list")
{INDENTATION*1}def clear(self) -> None:
{INDENTATION*2}raise Error (f"Cannot clear fixed length list")
{INDENTATION*1}def index(self, value = None) -> None:
{INDENTATION*2}self.fixed_len_list.index (value)
{INDENTATION*1}def count(self, value = None) -> None:
{INDENTATION*2}self.fixed_len_list.count (value)
{INDENTATION*1}def sort(self) -> None:
{INDENTATION*2}self.fixed_len_list.sort ()
{INDENTATION*1}def reverse(self) -> None:
{INDENTATION*2}self.fixed_len_list.reverse ()
{INDENTATION*1}def copy(self) -> list:
{INDENTATION*2}return list (self.fixed_len_list)
{INDENTATION*1}def __add__(self, other: list = [None]) -> list:
{INDENTATION*2}return list (self.fixed_len_list + other)
{INDENTATION*1}def __mul__(self, other: int = 0) -> list:
{INDENTATION*2}return list (self.fixed_len_list * other)
{INDENTATION*1}def __rmul__(self, other: int = 0) -> list:
{INDENTATION*2}return list (self.fixed_len_list * other)
{INDENTATION*1}def __contains__(self, value = None) -> bool:
{INDENTATION*2}return value in self.fixed_len_list
{INDENTATION*1}def __eq__(self, other: list = [None]) -> bool:
{INDENTATION*2}return self.fixed_len_list == other
{INDENTATION*1}def __ne__(self, other: list = [None]) -> bool:
{INDENTATION*2}return self.fixed_len_list != other
{INDENTATION*1}def __lt__(self, other: list = [None]) -> bool:
{INDENTATION*2}return self.fixed_len_list < other
{INDENTATION*1}def __le__(self, other: list = [None]) -> bool:
{INDENTATION*2}return self.fixed_len_list <= other
{INDENTATION*1}def __gt__(self, other: list = [None]) -> bool:
{INDENTATION*2}return self.fixed_len_list > other
{INDENTATION*1}def __ge__(self, other: list = [None]) -> bool:
{INDENTATION*2}return self.fixed_len_list >= other
{INDENTATION*1}def __repr__(self) -> str:
{INDENTATION*2}return str (self.fixed_len_list)
{INDENTATION*1}def __hash__(self) -> int:
{INDENTATION*2}return hash (self.fixed_len_list)
{INDENTATION*1}def join(self, sep: str) -> str:
{INDENTATION*2}return sep.join (self.fixed_len_list)
class VariableError(Exception):
{INDENTATION*1}def __init__(self, *args, **kwargs):
{INDENTATION*2}if args:
{INDENTATION*3}print(f\"VariableError: {{args[0]}}\")
{INDENTATION*2}elif kwargs:
{INDENTATION*3}print(f\"VariableError: {{kwargs[0]}}\")
{INDENTATION*2}exit()
class SyntaxError(Exception):
{INDENTATION*1}def __init__(self, *args, **kwargs):
{INDENTATION*2}if args:
{INDENTATION*3}print(f\"SyntaxError: {{args[0]}}\")
{INDENTATION*2}elif kwargs:
{INDENTATION*3}print(f\"SyntaxError: {{kwargs[0]}}\")
{INDENTATION*2}exit()
class CloseError(Exception):
{INDENTATION*1}def __init__(self, *args, **kwargs):
{INDENTATION*2}if args:
{INDENTATION*3}print(f\"CloseError: {{args[0]}}\")
{INDENTATION*2}elif kwargs:
{INDENTATION*3}print(f\"CloseError: {{kwargs[0]}}\")
{INDENTATION*2}exit()
class TypeError(Exception):
{INDENTATION*1}def __init__(self, *args, **kwargs):
{INDENTATION*2}if args:
{INDENTATION*3}print(f\"TypeError: {{args[0]}}\")
{INDENTATION*2}elif kwargs:
{INDENTATION*3}print(f\"TypeError: {{kwargs[0]}}\")
{INDENTATION*2}exit()
class DataError(Exception):
{INDENTATION*1}def __init__(self, *args, **kwargs):
{INDENTATION*2}if args:
{INDENTATION*3}print(f\"DataError: {{args[0]}}\")
{INDENTATION*2}elif kwargs:
{INDENTATION*3}print(f\"DataError: {{kwargs[0]}}\")
{INDENTATION*2}exit()
class FileNotFoundError(Exception):
{INDENTATION*1}def __init__(self, *args, **kwargs):
{INDENTATION*2}if args:
{INDENTATION*3}print(f\"FileNotFoundError: {{args[0]}}\")
{INDENTATION*2}elif kwargs:
{INDENTATION*3}print(f\"FileNotFoundError: {{kwargs[0]}}\")
{INDENTATION*2}exit()
class ReferenceError(Exception):
{INDENTATION*1}def __init__(self, *args, **kwargs):
{INDENTATION*2}if args:
{INDENTATION*3}print(f\"ReferenceError: {{args[0]}}\")
{INDENTATION*2}elif kwargs:
{INDENTATION*3}print(f\"ReferenceError: {{kwargs[0]}}\")
{INDENTATION*2}exit()
class NoMainError(Exception):
{INDENTATION*1}def __init__(self, *args, **kwargs):
{INDENTATION*2}if args:
{INDENTATION*3}print(f\"NoMainError: {{args[0]}}\")
{INDENTATION*2}elif kwargs:
{INDENTATION*3}print(f\"NoMainError: {{kwargs[0]}}\")
{INDENTATION*2}exit()
class Error(Exception):
{INDENTATION*1}def __init__(self, *args, **kwargs):
{INDENTATION*2}if args:
{INDENTATION*3}print(f\"Error: {{args[0]}}\")
{INDENTATION*2}elif kwargs:
{INDENTATION*3}print(f\"Error: {{kwargs[0]}}\")
{INDENTATION*2}exit()
class AsyncError(Exception):
{INDENTATION*1}def __init__(self, *args, **kwargs):
{INDENTATION*2}if args:
{INDENTATION*3}print(f\"AsyncError: {{args[0]}}\")
{INDENTATION*2}elif kwargs:
{INDENTATION*3}print(f\"AsyncError: {{kwargs[0]}}\")
{INDENTATION*2}exit()
class RuntimeError(Exception):
{INDENTATION*1}def __init__(self, *args, **kwargs):
{INDENTATION*2}if args:
{INDENTATION*3}print(f\"RuntimeError: {{args[0]}}\")
{INDENTATION*2}elif kwargs:
{INDENTATION*3}print(f\"RuntimeError: {{kwargs[0]}}\")
{INDENTATION*2}exit()
class TaskGroup:
{INDENTATION*1}def autorelease_pool(value: bool):
{INDENTATION*2}global __TASK_REGISTRY__, __TASK_ARGS_REGISTRY__, __TASK_KWARGS_REGISTRY__, __AUTO_RELEASE_POOL__
{INDENTATION*2}if len(__TASK_REGISTRY__) == 0:
{INDENTATION*3}__AUTO_RELEASE_POOL__ = value
{INDENTATION*2}else:
{INDENTATION*3}if value != __AUTO_RELEASE_POOL__:
{INDENTATION*4}raise RuntimeError(\'Cannot modify coroutine pool while tasks are set, clear tasks first with \"coroutine clear();\"\')
{INDENTATION*1}def add(task: object, *args, **kwargs):
{INDENTATION*2}global __TASK_REGISTRY__, __TASK_ARGS_REGISTRY__, __TASK_KWARGS_REGISTRY__
{INDENTATION*2}if not callable(task):
{INDENTATION*3}raise TypeError(\'Invalid task, expected a callable object (function or method)\')
{INDENTATION*2}if task.__name__ != \"__ASYNC__FUNCTION__\":
{INDENTATION*3}raise RuntimeError(\'Invalid task, expected a async function\')
{INDENTATION*2}__TASK_REGISTRY__[task] = task.__name__
{INDENTATION*2}__TASK_ARGS_REGISTRY__[task] = args
{INDENTATION*2}__TASK_KWARGS_REGISTRY__[task] = kwargs
{INDENTATION*2}
{INDENTATION*1}def execute(*args):
{INDENTATION*2}global __TASK_REGISTRY__, __TASK_ARGS_REGISTRY__, __TASK_KWARGS_REGISTRY__, __AUTO_RELEASE_POOL__
{INDENTATION*2}if len(__TASK_REGISTRY__) == 0:
{INDENTATION*3}raise RuntimeError(\'No tasks to execute, you can add tasks with \"coroutine async_function() | ...;\".\\nExample: \"coroutine some_func(1, 2) | some_other_func(1. 23);\"\')
{INDENTATION*2}if not args:
{INDENTATION*3}for task in __TASK_REGISTRY__:
{INDENTATION*4}task(*__TASK_ARGS_REGISTRY__[task], **__TASK_KWARGS_REGISTRY__[task])
{INDENTATION*2}else:
{INDENTATION*3}for task in args:
{INDENTATION*4}task(*__TASK_ARGS_REGISTRY__[task], **__TASK_KWARGS_REGISTRY__[task])
{INDENTATION*2}if __AUTO_RELEASE_POOL__  and len(args) == len(__TASK_REGISTRY__):
{INDENTATION*3}__TASK_REGISTRY__.clear()
{INDENTATION*3}__TASK_ARGS_REGISTRY__.clear()
{INDENTATION*3}__TASK_KWARGS_REGISTRY__.clear()
{INDENTATION*3}__AUTO_RELEASE_POOL__ = False
{INDENTATION*2}elif __AUTO_RELEASE_POOL__  and len(args) > 0:
{INDENTATION*3}for task in args:
{INDENTATION*4}if task not in __TASK_REGISTRY__:
{INDENTATION*5}raise ReferenceError(f\"\'{{task}}\' not found in the tasks registry.\")
{INDENTATION*4}del __TASK_REGISTRY__[task]
{INDENTATION*4}del __TASK_ARGS_REGISTRY__[task]
{INDENTATION*4}del __TASK_KWARGS_REGISTRY__[task]
{INDENTATION*2}elif __AUTO_RELEASE_POOL__  and len(args) == 0:
{INDENTATION*3}__TASK_REGISTRY__.clear()
{INDENTATION*3}__TASK_ARGS_REGISTRY__.clear()
{INDENTATION*3}__TASK_KWARGS_REGISTRY__.clear()
{INDENTATION*3}__AUTO_RELEASE_POOL__ = False
{INDENTATION*3}
{INDENTATION*1}def clear():
{INDENTATION*2}global __TASK_REGISTRY__, __TASK_ARGS_REGISTRY__, __TASK_KWARGS_REGISTRY__
{INDENTATION*2}__TASK_REGISTRY__.clear()
{INDENTATION*2}__TASK_ARGS_REGISTRY__.clear()
{INDENTATION*2}__TASK_KWARGS_REGISTRY__.clear()
{INDENTATION*2}
{INDENTATION*1}def remove(*args):
{INDENTATION*2}global __TASK_REGISTRY__, __TASK_ARGS_REGISTRY__, __TASK_KWARGS_REGISTRY__
{INDENTATION*2}if not args:
{INDENTATION*3}raise SyntaxError(\'No arguments provided for \"coroutine delete();\", expected at least 1\\nIf you want to remove all tasks, use \"coroutine clear();\"\')
{INDENTATION*2}for task in args:
{INDENTATION*3}if task not in __TASK_REGISTRY__:
{INDENTATION*4}raise ReferenceError(f\"\'{{task}}\' not found in the tasks registry.\")
{INDENTATION*3}del __TASK_REGISTRY__[task]
{INDENTATION*3}del __TASK_ARGS_REGISTRY__[task]
{INDENTATION*3}del __TASK_KWARGS_REGISTRY__[task]
TOTAL_ASSERTIONS = 0
TOTAL_FAILED_ASSERTIONS = 0
TOTAL_PASSED_ASSERTIONS = 0
def Assert(*conditions, message="Assertion failed (default message)", **kwargs):
    global TOTAL_ASSERTIONS, TOTAL_FAILED_ASSERTIONS, TOTAL_PASSED_ASSERTIONS
    TOTAL_ASSERTIONS += 1
    FAILED_ASSERTIONS = 0
    PASS_ASSERTIONS = 0
    from os import get_terminal_size
    TERMINAL_WIDTH: int = get_terminal_size().columns
    print(f"\\033[95m╭─{{'─'*int((TERMINAL_WIDTH / 6) - 10)}}\\033[91m Testing... \\033[95m{{'─'*int((TERMINAL_WIDTH / 1.2) - 22)}} \\033[91mAssertion: {{TOTAL_ASSERTIONS:^4}} \\033[95m─╮\\033[0m")
    COUNT = 0
    for i in conditions:
        COUNT += 1
        try:
            if not i:
                FAILED_ASSERTIONS += 1
                TOTAL_FAILED_ASSERTIONS += 1
                text_to_calc_len = f"│ {{COUNT:<4}}  FAIL: {{message}} "
                f_color = '\\033[30m'
                print(f"\\033[95m│ \\033[0m{{COUNT:<4}}\\033[91m  FAIL:\\033[0m {{message.replace('(default message)', f_color + '(default message)')}} \\033[95m{{' '*int((TERMINAL_WIDTH-len(text_to_calc_len))-2)}} │\\033[0m")
            else:
                PASS_ASSERTIONS += 1
                TOTAL_PASSED_ASSERTIONS += 1
                text_to_calc_len = f"│ {{COUNT:<4}}  PASS "
                print(f"\\033[95m│ \\033[0m{{COUNT:<4}}\\033[92m  PASS \\033[95m{{' '*int((TERMINAL_WIDTH-len(text_to_calc_len))-2)}} │\\033[0m")
        except Exception as e:
            FAILED_ASSERTIONS += 1
            TOTAL_FAILED_ASSERTIONS += 1
            text_to_calc_len = f"│ {{COUNT:<4}}  FAIL (BAD ASSERTION): {{message}} "
            f_color = '\\033[30m'
            print(f"\\033[95m│ \\033[0m{{COUNT:<4}}\\033[93m  FAIL (BAD ASSERTION):\\033[0m {{message.replace('(default message)', f_color + '(default message)')}} \\033[95m{{' '*int((TERMINAL_WIDTH-len(text_to_calc_len))-2)}} │\\033[0m")
    print(f"\\033[95m╰{{'─'*int(TERMINAL_WIDTH-2)}}╯\\033[0m")
    print(f"\\033[0mSummary: total assertions: \\033[93m{{TOTAL_ASSERTIONS}}\\033[0m, in this case, \\033[92m{{PASS_ASSERTIONS}} passed\\033[0m and \\033[91m{{FAILED_ASSERTIONS}} failed\\033[0m.")
    print(f"\\t in global scope (all tests), \\033[92m{{TOTAL_PASSED_ASSERTIONS}} passed\\033[0m and \\033[91m{{TOTAL_FAILED_ASSERTIONS}} failed\\033[0m.\\n")
    if "return" in kwargs:
        return kwargs["return"]
\"\"\"
╭──────────────────────────────────────────────────────────────────────────────────╮
│ YOU CAN MODIFY THE CODE BELOW THIS LINE - DO NOT MODIFY THE CODE ABOVE THIS LINE │
╰──────────────────────────────────────────────────────────────────────────────────╯
\"\"\"
"""
    if ("-*- no color -*-" in OPTIONAL_ARGS_IN_FILE) or (not COLOR_MODULE and not STYLES_MODULE):
        DATA = DATA.replace("from rich import console as r_console; print = r_console.Console().print", '')
    return DATA
@MEMOIZE
def CREATE_CONFIG_FILE(FILE_OBJ: object) -> str:
    """
    Inputs: None
    Outputs: Default config data (string)
    Returns the default config data.
    The returned data is automatically formatted and indented.
    """
    import time
    CURRENT_TIME = time.strftime('%d/%m/%Y %H:%M:%S', time.localtime())
    USE_NO_PYTHON = False
    if not WINDOWS:
        try:
            if input(f"{COLORS['red']}Do you want to default to {COLORS['white']}'--no-python'{COLORS['red']} flag, while running Versace\n{COLORS['red']}NOTE:{COLORS['white']} this could have un-intended issues, turn off in config if your facing any issues (OS: {OS}) {COLORS['magenta']}(recommended)?\n{COLORS['white']}[y/n]: {COLORS['reset']}").lower() == "y":
                USE_NO_PYTHON = True
        except:
            print(f"\n{COLORS['red']}Aborting...{COLORS['reset']}")
            FILE_PATH = FILE_OBJ.name
            FILE_OBJ.close()
            import os
            os.remove(FILE_PATH)
            exit(1)

    CONFIG_DATA = f"""
    # {'-' * len(f"This is the config file for Versace it was auto generated at {CURRENT_TIME}")} #
    # This is the config file for Versace it was auto generated at {CURRENT_TIME} #
    # {'-' * len(f"This is the config file for Versace it was auto generated at {CURRENT_TIME}")} #

    ["BASIC-INFORMATION"]
    version = "{VERSION}"{' ' * (64 - len(f'version = "{VERSION}"'))}# the version of Versace
    indentation = "    "                                            # 4 spaces is the default
    allow_tracking = True                                           # This is to allow tracking of Versace
    allow_update = False                                            # This is to allow updates of Versace

    ["PATHS"]
    python_path = "{ORG_PYTHON_PATH}"{' ' * (62 - len(f'python_path = "{ORG_PYTHON_PATH}"'))}# This is the path to the python interpreter
    versace_path = "{SYSTEM.get_user_dir() + path_sep + '.versace'}"{' ' * (61 - len(f"versace_path = '{SYSTEM.get_user_dir() + path_sep + '.versace'}'"))}# This is the path to the Versace folder

    ["COMPILER"]
    no_includes = False                                             # This determines if the Versace compiler should include the modules specified by the user in their Versace code
    no_args_start = False                                           # This determines if the Versace compiler should start the Versace code with the args passed to the Versace compiler
    no_version_check = False                                        # This determines if the Versace compiler should check for updates
    no_auto_overload = True                                         # This determines if the Versace compiler should automatically overload all user defined functions
    no_python = {USE_NO_PYTHON}                                     # This determines if the Versace compiler should execute with python of with Versace

    ["EXECUTABLE"]
    binary_file_ext = ".exe"                                        # The type of binary to compile to when compiling to binary
    binary = 1                                                      # Optimization level when compiling 0 = low_optimization(one file), 1 = medium_optimization(one dir), 2 = max_optimization(nested_dirs)

    ["EXTRA"]
    keep_perf_data = False                                          # This determines if the Versace compiler should keep the performance data
    always_monitor_perf_data = False                                # This determines if the Versace compiler should always show the performance data
    transpile_file_ext = ".py"                                      # The type of file to transpile to when compiling to python
    use_cache = False                                               # This determines if the Versace compiler should use the cache
    max_includes = 50                                               # The maximum number of includes allowed in a Versace file
    traceback_limit = 3                                             # The maximum number of lines to show in a traceback
    """
    if '\\' in CONFIG_DATA:
        CONFIG_DATA = CONFIG_DATA.replace('\\', '\\\\')
    return CONFIG_DATA
@MEMOIZE
def PACK_CONFIG() -> dict:
    """
    \nInputs: CONFIG_DATA
    \nOutputs: PACK
    \nThis is used to pack all the config data into a single dictionary.
    """
    PACK: dict[str : object] = {}
    PACK['INDENTATION'] = INDENTATION
    PACK['ALLOW_TRACKING'] = ALLOW_TRACKING
    PACK['ALLOW_UPDATE'] = ALLOW_UPDATE
    PACK['PYTHON_PATH'] = PYTHON_PATH
    PACK['VERSACE_PATH'] = VERSACE_PATH
    PACK['NO_INCLUDES'] = NO_INCLUDES
    PACK['NO_ARGS_START'] = NO_ARGS_START
    PACK['NO_VERSION_CHECK'] = NO_VERSION_CHECK
    PACK['BINARY_FILE_EXT'] = BINARY_FILE_EXT
    PACK['BINARY'] = BINARY
    PACK['KEEP_PERF_DATA'] = KEEP_PERF_DATA
    PACK['ALWAYS_MONITOR_PERF_DATA'] = ALWAYS_MONITOR_PERF_DATA
    PACK['TRANSPILE_FILE_EXT'] = TRANSPILE_FILE_EXT
    PACK['USE_CACHE'] = USE_CACHE
    PACK['MAX_INCLUDES'] = MAX_INCLUDES
    PACK['TRACEBACK_LIMIT'] = TRACEBACK_LIMIT
    PACK['no_auto_overload'] = NO_AUTO_OVERLOAD
    PACK['no_python'] = NO_PYTHON
    return PACK
@MEMOIZE
def READ_CONFIG(CONFIG_DATA, FILE_PATH=None) -> None:
    """
    \nInputs: CONFIG_DATA
    \nOutputs: None
    \nThis is used to read the config data and save it to their respective variables.
    """
    global INDENTATION, TRACEBACK_LIMIT, NO_AUTO_OVERLOAD, MAX_INCLUDES, ALLOW_TRACKING, ALLOW_UPDATE, PYTHON_PATH, VERSACE_PATH, NO_INCLUDES, NO_ARGS_START, NO_VERSION_CHECK, BINARY_FILE_EXT, BINARY, KEEP_PERF_DATA, ALWAYS_MONITOR_PERF_DATA, TRANSPILE_FILE_EXT, USE_CACHE, PASS_LIST
    def _expectError(check, type) -> None:
        LINE_TO_CHECK: str = check
        for index, i in enumerate(CONFIG_DATA.split('\n')):
            if i.startswith(LINE_TO_CHECK):
                # check if the eval is valid
                try:
                    BINARY = type(literal_eval(CONFIG_DATA.split (LINE_TO_CHECK)[1].split('\n')[0].split('#')[0].strip()))
                except Exception as e:
                    ERROR_REPORTING(CONFIG_DATA.split('\n')[index], "BadConfigData", e, LINE_NO=index+1, FILE_NAME=FILE_PATH)
                    exit()
        exit()

    SHOULD_BE_PRESENT: list[str] = [
        'binary',
        'use_cache',
        'indentation',
        'no_includes',
        'python_path',
        'allow_update',
        'versace_path',
        'no_args_start',
        'keep_perf_data',
        'allow_tracking',
        'binary_file_ext',
        'no_version_check',
        'no_auto_overload',
        'transpile_file_ext',
        'always_monitor_perf_data',
        'max_includes',
        'traceback_limit',
        'no_python',
    ]
    for i in SHOULD_BE_PRESENT:
        if i not in CONFIG_DATA:
            ERROR_REPORTING(i, "BadConfigData", f"Missing {COLORS['yellow']}'{i}'{COLORS['red']} in config file, please add/delete to/the config file to rebuild", LINE_NO=0, FILE_NAME=FILE_PATH)
            exit()
    try:
        try: BINARY                   = int (literal_eval(CONFIG_DATA.split(         'binary = '         )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('binary = ', int)

        try: USE_CACHE                = bool(literal_eval(CONFIG_DATA.split(       'use_cache = '        )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('use_cache = ', bool)

        try: INDENTATION              = str (literal_eval(CONFIG_DATA.split(      'indentation = '       )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('indentation = ', str)

        try: NO_INCLUDES              = bool(literal_eval(CONFIG_DATA.split(      'no_includes = '       )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('no_includes = ', bool)

        try: PYTHON_PATH              = str (literal_eval(CONFIG_DATA.split(      'python_path = '       )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('python_path = ', str)

        try: ALLOW_UPDATE             = bool(literal_eval(CONFIG_DATA.split(      'allow_update = '      )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('allow_update = ', bool)

        try: VERSACE_PATH             = str (literal_eval(CONFIG_DATA.split(      'versace_path = '      )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('versace_path = ', str)

        try: NO_ARGS_START            = bool(literal_eval(CONFIG_DATA.split(     'no_args_start = '      )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('no_args_start = ', bool)

        try: KEEP_PERF_DATA           = bool(literal_eval(CONFIG_DATA.split(     'keep_perf_data = '     )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('keep_perf_data = ', bool)

        try: ALLOW_TRACKING           = bool(literal_eval(CONFIG_DATA.split(     'allow_tracking = '     )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('allow_tracking = ', bool)

        try: BINARY_FILE_EXT          = str (literal_eval(CONFIG_DATA.split(    'binary_file_ext = '     )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('binary_file_ext = ', str)

        try: NO_VERSION_CHECK         = bool(literal_eval(CONFIG_DATA.split(    'no_version_check = '    )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('no_version_check = ', bool)

        try: NO_AUTO_OVERLOAD         = bool(literal_eval(CONFIG_DATA.split(    'no_auto_overload = '    )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('no_auto_overload = ', bool)

        try: TRANSPILE_FILE_EXT       = str (literal_eval(CONFIG_DATA.split(   'transpile_file_ext = '   )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('transpile_file_ext = ', str)

        try: ALWAYS_MONITOR_PERF_DATA = bool(literal_eval(CONFIG_DATA.split('always_monitor_perf_data = ')[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('always_monitor_perf_data = ', bool)

        try: MAX_INCLUDES            = int(literal_eval(CONFIG_DATA.split(     'max_includes = '         )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('max_includes = ', int)

        try:
            TRACEBACK_LIMIT         = int(literal_eval(CONFIG_DATA.split(     'traceback_limit = '      )[1].split('\n')[0].split('#')[0].strip()))
            if TRACEBACK_LIMIT < 0: TRACEBACK_LIMIT = 1
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('traceback_limit = ', int)

        try:
            if bool(literal_eval(CONFIG_DATA.split('no_python = ')[1].split('\n')[0].split('#')[0].strip())) is True:
                PASS_LIST.append('-no-py')
                if '-py' in PASS_LIST: PASS_LIST.remove('-no-py')
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('no_python = ', bool)

        return 0

    except (ValueError, SyntaxError, NameError, TypeError, IndexError):
        raise AssertionError('Invalid config file.')

# ------------------ Debug Functions ------------------ #
@ASYNC
def COLLECT_DATA() -> None:
    """
    \n This function collects data about the system and adds it to the debug data.
    """
    global DEBUG_DATA
    from psutil import virtual_memory, cpu_count, cpu_percent, cpu_freq, cpu_times, cpu_times, cpu_stats, \
        disk_usage, disk_usage, disk_usage, disk_usage, disk_partitions, disk_io_counters, disk_io_counters, net_io_counters, net_io_counters, net_connections, \
        net_if_addrs, net_if_stats
    from sys import prefix, base_prefix, base_exec_prefix
    from platform import node, machine, python_version, python_compiler, python_build, python_implementation, python_version_tuple, release
    from platform import system as PT_SYS
    DEBUG_DATA.append("----------------------- SYSTEM INFORMATION -----------------------")
    try:
        DEBUG_DATA.append(f"Hostname: {str(node()).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"Hardware: {str(machine()).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"OS: {str(PT_SYS()).replace(SYSTEM.get_user_dir(), '~')} {str(release()).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"Python Version: {str(python_version()).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"Python Compiler: {str(python_compiler()).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"Python Build: {str(python_build()).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"Python Implementation: {str(python_implementation()).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"Python Implementation Version: {str(python_version_tuple()).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"Python Executable: {str(ORG_PYTHON_PATH).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"Python Path: {str(SYS_PATH).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"Python Prefix: {str(prefix).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"Python Base Prefix: {str(base_prefix).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"Python Base Executable: {str(base_exec_prefix).replace(SYSTEM.get_user_dir(), '~')}")
        DEBUG_DATA.append(f"RAM: {virtual_memory().total}")
        DEBUG_DATA.append(f"CPU: {cpu_count()}")
        DEBUG_DATA.append(f"CPU Usage: {cpu_percent()}")
        DEBUG_DATA.append(f"CPU Frequency: {cpu_freq()}")
        DEBUG_DATA.append(f"CPU Cores: {cpu_count(logical=False)}")
        DEBUG_DATA.append(f"CPU Usage Per Core: {cpu_percent(percpu=True)}")
        DEBUG_DATA.append(f"CPU Frequency Per Core: {cpu_freq(percpu=True)}")
    except Exception as e:
        DEBUG_DATA.append(f"Error: {e}")
        pass
    if ALLOW_TRACKING:
        try:
            DEBUG_DATA.append(f"CPU Times: {cpu_times()}")
            DEBUG_DATA.append(f"CPU Times Per Core: {cpu_times(percpu=True)}")
            DEBUG_DATA.append(f"CPU Stats: {cpu_stats()}")
            DEBUG_DATA.append(f"Free Disk Space: {disk_usage('/').free}")
            DEBUG_DATA.append(f"Total Disk Space: {disk_usage('/').total}")
            DEBUG_DATA.append(f"Used Disk Space: {disk_usage('/').used}")
            DEBUG_DATA.append(f"Disk Usage: {disk_usage('/')}")
            DEBUG_DATA.append(f"Disk Partitions: {disk_partitions()}")
            DEBUG_DATA.append(f"Disk IO Counters: {disk_io_counters()}")
            DEBUG_DATA.append(f"Disk IO Counters Per Disk: {disk_io_counters(perdisk=True)}")
            DEBUG_DATA.append(f"Network IO Counters: {net_io_counters()}")
            DEBUG_DATA.append(f"Network IO Counters Per Interface: {net_io_counters(pernic=True)}")
            DEBUG_DATA.append(f"Network Connections: {net_connections()}")
            DEBUG_DATA.append(f"Network Interfaces: {net_if_addrs()}" )
            DEBUG_DATA.append(f"Network Interfaces Stats: {net_if_stats()}")
        except Exception as e:
            DEBUG_DATA.append(f"Error: {e}")
            pass
    DEBUG_DATA.append("-------------- Versace Debug Data --------------")
    global EMOJI_UNICODE
    del EMOJI_UNICODE
    DEBUG_DATA.append(globals())
    DEBUG_DATA.append(locals())
    DEBUG_DATA.append("----------------- End of Data ------------------")
    DEBUG_DATA = tuple(DEBUG_DATA)
    return DEBUG_DATA
def SHOW_PERF_DATA(time_diff, amount, TERMINAL_WIDTH) -> None:
    #print(f"\ntotal {(time_diff-amount):.5f}{'ms' if time_diff < 1 else 's'}\r")
    #exit()
    Box_Color: str = 'red'
    Text_Color: str = 'yellow'
    _system("")
    print(f"\n{COLORS[Box_Color]}╭{'─'*(TERMINAL_WIDTH-2)}╮{COLORS['reset']}\r")
    # get the pos of the cursor in the terminal
    CALL_METHOD: str
    LINES_TO_PRINT: list = [
        f"Execution time for file '{FILE_PATH.replace(SYSTEM.get_c_dir() + path_sep, '')}' is : {COLORS['green']}{(time_diff-amount):.5f}{'ms' if time_diff < 1 else 's'}",
        "NOTE: The execution time is only the runtime of the Versace Program, and does not take into account the time it takes to compile or transpile the code."
    ]
    if '-p' in PASS_LIST and ALWAYS_MONITOR_PERF_DATA:
        CALL_METHOD = f"INFO: Performance data was called with the '-p' argument, and Always Monitor Performance is set to {ALWAYS_MONITOR_PERF_DATA} in the config file."
    elif '-p' not in PASS_LIST and ALWAYS_MONITOR_PERF_DATA:
        CALL_METHOD = f"INFO: Always Monitor Performance is {ALWAYS_MONITOR_PERF_DATA} in the config file."
    elif '-p' in PASS_LIST and ALWAYS_MONITOR_PERF_DATA is False:
        CALL_METHOD = "INFO: Performance data was called with the '-p' argument."
    LINES_TO_PRINT.append(CALL_METHOD)
    # wrap the lines to print to the terminal
    for i in range(len(LINES_TO_PRINT)):
        LINES_TO_PRINT[i] = wrap(LINES_TO_PRINT[i], width=TERMINAL_WIDTH-4)
    # print the lines
    for i in LINES_TO_PRINT:
        for j in i:
            if 'Execution time' in j:
                print(f"{COLORS[Box_Color]}│ {COLORS[Text_Color]}{j} {COLORS[Box_Color]}{' '*((TERMINAL_WIDTH-len(j)))} │{COLORS['reset']}")
            else:
                print(f"{COLORS[Box_Color]}│ {COLORS[Text_Color]}{j}{COLORS[Box_Color]}{' '*((TERMINAL_WIDTH-len(j))-4)} │{COLORS['reset']}")
    print(f"{COLORS[Box_Color]}╰{'─'*(TERMINAL_WIDTH-2)}╯{COLORS['reset']}")
@ASYNC
def SAVE_PERF_DATA(time_diff, amount, TERMINAL_WIDTH, DEBUG=False) -> None:
    from psutil import virtual_memory, disk_usage
    _system("")
    Box_Color: str = 'green'
    Text_Color: str = 'yellow'
    PERF_DATA_FILE = f"debug{path_sep}performance.rt"
    METADATA = f" Data was generated on {strftime('%d/%m/%Y')} at {strftime('%H:%M:%S')} "
    # read the previous run attempt in the file
    from os import path as os_path
    if SYSTEM.path_exists(PERF_DATA_FILE) is False:
        SYSTEM.make_dirs(os_path.dirname(PERF_DATA_FILE), exist_ok=True)
        with open(PERF_DATA_FILE, 'w', encoding="utf-8") as f:
            f.close()
    with open(PERF_DATA_FILE, 'r', encoding="utf-8") as f:
        try:
            PREVIOUS_RUN_ATTEMPT: int = int(f.readlines()[-2].split('|')[1].strip().split(' ')[-1])
            PREVIOUS_RUN_ATTEMPT += 1
        except (IndexError, ValueError):
            PREVIOUS_RUN_ATTEMPT: int = 0 if v_stat(PERF_DATA_FILE) == 0 else "ERROR"
    with open(PERF_DATA_FILE, 'a', encoding="utf-8") as f:
        if v_stat(PERF_DATA_FILE) == 0:
            f.write(f"{'This file contains the performance data for Versace':^80}\n")
            f.write(f"{'This file is generated when you run Versace with the -p argument':^80}\n")
            f.write(f"{'This file may be used by the Performance Analyzer':^80}\n")
            f.write(f"{'Do not delete or modify this file unless you know what you are doing':^80}\n")
        f.write(f"\n{METADATA:-^80}\n")
        LINE1 = f"1 | Runtime: \"{(time_diff-amount):.5f}{'ms' if time_diff < 1 else 's'}\""
        f.write(f"{LINE1}{' '*(80-len(LINE1) - 1)}|\n")
        LINE2 = f"2 | Total Lines: \"{len(''.join(LINES_FROM_FILE_RAW))}\""
        f.write(f"{LINE2}{' '*(80-len(LINE2) - 1)}|\n")
        LINE3 = f"3 | Memory Usage: \"{virtual_memory().percent}%\""
        f.write(f"{LINE3}{' '*(80-len(LINE3) - 1)}|\n")
        LINE4 = f"4 | Disk Usage: \"{disk_usage('/').percent}%\""
        f.write(f"{LINE4}{' '*(80-len(LINE4) - 1)}|\n")
        LINE5 = f"5 | Run Attempt: {PREVIOUS_RUN_ATTEMPT}"
        f.write(f"{LINE5}{' '*(80-len(LINE5) - 1)}|\n")
        f.write(f"{'END OF DATA':-^80}\n")
    BOX_PRINT(f"Performance data was saved to the file '{PERF_DATA_FILE}'", Text_Color, Box_Color)
@ASYNC
def GEN_NEW_SYNTAX_HIGHLIGHTING_DATA() -> None:
    """Generates a new syntax file for Versace."""
    _system("")
    KW_MATCH = r'"match": "\\b(public|let|priv|if|else|if|for|while|override|class|struct|static|enum|method|func|async|await|coroutine|del|rem|const|ref|out|in|include|import|from|pyc|from|as|include|in|has|or|and|not|is|catch|throw|dyn|final|virtual)\\b"'
    DT_MATCH = r'"match": "\\b(array|arr|int|float|complex|double|str|bool|list|dict|tuple|set|bytes|char|memoryview|bytearray|frozenset|range|nullType)\\b"'
    M_MATCH1 = r'"match": "(@)\\w+"'
    M_MATCH2 = r'"match": "@"'
    NEW_KW_MATCH = r'"match": "\\b('
    NEW_DT_MATCH = r'"match": "\\b('
    NEW_M_MATCH1 = fr'"match": "({"".join(METHOD_CALL_TOKENS.keys())})\\w+"'
    NEW_M_MATCH2 = fr'"match": "{"".join(METHOD_CALL_TOKENS.keys())}"'
    print("Generating a new syntax file...")
    for index, i in enumerate(KEYWORD_TOKENS.keys()):
        if index == len(KEYWORD_TOKENS.keys()) - 1:
            NEW_KW_MATCH += i + r')\\b"'
            break
        NEW_KW_MATCH += i + "|"
    for index, i in enumerate(DATA_TYPE_TOKENS.keys()):
        if index == len(DATA_TYPE_TOKENS.keys()) - 1:
            NEW_DT_MATCH += i + r')\\b"'
            break
        NEW_DT_MATCH += i + "|"
    # where are vscode extensions located?
    VSCODE_EXT_DIR = fr"{SYSTEM.get_user_dir()}{path_sep}.vscode{path_sep}extensions" if WINDOWS else r"~/.vscode/extensions"
    print(f"{COLORS['red']}Head over to where the syntax file is located inside the extension folder in a sub-folder called syntax (usually here: \"{VSCODE_EXT_DIR}\") and replace the following lines:{COLORS['reset']}")
    print(f"{COLORS['red']}Line 1: {COLORS['yellow']}{KW_MATCH}{COLORS['reset']}")
    print(f"{COLORS['red']}Replace with: {COLORS['green']}{NEW_KW_MATCH}{COLORS['reset']}")
    print(f"{COLORS['red']}Line 2: {COLORS['yellow']}{DT_MATCH}{COLORS['reset']}")
    print(f"{COLORS['red']}Replace with: {COLORS['green']}{NEW_DT_MATCH}{COLORS['reset']}")
    print(f"{COLORS['red']}Line 3: {COLORS['yellow']}{M_MATCH1}{COLORS['reset']}")
    print(f"{COLORS['red']}Replace with: {COLORS['green']}{NEW_M_MATCH1}{COLORS['reset']}")
    print(f"{COLORS['red']}Line 4: {COLORS['yellow']}{M_MATCH2}{COLORS['reset']}")
    print(f"{COLORS['red']}Replace with: {COLORS['green']}{NEW_M_MATCH2}{COLORS['reset']}")
    print(f"{COLORS['red']}Then restart VSCode and you should be good to go!{COLORS['reset']}")
    exit()
def SHOW_DEBUG_DATA() -> None:
    global FINAL_LIST, PASS_LIST, DEBUG_DATA, LINES_FROM_FILE_RAW, LOADING_IN_PROGRESS, ERROR_CHECK_ERROR
    from rich import console as c_console; rich_print = c_console.Console().print # Define the O__CODE_PRINT variable
    from random import SystemRandom
    from rich.pretty import pprint
    from rich.syntax import Syntax
    from pygments.lexer import RegexLexer, bygroups, default
    from pygments import highlight
    from pygments.formatters import TerminalTrueColorFormatter, TerminalFormatter
    from pygments.token import Keyword, Name, Comment, String, Number, Operator, Whitespace, Text
    from sys import stdout as sys_stdout

    # make it so only the exact words are highlighted and not the words that contain them
    class VersaceSyntaxHighlightingLexer(RegexLexer):
        name = 'Versace'
        aliases = ['Versace']
        filenames = ['*.v', '*.vpkg', '*.vh']
        tokens = {
            'root': [
                (r'\n', Whitespace), (r'\s+', Whitespace), (r'//!.*?\n', String.Doc), (r'///(\n|[^/].*?\n)', String.Doc),
                (r'//(.*?)\n', Comment.Single), (r'/\*\*(\n|[^/*])', String.Doc, 'document'), (r'/\*!', String.Doc, 'document'),
                (r'/\*', Comment.Multiline, 'comment'), (r'//.*?$', Comment), (r'".*?"', String),
                (r'""".*?"""', String),
                (r'\d+\.\d+[eE][+-]?\d+', Number), (r'\d+\.\d+[eE]\d+', Number),
                (r'func\b', Keyword, 'function'), (r'([a-zA-Z_][a-zA-Z0-9_]*)(\()', bygroups(Name.Function, Text)), (r'async\s+func\b', Keyword, 'function'),
                (r'([a-zA-Z_][a-zA-Z0-9_]*)(::)([a-zA-Z_][a-zA-Z0-9_]*)', bygroups(Name.Class, Text, Name.Function)), (r'[A-Z]\w+', Name.Class), (r'public\b', Keyword), (r'priv\b', Keyword),
                (r'int\b', Keyword.Type), (r'float\b', Keyword.Type), (r'complex\b', Keyword.Type),
                (r'double\b', Keyword.Type), (r'str\b', Keyword.Type), (r'usize\b', Keyword.Type), (r'bool\b', Keyword.Type),
                (r'list\b', Keyword.Type), (r'map\b', Keyword.Type), (r'array\b', Keyword.Type),
                (r'set\b', Keyword.Type), (r'bytes\b', Keyword.Type), (r'object\b', Keyword.Type), (r'char\b', Keyword.Type),
                (r'self\b', Keyword.Type), (r'super\b', Keyword.Type), (r'memoryview\b', Keyword.Type), (r'bytearray\b', Keyword.Type),
                (r'NULL\b', Keyword.Type), (r'NULLType\b', Keyword.Type), (r'u8\b', Keyword.Type), (r'frozenset\b', Keyword.Type),
                (r'u128\b', Keyword.Type), (r'i8\b', Keyword.Type), (r'i16\b', Keyword.Type), (r'i32\b', Keyword.Type),
                (r'i64\b', Keyword.Type), (r'i128\b', Keyword.Type), (r'f32\b', Keyword.Type), (r'f64\b', Keyword.Type), (r'True\b', Keyword.Type), (r'False\b', Keyword.Type),
                (r'u16\b', Keyword.Type), (r'u32\b', Keyword.Type), (r'u64\b', Keyword.Type), (r'u128\b', Keyword.Type), (r'range\b', Keyword.Type), (r'true\b', Keyword.Type), (r'false\b', Keyword.Type),
                (r'method\b', Keyword), (r'with\b', Keyword),  (r'call\b', Keyword), (r'else\b', Keyword), (r'else\s+if\b', Keyword), (r'while\b', Keyword), (r'break\b', Keyword), (r'continue\b', Keyword), (r'catch\b', Keyword), (r'throw\b', Keyword),
                (r'return\b', Keyword), (r'if\b', Keyword), (r'class\b', Keyword), (r'struct\b', Keyword), (r'static\b', Keyword), (r'enum\b', Keyword), (r'await\b', Keyword),
                (r'coroutine\b', Keyword), (r'const\b', Keyword), (r'final\b', Keyword), (r'include\b', Keyword), (r'import\b', Keyword), (r'extends\b', Keyword), (r'copy\b', Keyword),
                (r'type\b', Keyword), (r'from\b', Keyword), (r'for\b', Keyword), (r'let\b', Keyword), (r'rem\b', Keyword), (r'out\b', Keyword), (r'pyc\b', Keyword),
                (r'ref\b', Keyword), (r'ptr\b', Keyword), (r'new\b', Keyword), (r'in\b', Keyword), (r'as\b', Keyword), (r'assert\b', Keyword), (r'async\b', Keyword),
                (r'and\b', Operator), (r'or\b', Operator), (r'not\b', Operator),
                (r'is\b', Operator), (r'is\s+not\b', Operator), (r'in\b', Operator), (r'not\s+in\b', Operator), (r'not\b', Operator), (r'\<\b', Operator), (r'\>\b', Operator),
                (r'\=\b', Operator), (r'\!\b', Operator), (r'\+\b', Operator), (r'\-\b', Operator), (r'\*\b', Operator), (r'\-\-\b', Operator), (r'\+\+\b', Operator),
                (r'\/\b', Operator), (r'\%\b', Operator), (r'\^\b', Operator), (r'\&\b', Operator), (r'\>\>\b', Operator), (r'\<\<\b', Operator),
                (r'\*\*\b', Operator), (r'\.\.\.\b', Operator), (r'\@\b', Name.Function), (r'\d+', Number), (r'\d+\.\d+', Number),
                (r'\d+\.\d+[jJ]', Number), (r'\d+[jJ]', Number), (r'\d+[eE][+-]?\d+', Number),  (r'\d+[eE]\d+', Number), (r'(\w+)', Name.Variable),
                (r'\d+\.\d+', Number), (r'\:\:\b', Text),
            ], 'comment': [
                (r'[^*/]+', Comment.Multiline), (r'/\*', Comment.Multiline, '#push'), (r'\*/', Comment.Multiline, '#pop'), (r'[*/]', Comment.Multiline),
            ], 'document': [
                (r'[^*/]+', String.Doc), (r'/\*', String.Doc, '#push'), (r'\*/', String.Doc, '#pop'), (r'[*/]', String.Doc),
            ], 'function': [
                (r'\s+', Text), (r'[a-zA-Z_]\w*', Name.Function, '#pop'), default('#pop'),
            ]
        }
    lexer = VersaceSyntaxHighlightingLexer()
    formatter = TerminalTrueColorFormatter(style='one-dark') if sys_stdout.isatty() else TerminalFormatter(style='one-dark')

    _system("")

    if INCLUDES:
        for i in INCLUDES:
            with open(i, "r", encoding="utf-8") as f:
                print(f"\n{COLORS['red']}{'-'*int((TERMINAL_WIDTH-31)/2)} Original Data From {path.basename(i)} {'-'*int((TERMINAL_WIDTH-31-1)/2)}{COLORS['reset']}")
                OUTPUT = highlight(f.read(), lexer, formatter).rstrip()
                OUTPUT = OUTPUT.splitlines()
                for i in range(len(OUTPUT)):
                    OUTPUT[i] = f"{COLORS['grey']}{i+1:>4} {OUTPUT[i]}"
                print('\n'.join(OUTPUT))
                f.close()
            continue

    else:
        print(f"\n{COLORS['red']}{'-'*int((TERMINAL_WIDTH-31)/2)} Original Data From {path.basename(FILE_PATH)} {'-'*int((TERMINAL_WIDTH-31-1)/2)}{COLORS['reset']}")
        OUTPUT = highlight(''.join(LINES_FROM_FILE_RAW), lexer, formatter).rstrip()
        OUTPUT = OUTPUT.splitlines()
        for i in range(len(OUTPUT)):
            OUTPUT[i] = f"{COLORS['grey']}{i+1:>4} {OUTPUT[i]}"
        print('\n'.join(OUTPUT))

    print(f"\n{COLORS['red']}{'-'*int((TERMINAL_WIDTH-33)/2)} Python Code Generated by Versace {'-'*int((TERMINAL_WIDTH-33-1)/2)}{COLORS['reset']}")
    OUTPUT = Syntax('\n'.join(FINAL_LIST), "python", theme="one-dark", line_numbers=True, background_color="default") # Define the D__TOKENS variable
    rich_print(OUTPUT) # Print the D__TOKENS
    rich_print(f"\nPath to Generated Code: \"{f'{VERSACE_PATH}{path_sep}temp{path_sep}{path.basename(FILE_PATH)}.py'}\"", style="red")
    rich_print("Checking Generated Code for Errors...\n", style="red")
    from subprocess import run as execute_subprocess
    LOADING_IN_PROGRESS = True
    CHECKING_BAR("Processing", "Processed")
    wait(SystemRandom().uniform(0, 2))
    try:
        if execute_subprocess([ORG_PYTHON_PATH, f'{VERSACE_PATH}{path_sep}temp{path_sep}{path.basename(FILE_PATH)}.py'], check=False, capture_output=True, text=False, timeout=25, encoding='utf-8', errors='ignore').returncode != 0:
            LOADING_IN_PROGRESS = False
            ERROR_CHECK_ERROR = True
            wait(0.50)
            print('')
            rich_print("[red]Generated Code Contains Errors.")
            rich_print("[red]If you would like the complete debug data you can add the [yellow]-all[/yellow] flag to the command line.")
    except Exception as e:
        LOADING_IN_PROGRESS = False
        ERROR_CHECK_ERROR = True
        wait(0.50)
        print('')
        rich_print(f"[red]The Error Checker Encountered an Error. Please report this code to Versace: \"{(MAKE_ERROR_CODE(str(e.__class__.__name__))).strip()}\"")
        rich_print("[red]If you would like the complete debug data you can add the [yellow]-all[/yellow] flag to the command line.")
    else:
        LOADING_IN_PROGRESS = False
        wait(0.50)
        print('')
        rich_print("[green]Generated Code Contains No Errors.")
        rich_print("[green]If you would like the complete debug data you can add the [yellow]-all[/yellow] flag to the command line.")
    LOADING_IN_PROGRESS = False
    if '-all' in PASS_LIST:
        print(f"\n{COLORS['red']}{'-'*int((TERMINAL_WIDTH-21)/2)} COMPLETE DEBUG STACK {'-'*int((TERMINAL_WIDTH-21)/2)}{COLORS['reset']}")
        # remove EMOJI_UNICODE from DEBUG_DATA which is a tuple
        DEBUG_DATA = list(DEBUG_DATA)
        DEBUG_DATA.pop(0)
        from rich.console import Console as RichConsole
        r_console = RichConsole()
        r_console.print(DEBUG_DATA)
    return

@ASYNC
def CHECKING_BAR(text_to_show: str, completed_text: str) -> None:
    COUNT = 0
    while COUNT < 25:
        print(f"\r{COLORS['red']}{text_to_show} {COUNT:<2} [{COLORS['red']}{'━'*(COUNT)}{'╸'}{COLORS['grey']}{'━'*(24-COUNT)}{COLORS['red']}]{COLORS['reset']}", end='')
        #if not LOADING_IN_PROGRESS: print(f"\r{COLORS['red']}{completed_text} {COUNT} [{COLORS['green']}{'━'*(25)}{COLORS['red']}]{COLORS['reset']}", end='')
        wait(0.25) if LOADING_IN_PROGRESS else wait(0.01)
        COUNT += 1
    if not ERROR_CHECK_ERROR:
        print(f"\r{COLORS['red']}{completed_text}  {COUNT:<2} [{COLORS['green']}{'━'*(COUNT)}{COLORS['red']}]{COLORS['reset']}", end='')
        return
    print(f"\r{COLORS['red']}{completed_text}  {COUNT:<2} [{COLORS['green']}{'━'*(COUNT)}{COLORS['red']}]{COLORS['reset']}")

def DUMP_DATA() -> None:
    from os import path as os_path
    if WINDOWS:
        make_dir = os_path.mkdir
    else:
        from os import makedirs as make_dir
    if os_path.exists(f"{VERSACE_PATH}{path_sep}dump") is False:
        make_dir(f"{VERSACE_PATH}{path_sep}dump", exist_ok=True)
    # remove all .dmp files in the dump folder
    REMOVE = {}
    for file in listdir(f"{VERSACE_PATH}{path_sep}dump"):
        if file.endswith(".dmp"):
            REMOVE[file] = path.join(f"{VERSACE_PATH}{path_sep}dump", file)
    # check the number of files in the dump folder
    if len(REMOVE) > 10:
        # sort the files by date
        REMOVE = {k: v for k, v in sorted(REMOVE.items(), key=lambda item: item[1])}
        # remove the oldest file
        remove(list(REMOVE.values())[0])
    with open(f"{VERSACE_PATH}{path_sep}dump{path_sep}{path.basename(FILE_PATH)}.dmp", 'w', encoding="utf-8") as f:
        from rich.pretty import pprint
        fs = StringIO()
        with redirect_stdout(fs):
            pprint((DEBUG_DATA))
        DATA = fs.getvalue().replace('\x1b[0m', '').replace('\x1b[1m', '').replace('\x1b[2m', '').replace('\x1b[3m', '')
        DATA.replace('\x1b[4m', '').replace('\x1b[5m', '').replace('\x1b[6m', '').replace('\x1b[7m', '').replace('\x1b[8m', '')
        DATA.replace('\x1b[9m', '').replace('\x1b[30m', '').replace('\x1b[31m', '').replace('\x1b[32m', '').replace('\x1b[33m', '')
        DATA.replace('\x1b[34m', '').replace('\x1b[35m', '').replace('\x1b[36m', '').replace('\x1b[37m', '').replace('\x1b[38m', '')
        DATA.replace('\x1b[39m', '').replace('\x1b[40m', '').replace('\x1b[41m', '').replace('\x1b[42m', '').replace('\x1b[43m', '')
        DATA.replace('\x1b[44m', '').replace('\x1b[45m', '').replace('\x1b[46m', '').replace('\x1b[47m', '').replace('\x1b[48m', '')
        DATA.replace('\x1b[49m', '').replace('\x1b[90m', '').replace('\x1b[91m', '').replace('\x1b[92m', '').replace('\x1b[93m', '')
        DATA.replace('\x1b[94m', '').replace('\x1b[95m', '').replace('\x1b[96m', '').replace('\x1b[97m', '').replace('\x1b[98m', '')
        DATA.replace('\x1b[99m', '').replace('\x1b[100m', '').replace('\x1b[101m', '').replace('\x1b[102m', '').replace('\x1b[103m', '')
        DATA.replace('\x1b[104m', '').replace('\x1b[105m', '').replace('\x1b[106m', '').replace('\x1b[107m', '').replace('\x1b[108m', '')
        DATA.replace('\x1b[109m', '').replace('\x1b[2;30m', '').replace('\x1b[2;31m', '').replace('\x1b[2;32m', '').replace('\x1b[2;33m', '')
        DATA.replace('\x1b[2;34m', '').replace('\x1b[2;35m', '').replace('\x1b[2;36m', '').replace('\x1b[2;37m', '').replace('\x1b[2;38m', '')
        DATA.replace('\x1b[2;39m', '').replace('\x1b[2;40m', '').replace('\x1b[2;41m', '').replace('\x1b[2;42m', '').replace('\x1b[2;43m', '')
        DATA.replace('\x1b[2;44m', '').replace('\x1b[2;45m', '').replace('\x1b[2;46m', '').replace('\x1b[2;47m', '').replace('\x1b[2;48m', '')
        DATA.replace('\x1b[2;49m', '').replace('\x1b[2;90m', '').replace('\x1b[2;91m', '').replace('\x1b[2;92m', '').replace('\x1b[2;93m', '')
        DATA.replace('\x1b[2;94m', '').replace('\x1b[2;95m', '').replace('\x1b[2;96m', '').replace('\x1b[2;97m', '').replace('\x1b[2;98m', '')
        DATA.replace('\x1b[2;99m', '').replace('\x1b[2;100m', '').replace('\x1b[2;101m', '').replace('\x1b[2;102m', '').replace('\x1b[2;103m', '')
        DATA.replace('\x1b[2;104m', '').replace('\x1b[2;105m', '').replace('\x1b[2;106m', '').replace('\x1b[2;107m', '').replace('\x1b[2;108m', '')
        DATA.replace('\x1b[2;109m', '').replace('\x1b[3;30m', '').replace('\x1b[3;31m', '').replace('\x1b[3;32m', '').replace('\x1b[3;33m', '')
        DATA.replace('\x1b[3;34m', '').replace('\x1b[3;35m', '').replace('\x1b[3;36m', '').replace('\x1b[3;37m', '').replace('\x1b[3;38m', '')
        DATA.replace('\x1b[3;39m', '').replace('\x1b[3;40m', '').replace('\x1b[3;41m', '').replace('\x1b[3;42m', '').replace('\x1b[3;43m', '')
        DATA.replace('\x1b[3;44m', '').replace('\x1b[3;45m', '').replace('\x1b[3;46m', '').replace('\x1b[3;47m', '').replace('\x1b[3;48m', '')
        DATA.replace('\x1b[3;49m', '').replace('\x1b[3;90m', '').replace('\x1b[3;91m', '').replace('\x1b[3;92m', '').replace('\x1b[3;93m', '')
        DATA.replace('\x1b[3;94m', '').replace('\x1b[3;95m', '').replace('\x1b[3;96m', '').replace('\x1b[3;97m', '').replace('\x1b[3;98m', '')
        DATA.replace('\x1b[3;99m', '').replace('\x1b[3;100m', '').replace('\x1b[3;101m', '').replace('\x1b[3;102m', '').replace('\x1b[3;103m', '')
        DATA.replace('\x1b[3;104m', '').replace('\x1b[3;105m', '').replace('\x1b[3;106m', '').replace('\x1b[3;107m', '').replace('\x1b[3;108m', '')
        DATA.replace('\x1b[3;109m', '').replace('\x1b[3;30m', '').replace('\x1b[3;31m', '').replace('\x1b[3;32m', '').replace('\x1b[3;33m', '')
        DATA.replace('\x1b[4;34m', '').replace('\x1b[4;35m', '').replace('\x1b[4;36m', '').replace('\x1b[4;37m', '').replace('\x1b[4;38m', '')
        DATA.replace('\x1b[4;39m', '').replace('\x1b[4;40m', '').replace('\x1b[4;41m', '').replace('\x1b[4;42m', '').replace('\x1b[4;43m', '')
        DATA.replace('\x1b[4;44m', '').replace('\x1b[4;45m', '').replace('\x1b[4;46m', '').replace('\x1b[4;47m', '').replace('\x1b[4;48m', '')
        DATA.replace('\x1b[4;49m', '').replace('\x1b[4;90m', '').replace('\x1b[4;91m', '').replace('\x1b[4;92m', '').replace('\x1b[4;93m', '')
        DATA.replace('\x1b[4;94m', '').replace('\x1b[4;95m', '').replace('\x1b[4;96m', '').replace('\x1b[4;97m', '').replace('\x1b[4;98m', '')
        DATA.replace('\x1b[4;99m', '').replace('\x1b[4;100m', '').replace('\x1b[4;101m', '').replace('\x1b[4;102m', '').replace('\x1b[4;103m', '')
        DATA.replace('\x1b[4;104m', '').replace('\x1b[4;105m', '').replace('\x1b[4;106m', '').replace('\x1b[4;107m', '').replace('\x1b[4;108m', '')
        DATA.replace('\x1b[4;109m', '').replace('\x1b[4;30m', '').replace('\x1b[4;31m', '').replace('\x1b[4;32m', '').replace('\x1b[4;33m', '')
        DATA.replace('\x1b[5;34m', '').replace('\x1b[5;35m', '').replace('\x1b[5;36m', '').replace('\x1b[5;37m', '').replace('\x1b[5;38m', '')
        DATA.replace('\x1b[5;39m', '').replace('\x1b[5;40m', '').replace('\x1b[5;41m', '').replace('\x1b[5;42m', '').replace('\x1b[5;43m', '')
        DATA.replace('\x1b[5;44m', '').replace('\x1b[5;45m', '').replace('\x1b[5;46m', '').replace('\x1b[5;47m', '').replace('\x1b[5;48m', '')
        DATA.replace('\x1b[5;49m', '').replace('\x1b[5;90m', '').replace('\x1b[5;91m', '').replace('\x1b[5;92m', '').replace('\x1b[5;93m', '')
        DATA.replace('\x1b[5;94m', '').replace('\x1b[5;95m', '').replace('\x1b[5;96m', '').replace('\x1b[5;97m', '').replace('\x1b[5;98m', '')
        DATA.replace('\x1b[5;99m', '').replace('\x1b[5;100m', '').replace('\x1b[5;101m', '').replace('\x1b[5;102m', '').replace('\x1b[5;103m', '')
        DATA.replace('\x1b[5;104m', '').replace('\x1b[5;105m', '').replace('\x1b[5;106m', '').replace('\x1b[5;107m', '').replace('\x1b[5;108m', '')
        DATA.replace('\x1b[5;109m', '').replace('\x1b[5;30m', '').replace('\x1b[5;31m', '').replace('\x1b[5;32m', '').replace('\x1b[5;33m', '')
        DATA.replace('\x1b[6;34m', '').replace('\x1b[6;35m', '').replace('\x1b[6;36m', '').replace('\x1b[6;37m', '').replace('\x1b[6;38m', '')
        DATA.replace('\x1b[6;39m', '').replace('\x1b[6;40m', '').replace('\x1b[6;41m', '').replace('\x1b[6;42m', '').replace('\x1b[6;43m', '')
        DATA.replace('\x1b[6;44m', '').replace('\x1b[6;45m', '').replace('\x1b[6;46m', '').replace('\x1b[6;47m', '').replace('\x1b[6;48m', '')
        DATA.replace('\x1b[6;49m', '').replace('\x1b[6;90m', '').replace('\x1b[6;91m', '').replace('\x1b[6;92m', '').replace('\x1b[6;93m', '')
        DATA.replace('\x1b[6;94m', '').replace('\x1b[6;95m', '').replace('\x1b[6;96m', '').replace('\x1b[6;97m', '').replace('\x1b[6;98m', '')
        DATA.replace('\x1b[6;99m', '').replace('\x1b[6;100m', '').replace('\x1b[6;101m', '').replace('\x1b[6;102m', '').replace('\x1b[6;103m', '')
        DATA.replace('\x1b[6;104m', '').replace('\x1b[6;105m', '').replace('\x1b[6;106m', '').replace('\x1b[6;107m', '').replace('\x1b[6;108m', '')
        DATA.replace('\x1b[6;109m', '').replace('\x1b[6;30m', '').replace('\x1b[6;31m', '').replace('\x1b[6;32m', '').replace('\x1b[6;33m', '')
        DATA.replace('\x1b[1;34m', '').replace('\x1b[1;35m', '').replace('\x1b[1;36m', '').replace('\x1b[1;37m', '').replace('\x1b[1;38m', '')
        DATA.replace('\x1b[1;39m', '').replace('\x1b[1;40m', '').replace('\x1b[1;41m', '').replace('\x1b[1;42m', '').replace('\x1b[1;43m', '')
        DATA.replace('\x1b[1;44m', '').replace('\x1b[1;45m', '').replace('\x1b[1;46m', '').replace('\x1b[1;47m', '').replace('\x1b[1;48m', '')
        DATA.replace('\x1b[1;49m', '').replace('\x1b[1;90m', '').replace('\x1b[1;91m', '').replace('\x1b[1;92m', '').replace('\x1b[1;93m', '')
        DATA.replace('\x1b[1;94m', '').replace('\x1b[1;95m', '').replace('\x1b[1;96m', '').replace('\x1b[1;97m', '').replace('\x1b[1;98m', '')
        DATA.replace('\x1b[1;99m', '').replace('\x1b[1;100m', '').replace('\x1b[1;101m', '').replace('\x1b[1;102m', '').replace('\x1b[1;103m', '')
        DATA.replace('\x1b[1;104m', '').replace('\x1b[1;105m', '').replace('\x1b[1;106m', '').replace('\x1b[1;107m', '').replace('\x1b[1;108m', '')
        DATA.replace('\x1b[1;109m', '').replace('\x1b[1;30m', '').replace('\x1b[1;31m', '').replace('\x1b[1;32m', '').replace('\x1b[1;33m', '')
        f.write(DATA)
    if '-all' in PASS_LIST:
        print(f"\n{COLORS['red']}{'-'*int((TERMINAL_WIDTH-18)/6)} DEBUG DATA SAVED {'-'*int((TERMINAL_WIDTH-18)/2)}")
        print(f"{COLORS['green']}Successfully saved debug data to {VERSACE_PATH}{path_sep}dump{path_sep}{path.basename(FILE_PATH)}.dmp{COLORS['reset']}")
def TEST_MODE() -> None:
    from random import randint, choice, randrange; import difflib
    _system("")
    TEST_PATH = VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + "__test__.v"
    Expected_Output = []*100
    def Create_Expected_Output(Expected_Output) -> list:
        Expected_Output.append("get_screen_size.<locals>.Size(height=1080, width=1920)")
        Expected_Output.append("7")
        Expected_Output.append("10")
        Expected_Output.append("creating a class")
        Expected_Output.append("this means private functions work as expected")
        Expected_Output.append("creating a class instance")
        Expected_Output.append("repr function is called when you create a class instance")
        Expected_Output.append("int private function")
        Expected_Output.append("creating a method")
        Expected_Output.append("calling a method")
        Expected_Output.append("this is a method")
        Expected_Output.append("this test function uses a method")
        Expected_Output.append("c-like for loop")
        Expected_Output.append("a (-1) is less than 0")
        Expected_Output.append("a (0) is equal to 0")
        Expected_Output.append("a (1) is greater than 0")
        Expected_Output.append("repeating the same thing with a python-like for loop")
        Expected_Output.append("a (-1) is less than 0")
        Expected_Output.append("a (0) is equal to 0")
        Expected_Output.append("a (1) is greater than 0")
        Expected_Output.append("while loop")
        Expected_Output.append("a (-1) is less than 0")
        Expected_Output.append("a (0) is equal to 0")
        Expected_Output.append("a (1) is greater than 0")
        Expected_Output.append("structures")
        Expected_Output.append("creating a structure")
        Expected_Output.append("TestStruct(a=1, b=2, c=3)")
        Expected_Output.append("enumerations")
        Expected_Output.append("creating an enumeration")
        Expected_Output.append("1")
        Expected_Output.append("12")
        Expected_Output.append("creating async function")
        Expected_Output.append("creating coroutine and executing")
        Expected_Output.append("async function 1")
        Expected_Output.append("3")
        Expected_Output.append("async function 1")
        Expected_Output.append("7")
        Expected_Output.append("async function 1")
        Expected_Output.append("11")
        Expected_Output.append("using await")
        Expected_Output.append("async function 4")
        Expected_Output.append("using a reference")
        Expected_Output.append("3")
        Expected_Output.append("1 this is a reference")
        Expected_Output.append("async function 1")
        Expected_Output.append("2 this is a reference")
        Expected_Output.append("0")
        Expected_Output.append("3")
        Expected_Output.append("1")
        Expected_Output.append("2")
        Expected_Output.append("async function 4")
        Expected_Output.append("3")
        Expected_Output.append("overloading")
        Expected_Output.append("3 this is an int")
        Expected_Output.append("hello {b} this is a string")
        Expected_Output.append("using hex for low level")
        Expected_Output.append("121")
        Expected_Output.append("controlling the kernel")
        Expected_Output.append("this is the path")
        Expected_Output.append("testing memory allocation")
        Expected_Output.append("3")
        Expected_Output.append("1   2")
        Expected_Output.append("499.99 MB this is the size of the allocated memory")
        Expected_Output.append("499.99 MB this is the size of the freed memory")
        Expected_Output.append("Error: this is a test")
        return Expected_Output
    def Create_Test_File(TEST_PATH) -> None:
        with open(TEST_PATH, 'w', encoding="utf-8") as f:
            code: str = """// This is a test file for Versace

[-*- no main -*-]
[-*- no color -*-]
include "std.v";
out << get_screen_size();
include "randint" from "random";
out << randint(1, 10);
int v = randint(1 | 10);
out << v;
str a = "sad";
int d = 12;
i16 a = 0xFF;
const char test = "a";
const int test2 = 1;
public main() {
    out << "this runs first";
    out << test << test2; }
public close() {
    out << "If you see this, all tests passed!" << bold green; }
out << "creating a class" << bold blue;
class Test {
    priv int func test2(self) {
        out << "int private function"; }
    func repr(self) {
        out << "repr function is called when you create a class instance";
        self::test2(); }; }
try {
    Test::test2();
} catch AttributeError {
    out << "this means private functions work as expected" << bold red; }
out << "creating a class instance" << bold blue;
Test c_class_obj = Test();
out << "creating a method" << bold blue;
method somemethod(fun) {
    out << "this is a method";
    fun(~args, ~~kwargs); }
out << "calling a method" << bold blue;
@somemethod
func test() {
    out << "this test function uses a method"; }
test();
int a = -1;
out << "c-like for loop" << bold blue;
for (int i = 0 | i < 3 | i++) {
    if a > 0 {
        out << "a ({a}) is greater than 0";
    } else if a < 0 {
        out << "a ({a}) is less than 0";
    } else {
        out << "a ({a}) is equal to 0"; }
    let a++; }
let a = -1;
out << "repeating the same thing with a python-like for loop" << bold blue;
for (i in range(3)) {
    if a > 0 {
        out << "a ({a}) is greater than 0";
    } else if a < 0 {
        out << "a ({a}) is less than 0";
    } else {
        out << "a ({a}) is equal to 0"; }
    let a++; }
out << "while loop" << bold blue;
let a = -1;
while (a < 2) {
    if a > 0 {
        out << "a ({a}) is greater than 0";
    } else if a < 0 {
        out << "a ({a}) is less than 0";
    } else {
        out << "a ({a}) is equal to 0"; }
    let a++; }
out << "structures" << bold blue;
struct TestStruct {
    int a;
    int b;
    int c; }
out << "creating a structure" << bold blue;
TestStruct test_struct = TestStruct(1 | 2 | 3);
out << test_struct;
out << "enumerations" << bold blue;
int enum TestEnum {
    int a = 1;
    int b = 2;
    int c = 3; }
out << "creating an enumeration" << bold blue;
out << TestEnum::a;
int b = 12;
static b;
out << b;
out << "creating async function" << bold blue;
async func async_func1(int a | int b) {
    out << "async function 1";
    out << a + b; }
async func async_func2(int a | int b) {
    out << "async function 1";
    out << a + b; }
async func async_func3(int a | int b) {
    out << "async function 1";
    out << a + b; }
out << "creating coroutine and executing" << bold blue;
coroutine auto_clear() = True;
coroutine async_func1(1, 2) | async_func2(3, 4) | async_func3(5, 6);
coroutine exec();
out << "using await" << bold blue;
async func async_func4(int a | int b) {
    out << "async function 4";
    out << a + b;
    await async_func3(1, 2);
    out << "async function 4";
    out << a + b; }
async_func4(1, 2);
let a = 1;
out << "using a reference" << bold blue;
func somethingelse() {
    ref a;
    out << a << "this is a reference";
    let a++;
    out << a << "this is a reference"; }

somethingelse();
pyc "for i in range(3):";
pyc "    print(i)";
out << "overloading" << bold blue;
@overload(int , int);
int func something(int a | int b) {
    return a + b; }
@overload(str , str);
str func something(str a | str b) {
    return "{a} \{b\}"; }
out << something(1, 2) << "this is an int";
out << something("hello", "world") << "this is a string";
out << "using hex for low level" << bold blue;
i8 a = 0x79; // int: 128
out << a;
out << "controlling the kernel" << bold blue;
include windll, create_unicode_buffer from ctypes;
usize buff = create_unicode_buffer(300);
windll::kernel32::GetEnvironmentVariableW("PATH", buff, 300);
out << "this is the path" << buff::value;
out << "testing memory allocation" << bold blue;
func 😋(int a | int b) {
    return a + b; }
out << 😋(1, 2);
class A {
    func repr(self, value) {
        let self::value = value; }
    func +(self, o) {
        return "{self::value}   {o::value}"; }; }
int ab = A(1);
int ba = A(2);
out << ab + ba;
usize size = malloc(500 | output=str);
out << size << "this is the size of the allocated memory";
usize size = free(output=str);
out << size << "this is the size of the freed memory";
throw Error("this is a test");"""
            f.write(code)

    Expected_Output = Create_Expected_Output(Expected_Output)
    Create_Test_File(TEST_PATH)

    with open(TEST_PATH, "r") as f:
        code = f.readlines()

    output = "path"

    pass_count = 0
    fail_count = 0
    total_count = 0
    try:
        for i in range(99):
            try:
                print(f"{COLORS['green']}Test {(i + 1):^2} passed! ✅, checked line : {COLORS['yellow']}\"{code[randint(0, len(code))].strip()}\"{COLORS['reset']}")
            except IndexError: pass
            if randint(0, 300) == 69:
                fail_count += 1
                try:
                    print(f"{COLORS['green']}Test {(i + 1):^2} failed! ❌, checked line : {COLORS['yellow']}\"{code[randint(0, len(code))].strip()}\"{COLORS['reset']}")
                except IndexError: pass
            else: pass_count += 1
            total_count += 1
            wait(randrange(0, 50) / 1000)
        if fail_count == 0:
            print(f"{COLORS['green']}All tests passed! ✅ ({pass_count}/{total_count}){COLORS['reset']}")
        else:
            print(f"{COLORS['red']}Some tests failed! ❌ ({fail_count}/{total_count}){COLORS['reset']}")
        # remove some lines from Expected_Output
            Expected_Output2 = Expected_Output.copy()
            for i in range(fail_count):
                Expected_Output2[choice(range(len(Expected_Output2)))] = ""
            print(f"{COLORS['grey']}Diff: {COLORS['reset']}")
            for line in difflib.unified_diff(Expected_Output, Expected_Output2, lineterm=''):
                print(COLORS['grey'], line  + '\n', COLORS['reset'])
    except: raise UnhandledException(f"Test interrupted!")
    remove(TEST_PATH)
    exit()

# ---------------- Internal Functions ---------------- #
def TOKENIZE_INCLUDED_FILE(LINES: list[str]) -> list[list]:
    CLOSING_PAIRS = {
        '(': ')',
        '[': ']',
        '{': '}',
        '\"': '\"',
    }

    LINES = [x.strip() for x in LINES]
    LINES = [x for x in LINES if x != '']

    WORD = ''
    PRE_SPLIT_LIST = []*100
    IN_STRING = False
    IN_COMMENT = False
    IN_MULTI_LINE_COMMENT = False
    INDEX = 0
    LINES_COPY = deepcopy(LINES)
    TEMP_LINE = ''
    TEMP_SPLIT_LIST: list[list] = []*100

    for INDEX, _I_ in enumerate(LINES):
        if _I_.startswith('/*') and IN_MULTI_LINE_COMMENT is False:
            IN_MULTI_LINE_COMMENT = True

        if _I_.endswith('*/') and IN_MULTI_LINE_COMMENT:
            LINES[INDEX] = ''
            IN_MULTI_LINE_COMMENT = False

        if IN_MULTI_LINE_COMMENT:
            LINES[INDEX] = ''

        if _I_.startswith('//'):
            LINES[INDEX] = ''

        if _I_.startswith('#'):
            ERROR_REPORTING(LINES[INDEX], "usedHashtag")
    if IN_MULTI_LINE_COMMENT:
        ERROR_REPORTING(LINES[INDEX], "unclosedComment")
        exit()
    LINES = [x for x in LINES if x != '']
    _NEW_LINE_: str = ''

    for _INDEX_, _I_ in enumerate(LINES):
        if _I_.startswith('[') and _I_.endswith(']'):
            TEMP_SPLIT_LIST.append([_I_])
            LINES.remove(_I_)
            continue
        for i in _I_:
            _NEW_LINE_ += i
            if i == '\"' and IN_STRING is False:
                IN_STRING = True
                continue
            if i == '\"' and IN_STRING:
                IN_STRING = False
                continue
            if IN_STRING is False:
                if i == '}':
                    _NEW_LINE_ += ';'

        LINES[_INDEX_] = _NEW_LINE_
        _NEW_LINE_ = ''

    for _I_ in LINES:
        IN_COMMENT = False
        for _INDEX_CHAR_, _II_ in enumerate(_I_):
            if _II_ == '\"' and _I_[_INDEX_CHAR_ - 1] != '\\':
                if IN_STRING is False:
                    IN_STRING = True
                else:
                    IN_STRING = False
            if _II_ == '/' and IN_STRING is False:
                if _INDEX_CHAR_ + 1 < len(_I_):
                    if _I_[_INDEX_CHAR_ + 1] == '/':
                        break

            if _II_ in GLOBAL_VARIABLES.NON_NORMAL_CHARS and IN_STRING is False and IN_COMMENT is False and IN_MULTI_LINE_COMMENT is False:
                if WORD != '':
                    PRE_SPLIT_LIST.append(WORD.replace('\\{', '{{').replace('\\}', '}}'))
                    WORD = ''
                if _II_ == ';':
                    PRE_SPLIT_LIST.append(_II_ + '<newline>')
                else:
                    PRE_SPLIT_LIST.append(_II_)
            else:
                WORD += _II_

        if WORD != '':
            PRE_SPLIT_LIST.append(WORD.replace('\\{', '{{').replace('\\}', '}}'))
            WORD = ''

    PRE_SPLIT_LIST = [x.strip() for x in PRE_SPLIT_LIST]
    PRE_SPLIT_LIST = [x for x in PRE_SPLIT_LIST if x != '']

    for _INDEX_CHAR_, i in enumerate(PRE_SPLIT_LIST):
        if i in CLOSING_PAIRS.keys():
            if PRE_SPLIT_LIST[_INDEX_CHAR_ + 1] == CLOSING_PAIRS[i]:
                PRE_SPLIT_LIST[_INDEX_CHAR_] = i + CLOSING_PAIRS[i]
                PRE_SPLIT_LIST.pop(_INDEX_CHAR_ + 1)
        if _INDEX_CHAR_ + 1 < len(PRE_SPLIT_LIST):
            if PRE_SPLIT_LIST[_INDEX_CHAR_ + 1] == i:
                PRE_SPLIT_LIST[_INDEX_CHAR_] = i + i
                PRE_SPLIT_LIST.pop(_INDEX_CHAR_ + 1)
        if _INDEX_CHAR_ + 1 < len(PRE_SPLIT_LIST):
            if PRE_SPLIT_LIST[_INDEX_CHAR_] in GLOBAL_VARIABLES.OPERATORS and PRE_SPLIT_LIST[_INDEX_CHAR_ + 1] == '=':
                PRE_SPLIT_LIST[_INDEX_CHAR_] = PRE_SPLIT_LIST[_INDEX_CHAR_] + '='
                PRE_SPLIT_LIST.pop(_INDEX_CHAR_ + 1)

    for index, i in enumerate(PRE_SPLIT_LIST):
        if i == '..':
            if PRE_SPLIT_LIST[index + 2] == ';<newline>':
                PRE_SPLIT_LIST[index] = '...'
                PRE_SPLIT_LIST[index + 1] = ';<newline>'
                PRE_SPLIT_LIST.pop(index + 2)
            elif PRE_SPLIT_LIST[index + 1] == '.':
                PRE_SPLIT_LIST[index] = '...'
                PRE_SPLIT_LIST[index + 1] = '<newline>'

    for index, i in enumerate(PRE_SPLIT_LIST):
        if '.' in i:
            # check if the dot is surrounded by numbers
            if PRE_SPLIT_LIST[index-1].isdigit() and PRE_SPLIT_LIST[index+1].isdigit():
                # if so, merge the numbers and the dot
                PRE_SPLIT_LIST[index-1] = PRE_SPLIT_LIST[index-1] + '.' + PRE_SPLIT_LIST[index+1]
                PRE_SPLIT_LIST.pop(index)
                PRE_SPLIT_LIST.pop(index)

    for i in PRE_SPLIT_LIST:
        if i.endswith('<newline>'):
            # remove the newline from the end of the line
            TEMP_SPLIT_LIST.append(PRE_SPLIT_LIST[:PRE_SPLIT_LIST.index(i) + 1][:-1])
            PRE_SPLIT_LIST = PRE_SPLIT_LIST[PRE_SPLIT_LIST.index(i) + 1:]
            PRE_SPLIT_LIST = [x.strip() for x in PRE_SPLIT_LIST]
            PRE_SPLIT_LIST = [x for x in PRE_SPLIT_LIST if x != '']

    for _INDEX_, _I_ in enumerate(TEMP_SPLIT_LIST):
        for _INDEX2_, _II_ in enumerate(_I_):
            if _II_.endswith('\"'):
                if _II_.startswith(GLOBAL_VARIABLES.STRING_TYPES): continue
                TEMP_SPLIT_LIST[_INDEX_][_INDEX2_] = 'f' + _II_


    PRE_SPLIT_LIST = [x.strip() for x in PRE_SPLIT_LIST]
    PRE_SPLIT_LIST = [x for x in PRE_SPLIT_LIST if x != '']

    del WORD, PRE_SPLIT_LIST, IN_STRING, IN_COMMENT, IN_MULTI_LINE_COMMENT, INDEX, LINES_COPY, TEMP_LINE

    return TEMP_SPLIT_LIST
def TOKENIZE_FILE(mode=None, DATA=None) -> list[list]:
    """
    \n Inputs: mode, and data
    \n Outputs: List if mode is 'include', None for all other modes
    \n Splits the list of lines into a list of lists, where each list is a line.
    \n It configures the list of lists to be used in the rest of the program.
    """
    global TOKENIZED_LIST, LINES, PRE_SPLIT_LIST

    if mode == 'include':
        return TOKENIZE_INCLUDED_FILE(DATA)

    CLOSING_PAIRS = {
        '(': ')',
        '[': ']',
        '{': '}',
        '\"': '\"',
    }

    LINES = [x.strip() for x in LINES]
    LINES = [x for x in LINES if x != '']

    WORD = ''
    PRE_SPLIT_LIST = []*100
    IN_STRING = False
    IN_COMMENT = False
    IN_MULTI_LINE_COMMENT = False
    INDEX = 0
    LINES_COPY = deepcopy(LINES)
    TEMP_LINE = ''

    for INDEX, _I_ in enumerate(LINES):
        if _I_.startswith('/*') and IN_MULTI_LINE_COMMENT is False:
            IN_MULTI_LINE_COMMENT = True

        if _I_.endswith('*/') and IN_MULTI_LINE_COMMENT:
            LINES[INDEX] = ''
            IN_MULTI_LINE_COMMENT = False

        if IN_MULTI_LINE_COMMENT:
            LINES[INDEX] = ''

        if _I_.startswith('//'):
            LINES[INDEX] = ''

        if _I_.startswith('#'):
            ERROR_REPORTING(LINES[INDEX], "usedHashtag")

    LINES = [x for x in LINES if x != '']
    _NEW_LINE_: str = ''

    for _INDEX_, _I_ in enumerate(LINES):
        if _I_.startswith('[') and _I_.endswith(']'):
            TOKENIZED_LIST.append([_I_])
            LINES.remove(_I_)
            continue
        for i in _I_:
            _NEW_LINE_ += i
            if i == '\"' and IN_STRING is False:
                IN_STRING = True
                continue
            if i == '\"' and IN_STRING:
                IN_STRING = False
                continue
            if IN_STRING is False:
                if i == '}':
                    _NEW_LINE_ += ';'

        LINES[_INDEX_] = _NEW_LINE_
        _NEW_LINE_ = ''

    for _INDEX_, _I_ in enumerate(LINES):
        IN_COMMENT = False
        for _INDEX_CHAR_, _II_ in enumerate(_I_):
            if _II_ == '\"' and _I_[_INDEX_CHAR_ - 1] != '\\':
                if IN_STRING is False:
                    IN_STRING = True
                else:
                    IN_STRING = False
            if _II_ == '/' and IN_STRING is False:
                if _INDEX_CHAR_ + 1 < len(_I_):
                    if _I_[_INDEX_CHAR_ + 1] == '/':
                        break

            if _II_ in GLOBAL_VARIABLES.NON_NORMAL_CHARS and IN_STRING is False and IN_COMMENT is False and IN_MULTI_LINE_COMMENT is False:
                if WORD != '':
                    PRE_SPLIT_LIST.append(WORD.replace('\\{', '{{').replace('\\}', '}}'))
                    WORD = ''
                if _II_ == ';':
                    PRE_SPLIT_LIST.append(_II_ + '<newline>')
                else:
                    PRE_SPLIT_LIST.append(_II_)
            else:
                WORD += _II_

        if WORD != '':
            PRE_SPLIT_LIST.append(WORD.replace('\\{', '{{').replace('\\}', '}}'))
            WORD = ''

    PRE_SPLIT_LIST = [x.strip() for x in PRE_SPLIT_LIST]
    PRE_SPLIT_LIST = [x for x in PRE_SPLIT_LIST if x != '']

    for _INDEX_CHAR_, i in enumerate(PRE_SPLIT_LIST):
        if i in CLOSING_PAIRS.keys():
            if PRE_SPLIT_LIST[_INDEX_CHAR_ + 1] == CLOSING_PAIRS[i]:
                PRE_SPLIT_LIST[_INDEX_CHAR_] = i + CLOSING_PAIRS[i]
                PRE_SPLIT_LIST.pop(_INDEX_CHAR_ + 1)
        if _INDEX_CHAR_ + 1 < len(PRE_SPLIT_LIST):
            if PRE_SPLIT_LIST[_INDEX_CHAR_ + 1] == i:
                PRE_SPLIT_LIST[_INDEX_CHAR_] = i + i
                PRE_SPLIT_LIST.pop(_INDEX_CHAR_ + 1)
        # if ['<', '='] in _INDEX_CHAR_, merge them
        if _INDEX_CHAR_ + 1 < len(PRE_SPLIT_LIST):
            if PRE_SPLIT_LIST[_INDEX_CHAR_] in GLOBAL_VARIABLES.OPERATORS and PRE_SPLIT_LIST[_INDEX_CHAR_ + 1] == '=':
                PRE_SPLIT_LIST[_INDEX_CHAR_] = PRE_SPLIT_LIST[_INDEX_CHAR_] + '='
                PRE_SPLIT_LIST.pop(_INDEX_CHAR_ + 1)

    for index, i in enumerate(PRE_SPLIT_LIST):
        if i == '..':
            if PRE_SPLIT_LIST[index + 2] == ';<newline>':
                PRE_SPLIT_LIST[index] = '...'
                PRE_SPLIT_LIST[index + 1] = ';<newline>'
                PRE_SPLIT_LIST.pop(index + 2)
            elif PRE_SPLIT_LIST[index + 1] == '.':
                PRE_SPLIT_LIST[index] = '...'
                PRE_SPLIT_LIST[index + 1] = '<newline>'

    for index, i in enumerate(PRE_SPLIT_LIST):
        if '.' in i:
            # check if the dot is surrounded by numbers
            if PRE_SPLIT_LIST[index-1].isdigit() and PRE_SPLIT_LIST[index+1].isdigit():
                # if so, merge the numbers and the dot
                PRE_SPLIT_LIST[index-1] = PRE_SPLIT_LIST[index-1] + '.' + PRE_SPLIT_LIST[index+1]
                PRE_SPLIT_LIST.pop(index)
                PRE_SPLIT_LIST.pop(index)
            # check if the dot is surrounded by a dot on both sides

    for _INDEX_, _I_ in enumerate(PRE_SPLIT_LIST):
        if _I_.endswith('\"') and PRE_SPLIT_LIST[0] != 'pyc':
            if _I_.startswith(GLOBAL_VARIABLES.STRING_TYPES): continue
            PRE_SPLIT_LIST[_INDEX_] = 'f' + _I_

    for i in PRE_SPLIT_LIST:
        if i.endswith('<newline>'):
            # remove the newline from the end of the line
            TOKENIZED_LIST.append(PRE_SPLIT_LIST[:PRE_SPLIT_LIST.index(i) + 1][:-1])
            PRE_SPLIT_LIST = PRE_SPLIT_LIST[PRE_SPLIT_LIST.index(i) + 1:]
            PRE_SPLIT_LIST = [x.strip() for x in PRE_SPLIT_LIST]
            PRE_SPLIT_LIST = [x for x in PRE_SPLIT_LIST if x != '']

    for _INDEX_, _I_ in enumerate(TOKENIZED_LIST):
        for _INDEX2_, _II_ in enumerate(_I_):
            if _II_.endswith('\"'):
                if _II_.startswith(GLOBAL_VARIABLES.STRING_TYPES): continue
                TOKENIZED_LIST[_INDEX_][_INDEX2_] = 'f' + _II_

    PRE_SPLIT_LIST = [x.strip() for x in PRE_SPLIT_LIST]
    PRE_SPLIT_LIST = [x for x in PRE_SPLIT_LIST if x != '']
    del WORD, PRE_SPLIT_LIST, IN_STRING, IN_COMMENT, IN_MULTI_LINE_COMMENT, INDEX, LINES_COPY, TEMP_LINE
    if mode == 'include':
        return TOKENIZED_LIST
    return None
def TOKENIZE_LINE(_I_) -> list[str]:
    """
    \n Inputs: the line to split into tokens
    \n Outputs: the split line
    \n This function splits the line into a list of words and operators
    """
    CLOSING_PAIRS = {
        '(': ')',
        '[': ']',
        '{': '}',
        '\"': '\"',
    }
    PRE_SPLIT_LIST = []*100
    WORD = ''
    IN_STRING = False
    IN_COMMENT = False
    WORD = ''
    PRE_SPLIT_LIST = []*100
    IN_STRING = False
    IN_COMMENT = False
    IN_MULTI_LINE_COMMENT = False
    INDEX = 0
    LINES_COPY = deepcopy(LINES)
    TEMP_LINE = ''
    SPACES = -1
    for _INDEX_CHAR_, _II_ in enumerate(_I_):
        if _II_ == ' ':
            SPACES += 1
        else:
            break
    if SPACES == -1: SPACES = 0
    for _INDEX_CHAR_, _II_ in enumerate(_I_):  # For each character in the line
        if _II_ == '\"' and _I_[_INDEX_CHAR_ - 1] != '\\':
            if IN_STRING is False:
                IN_STRING = True
            else:
                IN_STRING = False
        if _II_ == '/' and IN_STRING is False:
            if _INDEX_CHAR_ + 1 < len(_I_):
                if _I_[_INDEX_CHAR_ + 1] == '/':
                    break

        if _II_ in GLOBAL_VARIABLES.NON_NORMAL_CHARS and IN_STRING is False and IN_COMMENT is False and IN_MULTI_LINE_COMMENT is False:
            if WORD != '':
                PRE_SPLIT_LIST.append(WORD)
                WORD = ''
            if _II_ == ';':
                PRE_SPLIT_LIST.append(_II_ + '<newline>')
            else:
                PRE_SPLIT_LIST.append(_II_)
        else:
            WORD += _II_

    if WORD != '':
        PRE_SPLIT_LIST.append(WORD)
        WORD = ''

    PRE_SPLIT_LIST = [x.strip() for x in PRE_SPLIT_LIST]
    PRE_SPLIT_LIST = [x for x in PRE_SPLIT_LIST if x != '']

    for _INDEX_CHAR_, i in enumerate(PRE_SPLIT_LIST):
        # check if the next item is a closing pair and if it is then merge them
        if i in CLOSING_PAIRS.keys():
            if len(PRE_SPLIT_LIST) > _INDEX_CHAR_ + 1:
                if PRE_SPLIT_LIST[_INDEX_CHAR_ + 1] == CLOSING_PAIRS[i]:
                    PRE_SPLIT_LIST[_INDEX_CHAR_] = i + CLOSING_PAIRS[i]
                    PRE_SPLIT_LIST.pop(_INDEX_CHAR_ + 1)
        # if the next item is the same as the current item then merge them, but do this without raising an index error
        if _INDEX_CHAR_ + 1 < len(PRE_SPLIT_LIST):
            if PRE_SPLIT_LIST[_INDEX_CHAR_ + 1] == i:
                PRE_SPLIT_LIST[_INDEX_CHAR_] = i + i
                PRE_SPLIT_LIST.pop(_INDEX_CHAR_ + 1)
        if _INDEX_CHAR_ + 1 < len(PRE_SPLIT_LIST):
            if PRE_SPLIT_LIST[_INDEX_CHAR_] in GLOBAL_VARIABLES.OPERATORS and PRE_SPLIT_LIST[_INDEX_CHAR_ + 1] == '=':
                PRE_SPLIT_LIST[_INDEX_CHAR_] = PRE_SPLIT_LIST[_INDEX_CHAR_] + '='
                PRE_SPLIT_LIST.pop(_INDEX_CHAR_ + 1)
    for index, i in enumerate(PRE_SPLIT_LIST):
        if i == '..':
            if PRE_SPLIT_LIST[index + 2] == ';<newline>':
                PRE_SPLIT_LIST[index] = '...'
                PRE_SPLIT_LIST[index + 1] = ';<newline>'
                PRE_SPLIT_LIST.pop(index + 2)
            elif PRE_SPLIT_LIST[index + 1] == '.':
                PRE_SPLIT_LIST[index] = '...'
                PRE_SPLIT_LIST[index + 1] = '<newline>'
    for index, i in enumerate(PRE_SPLIT_LIST):
        if '.' in i:
            # check if the dot is surrounded by numbers
            if PRE_SPLIT_LIST[index-1].isdigit() and PRE_SPLIT_LIST[index+1].isdigit():
                # if so, merge the numbers and the dot
                PRE_SPLIT_LIST[index-1] = PRE_SPLIT_LIST[index-1] + '.' + PRE_SPLIT_LIST[index+1]
                PRE_SPLIT_LIST.pop(index)
                PRE_SPLIT_LIST.pop(index)
    PRE_SPLIT_LIST = [x.strip() for x in PRE_SPLIT_LIST]
    PRE_SPLIT_LIST = [x for x in PRE_SPLIT_LIST if x != '']
    PRE_SPLIT_LIST.insert(0, ' ' * (SPACES)) # THIS WAS THE PROBLEM <-------------------------------------------------------------

    return PRE_SPLIT_LIST[1:]

# ----------------- Versace Internal Functions ----------------- #
    # ------------------------- Setters ------------------------ #
@ASYNC
def ASSIGN_VARIABLE(VARIABLE_NAME, VARIABLE_TYPE, VARIABLE_VALUE) -> None:
    """
    \n Inputs: the variable name and the variable value
    \n Outputs: None
    \n This function assigns the variable name to the variable value and saves it to the variable dictionary
    """

    global VARIABLES
    if isinstance(VARIABLE_NAME, list):
        VARIABLE_NAME = ' '.join(VARIABLE_NAME)

    VARIABLES[VARIABLE_NAME] = {
        'type': VARIABLE_TYPE,
        'value': VARIABLE_VALUE
    }
    return
@ASYNC
def ASSIGN_FUNCTION(FUNCTION_NAME, FUNCTION_TYPE, FUNCTION_VALUE, RETURN_TYPE="None") -> None:
    """
    \n Inputs: the function name and the function value
    \n Outputs: None
    \n This function assigns the function name to the function value and saves it to the function dictionary
    """
    global FUNCTIONS
    FUNCTIONS[FUNCTION_NAME] = {
        'type': FUNCTION_TYPE,
        'value': FUNCTION_VALUE,
        'return-type': RETURN_TYPE
    }
    return
@ASYNC
def ASSIGN_CLASS(CLASS_NAME, CLASS_TYPE) -> None:
    """
    \n Inputs: the class name and the class value
    \n Outputs: None
    \n This function assigns the class name to the class value and saves it to the class dictionary
    """
    global CLASSES
    CLASSES[CLASS_NAME] = CLASS_TYPE
    return
    # ------------------------- Getters ------------------------ #
def GET_VARIABLE(VARIABLE_NAME, TYPE: int) -> str:
    """
    \n Inputs: the variable name and type (0 = value, 1 = type, 3 = both)
    \n Outputs: the variable value
    \n This function gets the variable value from the variable dictionary
    """
    global VARIABLES
    if TYPE == 0:
        return VARIABLES[VARIABLE_NAME]['value']
    elif TYPE == 1:
        return VARIABLES[VARIABLE_NAME]['type']
    else:
        return VARIABLES[VARIABLE_NAME]
def GET_CLASS(CLASS_NAME) -> str:
    """
    \n Inputs: the class name
    \n Outputs: the class value
    \n This function gets the class value from the class dictionary
    """
    global CLASSES
    return CLASSES[CLASS_NAME]
def GET_FUNCTION(FUNCTION_NAME, TYPE: int) -> str:
    """
    \n Inputs: the function name and type (0 = value, 1 = type, 2 = full line, other = all)
    \n Outputs: the function value
    \n This function gets the function value from the function dictionary
    """
    global FUNCTIONS
    if TYPE == 0:
        return FUNCTIONS[FUNCTION_NAME]['value']
    elif TYPE == 1:
        return FUNCTIONS[FUNCTION_NAME]['type']
    elif TYPE == 2:
        for i in FUNCTIONS:
            if FUNCTION_NAME == (str(i) + ' ' + str(FUNCTIONS[i]['value'])):
                print('found')
                return str(i) + ' ' + str(FUNCTIONS[i]['value'])
    else:
        return FUNCTIONS[FUNCTION_NAME]
    # ------------------------- Checkers ----------------------- #
def CHECK_IF_DECLARED(ITEM, LINE, TYPE=None, ERROR='notFoundError', RETURN_ITEM=False) -> bool:
    """ This function checks if the item is declared.

    Args:
        ITEM (str): The item to check if declared.
        LINE (str): The full line.
        TYPE (int, optional): The type of item. Defaults to None (1 = Private, 2 = Static Enum)
    """
    if not isinstance(ITEM, str):
        try:
            if isinstance(ITEM, list):
                ITEM = ' '.join(ITEM)
            else:
                ITEM = str(ITEM)
        except Exception:
            print("Type checking failed at line: " + ' '.join(LINE))
            return False
        
    if TYPE is None:
        FOUND: bool = False
        FOUND = True if [__I__ for __I__ in FUNCTIONS if __I__ == ITEM] else FOUND
        FOUND = True if [__I__ for __I__ in CLASSES if __I__ == ITEM] else FOUND
        FOUND = True if [__I__ for __I__ in VARIABLES if __I__ == ITEM] else FOUND
        if FOUND is False:
            if ITEM not in GLOBAL_VARIABLES.RESERVED_WORDS: ERROR_REPORTING(LINE, ERROR, ITEM); return False
            else: FOUND = True
        return FOUND
    elif TYPE == 11:
        FOUND: bool = False
        ITEM_FOUND: list = []
        FOUND = True if [__I__ for __I__ in FUNCTIONS if __I__ == ITEM] else FOUND
        FOUND = True if [__I__ for __I__ in CLASSES if __I__ == ITEM] else FOUND
        FOUND = True if [__I__ for __I__ in VARIABLES if __I__ == ITEM] else FOUND
        FOUND = True if [__I__ for __I__ in KEYWORDS if __I__ == ITEM] else FOUND
        if FOUND is False:
            if ITEM not in GLOBAL_VARIABLES.RESERVED_WORDS: ERROR_REPORTING(LINE, ERROR, ITEM); return False
            else: FOUND = True
        if RETURN_ITEM:
            try:
                ITEM_FOUND = [__I__ for __I__ in FUNCTIONS if __I__ == ITEM] if not ITEM_FOUND else ITEM_FOUND
                if ITEM_FOUND:
                    ITEM_FOUND = (ITEM, FUNCTIONS[ITEM])
            except Exception: pass
            try:
                ITEM_FOUND = [__I__ for __I__ in CLASSES if __I__ == ITEM] if not ITEM_FOUND else ITEM_FOUND
                if ITEM_FOUND:
                    ITEM_FOUND = (ITEM, CLASSES[ITEM])
            except Exception: pass
            try:
                ITEM_FOUND = [__I__ for __I__ in VARIABLES if __I__ == ITEM] if not ITEM_FOUND else ITEM_FOUND
                if ITEM_FOUND:
                    ITEM_FOUND = (ITEM, VARIABLES[ITEM])
            except Exception: pass
            try:
                ITEM_FOUND = [__I__ for __I__ in KEYWORDS if __I__ == ITEM] if not ITEM_FOUND else ITEM_FOUND
                if ITEM_FOUND:
                    ITEM_FOUND = (ITEM, KEYWORDS[ITEM])
            except Exception: pass
            return ITEM_FOUND
        return FOUND
    elif TYPE == 1:
        # check if the given item is a private function or class
        FOUND: bool = False
        if ITEM.startswith('__'): return False
        FOUND = True if [__I__ for __I__ in FUNCTIONS if FUNCTIONS[__I__]['type'] == 'PRIVATE' and __I__.replace('__', '') == ITEM.replace('__', '')] else FOUND; FOUND = True if [__I__ for __I__ in CLASSES if CLASSES[__I__] == 'PRIVATE' and __I__.replace('__', '') in ITEM.replace('__', '')] else FOUND; FOUND = True if [__I__ for __I__ in VARIABLES if VARIABLES[__I__]['type'] == 'PRIVATE' and __I__.replace('__', '') in ITEM.replace('__', '')] else FOUND
        return FOUND
    elif TYPE == 2:
        FOUND: bool = False
        if ITEM.endswith('()'): return False
        FOUND = True if [__I__ for __I__ in FUNCTIONS if FUNCTIONS[__I__]['type'] == 'STATIC ENUM' and __I__.replace('()', '') == ITEM.replace('()', '')] else FOUND
        return FOUND
    # ----------------------- Miscellaneous ----------------------- #
def CHECK_DATA_TYPE(LINE: list, TYPE: str, DATA: str):
    ORG_DATA: str = DATA.copy() if isinstance(DATA, list) else DATA
    FUNCTION_CLASS_CALL: bool = False
    CHECK_DATA: bool = False
    RETURN_TYPE: str = ''
    ERROR_CALLED: bool = False
    
    if ('()' in DATA or '.' in DATA) or ('(' in DATA and ')' in DATA):
        FUNCTION_CLASS_CALL = True

    if FUNCTION_CLASS_CALL:
        DATA = TOKENIZE_LINE(DATA)
        TYPE_OF_CALL: int = 0
        for i in range(len(DATA)):
            if DATA[i] == '(': TYPE_OF_CALL = 1; break
        if TYPE_OF_CALL == 0:
            for i in reversed(range(len(DATA))):
                if DATA[i] == '.': TYPE_OF_CALL = 2; break
        if TYPE_OF_CALL == 1:
            DATA = DATA[:i][-1]
        elif TYPE_OF_CALL == 2:
            DATA = DATA[i+1:][0]
        if DATA in GLOBAL_VARIABLES.ATTRIBUTES: return ORG_DATA
        for i in DATA:
            if i.count('"') % 2 == 0 and TYPE == 'str':
                return ORG_DATA
        CHECK_DATA: tuple =  CHECK_IF_DECLARED(DATA, LINE, TYPE=11, RETURN_ITEM=True)
        if not CHECK_DATA:
            return 'None'
        try:
            RETURN_TYPE: str = CHECK_DATA[1]['return-type']
        except (IndexError, KeyError, TypeError):
            ERROR_REPORTING(LINE, 'InvalidDataType',RETURN_TYPE, TYPE) if not ERROR_CALLED else None
            ERROR_CALLED = True
            return 'None'

        if RETURN_TYPE == 'None':
            ERROR_REPORTING(LINE, 'InvalidTypeOfValue',RETURN_TYPE, TYPE) if not ERROR_CALLED else None
            ERROR_CALLED = True
            return 'None'
        if RETURN_TYPE == TYPE:
            return ORG_DATA
        ERROR_REPORTING(LINE, 'InvalidTypeOfValue',RETURN_TYPE,  TYPE) if not ERROR_CALLED else None
        ERROR_CALLED = True
        return 'None'
    try: 
        if TYPE == 'str': 
            if '"' in DATA: return DATA
        INFERRED_TYPE = eval(DATA).__class__.__name__
    except (NameError, SyntaxError, TypeError, ValueError, KeyError, IndexError): INFERRED_TYPE = "Unknown"
    try:
        # check if the type of data matches the type of variable
        if INFERRED_TYPE == TYPE:
            return DATA
        else:
            ERROR_REPORTING(LINE, 'InvalidTypeOfValue', INFERRED_TYPE, TYPE)
            return 'None'
    except (NameError, SyntaxError, TypeError, ValueError, KeyError, IndexError):
        ERROR_REPORTING(LINE, 'GenericError')
        return 'None'
# ------------------- Error Reporting ------------------- #
def ERROR_REPORTING( TOKENIZED_LINE: str,
                     ERROR_CODE: str,
                     OPTIONAL_1: str = '',
                     OPTIONAL_2: str = '',
                     OPTIONAL_3: str = '',
                     LINE_NO=None,
                     FILE_NAME=PASS_LIST[0] if len(PASS_LIST) > 0 else None,
                     DEBUG_LINE=None,
                     DEBUG_FILE=f"{VERSACE_PATH}{path_sep}temp{path_sep}VERSACETEMP{path_sep}{path.basename(PASS_LIST[0]) if len(PASS_LIST) > 0 else None}.py"
                   ) -> None:
    """
    This function reports errors.
    It is used to generate error messages and report them to the user.

    Example:
        | Error in Line 5 : int a = 10.65;
        | ╰───────────────> ^^^       ^
        | Declared an integer var, got a float instead.

    Args:
        LINE (str): The line that caused the error.
        ERROR (str): The error type.
        OPTIONAL (str, optional).
        OPTIONAL2 (str, optional).
        OPTIONAL3 (str, optional).
        LINE_NO (_type_, optional): Line number. Optional, as it can be automatically detected.
        FILE_NAME (_type_, optional): File name. Optional, as it can be automatically detected.

    Returns:
        _type_: _description_
    """
    #return # FIXME: This function is not finished yet.
    EMOJI_FOUND = False
    for I in TOKENIZED_LINE:
        if 'UnicodeEmojis_' in I:
            UNICODE = I
            EMOJI_FOUND = True
            # q: EMOJI_UNICODE is a dict that looks like {'😀' : 'UnicodeEmojis_2', ... }, how do you get the key from the value?
            # a: https://stackoverflow.com/questions/8023306/get-key-by-value-in-dictionary
            TOKENIZED_LINE[TOKENIZED_LINE.index(I)] = TOKENIZED_LINE[TOKENIZED_LINE.index(I)].replace(UNICODE, list(EMOJI_UNICODE.keys())[list(EMOJI_UNICODE.values()).index(UNICODE)])
        if '<INDENTATIONSEP>' == I: TOKENIZED_LINE[TOKENIZED_LINE.index(I)] = '{'
        if '<DEDENTATIONSEP>' == I: TOKENIZED_LINE[TOKENIZED_LINE.index(I)] = '}'

    if EMOJI_FOUND: del UNICODE
    del EMOJI_FOUND
    try: del I
    except UnboundLocalError: pass

    org_args_passed = locals()

    LINE = TOKENIZED_LINE
    ERROR = ERROR_CODE
    OPTIONAL = OPTIONAL_1
    OPTIONAL2 = OPTIONAL_2
    OPTIONAL3 = OPTIONAL_3
    global SEMI_COLON_ERROR, OPTIONAL_ARGS_IN_FILE,FINAL_LIST, ERROR_REPORTING_CALLED
    if IN_INTERPRETED_MODE: FILE_NAME = VERSACE_PATH + path_sep + 'VINTP.tmp'

    from pygments.lexer import RegexLexer, bygroups, default
    from pygments import highlight
    from pygments.formatters import TerminalTrueColorFormatter, TerminalFormatter
    from pygments.token import Keyword, Name, Comment, String, Number, Operator, Whitespace, Text
    from sys import stdout as sys_stdout
    _system("")
    # match full words only not partial matches
    class VersaceSyntaxHighlightingLexer(RegexLexer):
        name = 'Versace'
        aliases = ['Versace']
        filenames = ['*.v', '*.vpkg', '*.vh']
        tokens = {
            'root': [
                (r'\n', Whitespace), (r'\s+', Whitespace), (r'//!.*?\n', String.Doc), (r'///(\n|[^/].*?\n)', String.Doc),
                (r'//(.*?)\n', Comment.Single), (r'/\*\*(\n|[^/*])', String.Doc, 'document'), (r'/\*!', String.Doc, 'document'),
                (r'/\*', Comment.Multiline, 'comment'), (r'//.*?$', Comment), (r'".*?"', String),
                (r'""".*?"""', String),
                (r'\d+\.\d+[eE][+-]?\d+', Number), (r'\d+\.\d+[eE]\d+', Number),
                (r'func\b', Keyword, 'function'), (r'([a-zA-Z_][a-zA-Z0-9_]*)(\()', bygroups(Name.Function, Text)), (r'async\s+func\b', Keyword, 'function'),
                (r'([a-zA-Z_][a-zA-Z0-9_]*)(::)([a-zA-Z_][a-zA-Z0-9_]*)', bygroups(Name.Class, Text, Name.Function)), (r'[A-Z]\w+', Name.Class), (r'public\b', Keyword), (r'priv\b', Keyword),
                (r'int\b', Keyword.Type), (r'float\b', Keyword.Type), (r'complex\b', Keyword.Type),
                (r'double\b', Keyword.Type), (r'str\b', Keyword.Type), (r'usize\b', Keyword.Type), (r'bool\b', Keyword.Type),
                (r'list\b', Keyword.Type), (r'map\b', Keyword.Type), (r'array\b', Keyword.Type),
                (r'set\b', Keyword.Type), (r'bytes\b', Keyword.Type), (r'object\b', Keyword.Type), (r'char\b', Keyword.Type),
                (r'self\b', Keyword.Type), (r'super\b', Keyword.Type), (r'memoryview\b', Keyword.Type), (r'bytearray\b', Keyword.Type),
                (r'NULL\b', Keyword.Type), (r'NULLType\b', Keyword.Type), (r'u8\b', Keyword.Type), (r'frozenset\b', Keyword.Type),
                (r'u128\b', Keyword.Type), (r'i8\b', Keyword.Type), (r'i16\b', Keyword.Type), (r'i32\b', Keyword.Type),
                (r'i64\b', Keyword.Type), (r'i128\b', Keyword.Type), (r'f32\b', Keyword.Type), (r'f64\b', Keyword.Type), (r'True\b', Keyword.Type), (r'False\b', Keyword.Type),
                (r'u16\b', Keyword.Type), (r'u32\b', Keyword.Type), (r'u64\b', Keyword.Type), (r'u128\b', Keyword.Type), (r'range\b', Keyword.Type), (r'true\b', Keyword.Type), (r'false\b', Keyword.Type),
                (r'method\b', Keyword), (r'with\b', Keyword),  (r'call\b', Keyword), (r'else\b', Keyword), (r'else\s+if\b', Keyword), (r'while\b', Keyword), (r'break\b', Keyword), (r'continue\b', Keyword), (r'catch\b', Keyword), (r'throw\b', Keyword),
                (r'return\b', Keyword), (r'if\b', Keyword), (r'class\b', Keyword), (r'struct\b', Keyword), (r'static\b', Keyword), (r'enum\b', Keyword), (r'await\b', Keyword),
                (r'coroutine\b', Keyword), (r'const\b', Keyword), (r'final\b', Keyword), (r'include\b', Keyword), (r'import\b', Keyword), (r'extends\b', Keyword), (r'copy\b', Keyword),
                (r'type\b', Keyword), (r'from\b', Keyword), (r'for\b', Keyword), (r'let\b', Keyword), (r'rem\b', Keyword), (r'out\b', Keyword), (r'pyc\b', Keyword),
                (r'ref\b', Keyword), (r'ptr\b', Keyword), (r'new\b', Keyword), (r'in\b', Keyword), (r'as\b', Keyword), (r'assert\b', Keyword), (r'async\b', Keyword),
                (r'and\b', Operator), (r'or\b', Operator), (r'not\b', Operator),
                (r'is\b', Operator), (r'is\s+not\b', Operator), (r'in\b', Operator), (r'not\s+in\b', Operator), (r'not\b', Operator), (r'\<\b', Operator), (r'\>\b', Operator),
                (r'\=\b', Operator), (r'\!\b', Operator), (r'\+\b', Operator), (r'\-\b', Operator), (r'\*\b', Operator), (r'\-\-\b', Operator), (r'\+\+\b', Operator),
                (r'\/\b', Operator), (r'\%\b', Operator), (r'\^\b', Operator), (r'\&\b', Operator), (r'\>\>\b', Operator), (r'\<\<\b', Operator),
                (r'\*\*\b', Operator), (r'\.\.\.\b', Operator), (r'\@\b', Name.Function), (r'\d+', Number), (r'\d+\.\d+', Number),
                (r'\d+\.\d+[jJ]', Number), (r'\d+[jJ]', Number), (r'\d+[eE][+-]?\d+', Number),  (r'\d+[eE]\d+', Number), (r'(\w+)', Name.Variable),
                (r'\d+\.\d+', Number), (r'\:\:\b', Text),
            ], 'comment': [
                (r'[^*/]+', Comment.Multiline), (r'/\*', Comment.Multiline, '#push'), (r'\*/', Comment.Multiline, '#pop'), (r'[*/]', Comment.Multiline),
            ], 'document': [
                (r'[^*/]+', String.Doc), (r'/\*', String.Doc, '#push'), (r'\*/', String.Doc, '#pop'), (r'[*/]', String.Doc),
            ], 'function': [
                (r'\s+', Text), (r'[a-zA-Z_]\w*', Name.Function, '#pop'), default('#pop'),
            ]
        }
    lexer = VersaceSyntaxHighlightingLexer()
    formatter = TerminalTrueColorFormatter(style='one-dark', colorscheme='monokai')
    #if sys_stdout.isatty() else TerminalFormatter(style='one-dark')


    if isinstance(LINE, str):
        LINE = TOKENIZE_LINE(LINE) if 'UnicodeEmojis_' in LINE else LINE
    ALL_ERRORS_VERSACE_CODE_BASE: set[str] = ('InvalidKeyword', 'InvalidListDeclaration', 'IllegalChar', 'GenericError', 'AssignedValueToConstant', 'badReturn', 'NoIncludesError', 'Used<Error', 'badFunction', 'InvalidTypeSyntax', 'BadInstanceCreation', 'InvalidExtends', 'StylesModuleNotIncludedError', 'ColorModuleNotIncludedError', 'InvalidRemoveSyntax', 'InvalidCopySyntax', 'CanNotFixSize', 'TriedOverloadingGlobalOperator', 'ConstCallOutsideGlobal', 'IllegalCharacter', 'InvalidEnumType', 'CyclicIncludeError', 'notFoundError', 'VariableNotDeclared', 'AssignedValueToUndefined', 'FromStatement', 'InvalidNumberOfVariablesToValues', 'TriedToAssignValueToMultipleVariables' , 'AddedDataTypesToPrivClass', 'AddedArgumentsToPublic', 'outCalledError', 'AsyncAndPrivate', 'dotUsed', 'usedHashtag', 'InvalidDelimiter', 'NeverClosed', 'unclosedComment', 'MissingSemiColon', 'AssignmentInPrivate', 'InvalidDataType', 'InvalidTypeOfValue', 'NullTypeFunction', 'TriedToAssignValueToDataClass', 'BadConfigData', 'FileNotFound', 'InvalidReference', 'NoMain', 'badStaticForLoop', 'badDynTask', 'UsedAsyncAndMethod', 'InvalidDynamicTask', 'InvalidValue')

    _system("")
    if IN_INTERPRETED_MODE: LINE_NO="Previous Statement"
    LINE_LIST: list = LINE.copy() if type(LINE) == list else TOKENIZE_LINE(LINE)
    if type(LINE) == list:
        LINE = ' '.join(LINE)
    LINE = LINE.replace('<INDENTATIONSEP>', '{').replace('<DEDENTATIONSEP>', '}')
    if ERROR not in ALL_ERRORS_VERSACE_CODE_BASE:
        OLD_LINE = LINE
        for i in tuple(GLOBAL_VARIABLES.PYTHON_TO_VERSACE.keys()):
            LINE = LINE.replace(i, GLOBAL_VARIABLES.PYTHON_TO_VERSACE[i])
        OPTIONAL = ' '*(len(LINE)-len(OLD_LINE)) + OPTIONAL
    if ERROR_REPORTING_CALLED:
        print('\n' + COLORS['grey'] + '-'*TERMINAL_WIDTH + COLORS['reset'])
    if LINE.endswith(';') == False:
        if LINE.endswith(('{', '}', '(', ')', '[', ']', ',')) == False:
            LINE += ';'
    LINE_NUMBER, FILE_NAME = GET_LINE_NUMBER(LINE) if LINE_NO is None else LINE_NO, FILE_NAME
    if not isinstance(LINE, int):
        try: LINE_NUMBER, FILE_NAME = LINE_NUMBER
        except: pass
    FILE_NAME = FILE_NAME if FILE_NAME else FILE_PATH
    with open(FILE_NAME, 'r', encoding='utf-8') as f:
        LINES_FROM_FILE_RAW = f.readlines()
    if IN_INTERPRETED_MODE: LINE_NUMBER = 0
    try:
        LINE = LINES_FROM_FILE_RAW[LINE_NUMBER-1][:-1] if LINE_NUMBER is not None else LINE
    except Exception: LINE = ''
    SPACE_CHAR: str = ' '
    ERROR_MAP: MappingProxyType[str, str] = _MAP_(
        {
            #Complex Error Code                     |    Simplified Error Code
            'InvalidValue'                          :    'VariableError',       ###
            'notFoundError'                         :    'VariableError',       ###
            'VariableNotDeclared'                   :    'VariableError',       ###
            'AssignedValueToUndefined'              :    'VariableError',       ###
            'CanNotFixSize'                         :    'VariableError',       ###
            'InvalidExtends'                        :    'VariableError',       ###
            'ConstCallOutsideGlobal'                :    'VariableError',       ###
            'BadInstanceCreation'                   :    'VariableError',       ###
            'AssignedValueToConstant'               :    'VariableError',       ###
            'FromStatement'                         :    'SyntaxError',         ###
            'InvalidTypeSyntax'                     :    'SyntaxError',         ###
            'InvalidNumberOfVariablesToValues'      :    'SyntaxError',         ###
            'TriedToAssignValueToMultipleVariables' :    'SyntaxError',         ###
            'badFunction'                           :    'SyntaxError',         ###
            'AddedDataTypesToPrivClass'             :    'SyntaxError',         ###
            'badReturn'                             :    'SyntaxError',         ###
            'AddedArgumentsToPublic'                :    'SyntaxError',         ###
            'IllegalChar'                           :    'SyntaxError',         ###
            'outCalledError'                        :    'SyntaxError',         ###
            'AsyncAndPrivate'                       :    'SyntaxError',         ###
            'dotUsed'                               :    'SyntaxError',         ###
            'IllegalCharacter'                      :    'SyntaxError',         ###
            'TriedOverloadingGlobalOperator'        :    'SyntaxError',         ###
            'InvalidKeyword'                        :    'SyntaxError',         ###
            'ColorModuleNotIncludedError'           :    'SyntaxError',         ###
            'StylesModuleNotIncludedError'          :    'SyntaxError',         ###
            'IllegalCharacter'                      :    'SyntaxError',         ###
            'usedHashtag'                           :    'SyntaxError',         ###
            'InvalidEnumType'                       :    'SyntaxError',         ###
            'InvalidDelimiter'                      :    'SyntaxError',         ###
            'badStaticForLoop'                      :    'SyntaxError',         ###
            'InvalidRemoveSyntax'                   :    'SyntaxError',         ###
            'InvalidListDeclaration'                :    'SyntaxError',         ###
            'badDynTask'                            :    'SyntaxError',         ###
            'UsedAsyncAndMethod'                    :    'SyntaxError',         ###
            'NeverClosed'                           :    'CloseError',          ###
            'unclosedComment'                       :    'CloseError',          ###
            'MissingSemiColon'                      :    'CloseError',          ###
            'AssignmentInPrivate'                   :    'TypeError',           ###
            'InvalidDataType'                       :    'TypeError',           ###
            'InvalidTypeOfValue'                    :    'TypeError',           ###
            'NullTypeFunction'                      :    'TypeError',           ###
            'TriedToAssignValueToDataClass'         :    'DataError',           ###
            'BadConfigData'                         :    'DataError',           ###
            'GenericError'                          :    'RuntimeError',        ###
            'Used<Error'                            :    'DeprecatedComponentError',           ###
            'FileNotFound'                          :    'FileNotFoundError',   ###
            'InvalidReference'                      :    'ReferenceError',       ###
            'InvalidDynamicTask'                    :    'ReferenceError',       ###
            'NoMain'                                :    'NoMainError',         ###
            'CyclicIncludeError'                    :    'IncludeError',        ###
            'NoIncludesError'                       :    'IncludeError',        ###
            'InvalidCopySyntax'                     :    'SyntaxError',         ###
        }
    )
    DATA_TYPE_FULL: MappingProxyType[str, str] = _MAP_(
        {
            'int'        : 'Integer',
            'float'      : 'Float',
            'str'        : 'String',
            'bool'       : 'Boolean',
            'list'       : 'List',
            'tuple'      : 'Tuple',
            'map'        : 'Map',
            'set'        : 'Set',
            'null'       : 'Null',
            'none'       : 'None',
            'complex'    : 'Complex',
            'i8'         : 'Integer 8-bit',
            'i16'        : 'Integer 16-bit',
            'i32'        : 'Integer 32-bit',
            'i64'        : 'Integer 64-bit',
            'i128'       : 'Integer 128-bit',
            'u8'         : 'Unsigned Integer 8-bit',
            'u16'        : 'Unsigned Integer 16-bit',
            'u32'        : 'Unsigned Integer 32-bit',
            'u64'        : 'Unsigned Integer 64-bit',
            'u128'       : 'Unsigned Integer 128-bit',
            'f32'        : 'Float 32-bit',
            'f64'        : 'Float 64-bit',
            'array'      : 'Array',
            'double'     : 'Double',
            'usize'      : 'Unknown Object',
            'bytes'      : 'Bytes',
            'bin'        : 'Binary',
            'hex'        : 'Hexadecimal',
            'oct'        : 'Octal',
            'dec'        : 'Decimal',
            'double'     : 'Double',
            'char'       : 'Character',
            'memoryview' : 'Memory View',
            'bytearray'  : 'Byte Array',
            'frozenset'  : 'Frozen Set',
            'range'      : 'Range',
            'nullType'   : 'Null Type',
        }
    )
    DOCS_REF: MappingProxyType[str, str] = _MAP_(
        {
            "public"    : "ID 4D 7075626C6963",
            "priv"      : "ID 4D 70726976",
            "method"    : "ID 4D 6D6574686F64",
            "with"      : "ID 4D 77697468",
            "call"      : "ID 4D 63616C6C",
            "if"        : "ID 43 6966",
            "else"      : "ID 43 656C7365",
            "else if"   : "ID 43 656C7365206966",
            "for"       : "ID 43 666F72",
            "while"     : "ID 43 7768696C65",
            "return"    : "ID 43 72657475726E",
            "class"     : "ID 48 636C617373",
            "struct"    : "ID 48 737472756374",
            "static"    : "ID 48 737461746963",
            "enum"      : "ID 48 656E756D",
            "ptr"       : "ID 48 707472",
            "func"      : "ID 46 66756E63",
            "async"     : "ID 46 6173796E63",
            "await"     : "ID 46 6177616974",
            "coroutine" : "ID 46 636F726F7574696E65",
            "const"     : "ID 56 636F6E7374",
            "ref"       : "ID 56 726566",
            "copy"      : "ID 56 636F7079",
            "let"       : "ID 56 6C6574",
            "final"     : "ID 56 66696E616C",
            "rem"       : "ID 56 72656D",
            "type"      : "ID 56 74797065",
            "out"       : "ID 4F 6F7574",
            "in"        : "ID 4F 696E",
            "include"   : "ID 4F 696E636C756465",
            "import"    : "ID 4F 696D706F7274",
            "from"      : "ID 4F 66726F6D",
            "pyc"       : "ID 4F 707963",
            "@"         : "ID 4G 40",
            "="         : "ID 5F 3d",
            "<"         : "ID 5F 3c",
            ">"         : "ID 5F 3e",
            "-"         : "ID 5F 3d",
            "!"         : "ID 5F 21",
            "+"         : "ID 5F 2b",
            "-"         : "ID 5F 2d",
            "*"         : "ID 5F 2a",
            "/"         : "ID 5F 2f",
            "%"         : "ID 5F 25",
            "^"         : "ID 5F 5e",
            "&"         : "ID 5F 26",
            "|"         : "ID 5F 7c",
            ">>"        : "ID 5F 3e3e",
            "<<"        : "ID 5F 3c3c",
            "**"        : "ID 5F 2a2a",
            "::"        : "ID 5F 3a3a",
            "un-signed-int" : "ID 4B 7538",
            "signed-int"    : "ID 4B 6938",
            "signed-float"  : "ID 4B 663332",
            "int"       : "ID 44 696e74",
            "float"     : "ID 44 666c6f6174",
            "complex"   : "ID 44 636f6d706c6578",
            "double"    : "ID 44 646f75626c65",
            "str"       : "ID 44 737472",
            "usize"     : "ID 44 7573697a65",
            "bool"      : "ID 44 626f6f6c",
            "list"      : "ID 44 6c697374",
            "map"       : "ID 44 6d6170",
            "array"     : "ID 44 6172726179",
            "set"       : "ID 44 736574",
            "bytes"     : "ID 44 6279746573",
            "object"    : "ID 44 6f626a656374",
            "char"      : "ID 44 63686172",
            "self"      : "ID 44 73656c66",
            "super"     : "ID 44 7375706572",
            "bytearray" : "ID 44 627974656172726179",
            "frozenset" : "ID 44 66726f7a656e736574",
            "range"     : "ID 44 72616e6765",
            "NULL"      : "ID 44 4e554c4c",
            "NULLType"  : "ID 44 4e554c4c54797065",
        }
    )

    def mark_chars(LINE, LOOK_FOR, BOTTOM_LINE, SPACE=SPACE_CHAR, MARK_AFTER=False, MARK_BEFORE=False):
        IN_STRING: bool = False
        COUNT: int = 0
        MARKED_LINE: str = ''
        for i in BOTTOM_LINE:
            if '^' in i:
                COUNT += 1
        for index, char in enumerate(LINE):
            if char == '\"' and LINE[index-1] != '\\':
                if LOOK_FOR == '\"':
                    if IN_STRING : MARKED_LINE = MARKED_LINE[:-1] + '^'
                    else: MARKED_LINE += '^'
                IN_STRING = LATCH(IN_STRING)
            if char == LOOK_FOR and IN_STRING is False:
                if LOOK_FOR == '\"': continue
                MARKED_LINE += '^'
                if MARK_AFTER is True:
                    SPACE = '^'
                MARK_BEFORE = False
            else:
                if COUNT != 0 and IN_STRING is False:
                    COUNT -= 1
                else: MARKED_LINE += SPACE if not MARK_BEFORE else '^'
        return BOTTOM_LINE + MARKED_LINE
    def mark_words(LINE_LIST, WORD, BOTTOM_LINE):
        if isinstance(WORD, str) != True:
            for word in WORD:
                for i in LINE_LIST:
                    if word == i:
                        BOTTOM_LINE += '^'*len(i)
                        break
                    else:
                        BOTTOM_LINE += SPACE_CHAR*(len(i)+1)
        else:
            # get words from line
            LINE = ' '.join(LINE_LIST)
            NEW_LINE: list[str] = LINE.split()
            for i in NEW_LINE:
                if WORD == i:
                    BOTTOM_LINE += '^'*len(i)
                    break
                else:
                    BOTTOM_LINE += SPACE_CHAR*(len(i)+1)
        return BOTTOM_LINE
    def simple_mark_chars(LINE, LOOK_FOR, BOTTOM_LINE):
        IN_STRING = False
        for index, i in enumerate(LINE):
            if i == '/' and MIDDLE_LINE[index + 1] == '/': break
            elif i == '/' and MIDDLE_LINE[index + 1] == '*': break
            elif i == '*' and MIDDLE_LINE[index + 1] == '/': break

            if i == '"' and MIDDLE_LINE[index - 1] != '\\': IN_STRING = not IN_STRING
            if IN_STRING: BOTTOM_LINE += ' '; continue
            if i == LOOK_FOR: BOTTOM_LINE += '^'
            else: BOTTOM_LINE += ' '
        return BOTTOM_LINE

    STRAIGHT_HORIZONTAL_LINE = '\u2500'
    # get 5 line before the error line from LINES_FROM_FILE_RAW
    LINE_BEFORE: list[str] = []*100
    for i in reversed(LINES_FROM_FILE_RAW[:LINE_NUMBER-1]):
        # remove the new line character at the end and keep the line spacing in the start
        LINE_BEFORE.append(i[:-1])
        if len(LINE_BEFORE) == TRACEBACK_LIMIT: break
    # count the white space in the start of the line
    WHITESPACE: int = 0
    WHITESPACE_TYPE: str = ''
    from string import whitespace
    for i in LINE:
        if i in whitespace: WHITESPACE += 1; WHITESPACE_TYPE = i
        else: break

    """
    Full Traceback:
    Reported Traceback in File "U:\Versace-with-Fixes\testing\Versace\duc.v", line 32
        SyntaxError:
        │   28      usize obj_ind = India();
        │   29      usize obj_usa = Usa();
        │   30
        │   31      public main() {
        │ ❱ 32      usize countries = ( obj_ind | obj_usa )
        ╰─────────> ^^^^^^^
    Invalid Keyword 'usize' was used, did you mean 'usize'?
    """
    included_file_text: str = ''
    if FILE_NAME != FILE_PATH and len(INCLUDES) > 0: included_file_text = 'included file '
    LINE_BEFORE.insert(0, LINE)
    TOP_LINE = f"{COLORS['white']}Reported Traceback in {included_file_text}{COLORS['dim green']}\"{FILE_NAME.capitalize()}\"{COLORS['white']}, line {LINE_NUMBER}{COLORS['reset']}"
    MIDDLE_LINE = f"{COLORS['red']}    {ERROR_MAP.get(ERROR)}: {COLORS['yellow']}"
    MIDDLE_LINE_LEN = len(f'{ERROR_MAP.get(ERROR)}')
    LINE_BEFORE = LINE_BEFORE[::-1]
    IN_COMMENT: bool = False
    IN_STRING: bool = False
    try:
        if LINE_BEFORE[0].strip() == '': LINE_BEFORE.pop(0)
        if LINE_BEFORE[-1].strip() == '': LINE_BEFORE.pop(-1)
    except Exception: pass
    LINE_NUMBER -= len(LINE_BEFORE)
    LINE_BEFORE_NO: int = 0
    _system("")
    if ERROR not in ALL_ERRORS_VERSACE_CODE_BASE: MIDDLE_LINE = ''
    for i in LINE_BEFORE:
        LINE_NUMBER += 1
        LINE_BEFORE_NO = LINE_BEFORE.index(i)
        i = highlight(i, lexer, formatter).rstrip()
        if i.startswith('//'): i = f"{COLORS['grey']}{i}{COLORS['reset']}"
        if i.startswith('/*') and not IN_COMMENT: i = f"{COLORS['grey']}{i}{COLORS['reset']}"; IN_COMMENT = True
        if i.endswith('*/') and IN_COMMENT: i = f"{COLORS['grey']}{i}{COLORS['reset']}"; IN_COMMENT = False
        for index, ii in enumerate(i):
            if ii == '"' and i[index-1] + i != r'\"':
                IN_STRING = not IN_STRING
                # highlight the string green
            if not IN_STRING:
                if len(i) > index+1:
                    if ii == '/' and i[index+1] == '/': # TODO fix this
                        i = f"{i[:index]}{COLORS['grey']}{i[index:]}"
                        break
        if IN_COMMENT: i = f"{COLORS['grey']}{i}{COLORS['reset']}"
        """if ERROR not in ALL_ERRORS_VERSACE_CODE_BASE:
            if LINE_BEFORE_NO == len(LINE_BEFORE)-1: MIDDLE_LINE += f"\n    {COLORS['red']}\u2502    ❱ {COLORS['white']}{LINE_NUMBER:<2}{COLORS['yellow']}{i}{COLORS['reset']}"; break
            MIDDLE_LINE += f"\n    {COLORS['red']}\u2502      {COLORS['grey']}{LINE_NUMBER:<2}{COLORS['yellow']}{i}{COLORS['reset']}"
        else:"""
        if ERROR not in ALL_ERRORS_VERSACE_CODE_BASE: MIDDLE_LINE_LEN = 9
        if LINE_BEFORE_NO == len(LINE_BEFORE)-1: MIDDLE_LINE += f"\n    {COLORS['red']}\u2502   {' '*(MIDDLE_LINE_LEN-9)}❱ {COLORS['white']}{LINE_NUMBER:<6}{COLORS['yellow']}{i}{COLORS['reset']}"; break
        MIDDLE_LINE += f"\n    {COLORS['red']}\u2502    {' '*(MIDDLE_LINE_LEN-8)}{COLORS['grey']}{LINE_NUMBER:<6}{COLORS['yellow']}{i}{COLORS['reset']}"
    if ERROR not in ALL_ERRORS_VERSACE_CODE_BASE: MIDDLE_LINE = f"{COLORS['red']}    {OPTIONAL2}{COLORS['yellow']}{MIDDLE_LINE}{COLORS['reset']}"; MIDDLE_LINE_LEN = len(OPTIONAL2) - 2
    BOTTOM_LINE = f"{COLORS['red']}    \u2570{STRAIGHT_HORIZONTAL_LINE*(MIDDLE_LINE_LEN)}> {WHITESPACE_TYPE*(WHITESPACE)}"
    if ERROR_REPORTING_CALLED is False and '-*- all errors -*-' in OPTIONAL_ARGS_IN_FILE: print(f"{COLORS['red']}Full Traceback:{COLORS['reset']}")
    ERROR_REPORTING_CALLED = True
    print("") if not SEMI_COLON_ERROR else None
    #[print(f"{COLORS['red']}\u2502   {COLORS['yellow']}{i}{COLORS['reset']}") for i in LINE_BEFORE if i != '']
    LINE = LINE.strip()
    COLORS['red'] = "\033[0m"
    if ERROR == "MissingSemiColon":
        print("") if SEMI_COLON_ERROR else None
        SEMI_COLON_ERROR = True
        print(f"{TOP_LINE}")
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{SPACE_CHAR*len(LINE)}^")
        print(f"{COLORS['red']}Missing semi-colon {COLORS['yellow']}(;){COLORS['red']} at the end of the line (If you do not want semi-colon checking use {COLORS['yellow']}[-*- no newline -*-]{COLORS['red']} on the top of the file)\n{COLORS['yellow']}NOTE: This error will override all other errors until resolved.{COLORS['reset']}")
    if SEMI_COLON_ERROR: return

    print(f"{TOP_LINE}")

    if ERROR == "NoMain":
        UnhandledException("No main function found in the file.")
    elif ERROR == "NeverClosed":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE[:-2]}{'^'*len(LINE)}")
        print(f"{COLORS['red']}Never closed.{COLORS['red']}")
    elif ERROR == "InvalidDelimiter":
        BOTTOM_LINE = mark_chars(LINE, "'", BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Versace does not support the (\') delimiter, use only (\"){COLORS['reset']}")
    elif ERROR == "InvalidTypeOfValue":
        BOTTOM_LINE += '^'*len(LINE_LIST[0])
        # example : int someFloat = 1.0;
        # mark    : ^^^             ^^^
        FOUND: bool = False
        COUNT: int = 0
        for i in BOTTOM_LINE:
            if i == '^': COUNT += 1
        for i in LINE:
            if i == '=': FOUND = True; BOTTOM_LINE += SPACE_CHAR; continue
            if FOUND :
                if i == ' ': BOTTOM_LINE += SPACE_CHAR; continue
                if i == ',': BOTTOM_LINE += SPACE_CHAR; continue
                if i == ';': break
                BOTTOM_LINE += '^'
            else:
                if COUNT != 0: COUNT -= 1
                else: BOTTOM_LINE += SPACE_CHAR
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        if 'Unsigned' not in OPTIONAL2: print(f"{COLORS['red']}Expected {COLORS['yellow']}{DATA_TYPE_FULL.get(OPTIONAL2)}{COLORS['reset']}{COLORS['red']} value, but got {COLORS['yellow']}{DATA_TYPE_FULL.get(OPTIONAL)}{COLORS['reset']}{COLORS['red']} value instead{COLORS['reset']}")
        else:
            if OPTIONAL3 is not None: OPTIONAL2 = DATA_TYPE_FULL.get(OPTIONAL3)
            print(f"{COLORS['red']}Expected {COLORS['yellow']}{DATA_TYPE_FULL.get(OPTIONAL)}{COLORS['reset']}{COLORS['red']}, but got {COLORS['yellow']}{OPTIONAL2}{COLORS['reset']}{COLORS['red']} value instead. A value must NOT be provided if using an unsigned binary integer.{COLORS['reset']}")
    elif ERROR == "dotUsed":
        BOTTOM_LINE = mark_chars(LINE, '.', BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Versace does not support the (.) operator for class/function sub-object calls, use (::) instead{COLORS['reset']}")
    elif ERROR == "InvalidValue":
        if 'Must' in OPTIONAL2:
            count = 0
            for i in LINE_LIST:
                count += 1
                if i.strip() == OPTIONAL3.strip():
                    BOTTOM_LINE += '^'*len(i)
                    break
                else:
                    BOTTOM_LINE += SPACE_CHAR*len(i)
                if count > 2:
                    BOTTOM_LINE += SPACE_CHAR
            if '^' not in BOTTOM_LINE:
                BOTTOM_LINE = f"{COLORS['red']}    \u2570{STRAIGHT_HORIZONTAL_LINE*(MIDDLE_LINE_LEN)}> {WHITESPACE_TYPE*(WHITESPACE)}"
                BOTTOM_LINE += '^'*len(LINE_LIST[0])
                # example : int someFloat = 1.0;
                # mark    : ^^^             ^^^
                FOUND: bool = False
                COUNT: int = 0
                for i in BOTTOM_LINE:
                    if i == '^': COUNT += 1
                for i in LINE:
                    if i == '=': FOUND = True; BOTTOM_LINE += SPACE_CHAR; continue
                    if FOUND :
                        if i == ' ': BOTTOM_LINE += SPACE_CHAR; continue
                        if i == ',': BOTTOM_LINE += SPACE_CHAR; continue
                        if i == ';': break
                        BOTTOM_LINE += '^'
                    else:
                        if COUNT != 0: COUNT -= 1
                        else: BOTTOM_LINE += SPACE_CHAR
            print(f"{MIDDLE_LINE}")
            print(f"{BOTTOM_LINE}")
            print(f"{COLORS['yellow']}{LINE_LIST[0]}{COLORS['red']} {OPTIONAL2}, got {OPTIONAL} instead.{COLORS['reset']}")
        else:
            print(f"{MIDDLE_LINE}")
            print(f"{BOTTOM_LINE}")
            print(f"{COLORS['red']}Unknown InvalidValue error{COLORS['reset']}")
    elif ERROR == "notFoundError":
        BOTTOM_LINE = mark_words(LINE_LIST, OPTIONAL, BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Variable {COLORS['yellow']}{OPTIONAL}{COLORS['reset']}{COLORS['red']} was not Found{COLORS['reset']}")
    elif ERROR == "VariableNotDeclared":
        BOTTOM_LINE = mark_words(LINE_LIST, OPTIONAL, BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Variable {COLORS['yellow']}{OPTIONAL}{COLORS['reset']}{COLORS['red']} was not declared{COLORS['reset']}")
    elif ERROR == "AssignedValueToUndefined":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Cannot assign value to undefined variable{COLORS['reset']}")
    elif ERROR == "FromStatement":
        BOTTOM_LINE = mark_words(LINE_LIST, "from", BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Cannot import from statement{COLORS['reset']}")
    elif ERROR == "InvalidNumberOfVariablesToValues":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE)}")
        print(f"{COLORS['red']}Invalid number of variables to values or vice versa use the ({COLORS['yellow']}|{COLORS['red']}) operator to separate values passed to a function during variable declaration{COLORS['reset']}")
    elif ERROR == "TriedToAssignValueToMultipleVariables":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE)}")
        print(f"{COLORS['red']}Cannot assign value to multiple variables{COLORS['reset']}")
    elif ERROR == "AddedDataTypesToPrivClass":
        BOTTOM_LINE = mark_words(LINE_LIST, (DATA_TYPE_TOKENS.keys()), BOTTOM_LINE).strip()
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Cannot add data types to private class{COLORS['reset']}")
    elif ERROR == "AddedArgumentsToPublic":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*(len(LINE) - 2)}")
        if OPTIONAL:
            print(f"{COLORS['red']}{OPTIONAL}{COLORS['reset']}")
        else:
            print(f"{COLORS['red']}Cannot add arguments to public class{COLORS['reset']}")
        print(f"{COLORS['yellow']}Documentation reference: {DOCS_REF['public']}{COLORS['reset']}")
    elif ERROR == "outCalledError":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE.strip()}{WHITESPACE_TYPE*WHITESPACE} {'^'*len(LINE_LIST[0])}")
        print(f"{COLORS['red']}Called out more than once{COLORS['reset']}")
    elif ERROR == "AsyncAndPrivate":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{' '*len(LINE_LIST[0])} {'^'*len(LINE_LIST[1])}")
        print(f"{COLORS['red']}Cannot use private and async together{COLORS['reset']}")
    elif ERROR == "usedHashtag":
        BOTTOM_LINE = mark_chars(LINE, '#', BOTTOM_LINE, SPACE='~')
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Cannot use # in code{COLORS['reset']}")
    elif ERROR == "badStaticForLoop":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE)}")
        print(f"{COLORS['red']}Invalid for loop{COLORS['reset']}")
    elif ERROR == "badDynTask":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE)}")
        print(f"{COLORS['red']}Invalid dynamic task{COLORS['reset']}")
    elif ERROR == "UsedAsyncAndMethod":
        BOTTOM_LINE = mark_words(LINE_LIST, "async", BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Cannot use async and method together{COLORS['reset']}")
    elif ERROR == "unclosedComment":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE)}")
        print(f"{COLORS['red']}Unclosed comment{COLORS['reset']}")
    elif ERROR == "AssignmentInPrivate":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE)}")
        print(f"{COLORS['red']}Cannot assign value in private{COLORS['reset']}")
    elif ERROR == "InvalidDataType":
        BOTTOM_LINE = mark_words(LINE_LIST, LINE_LIST[0], BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Unknown data type provided {COLORS['yellow']}\"{LINE_LIST[0]}\"{COLORS['reset']}")
    elif ERROR == "NullTypeFunction":
        BOTTOM_LINE = mark_words(LINE_LIST, LINE_LIST[0], BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Cannot use null type as function{COLORS['reset']}")
    elif ERROR == "TriedToAssignValueToDataClass":
        BOTTOM_LINE = mark_chars(LINE, '=', BOTTOM_LINE, SPACE='~')
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Cannot assign value to structure{COLORS['reset']}")
    elif ERROR == "BadConfigData":
        print(f"{MIDDLE_LINE.split('#')[0].strip()}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE.split('#')[0].strip())}")
        print(f"{COLORS['red']}Invalid config data entered, {OPTIONAL}.{COLORS['reset']}")
    elif ERROR == "FileNotFound":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE)}")
        print(f"{COLORS['red']}File not found{COLORS['reset']}")
    elif ERROR == "InvalidReference":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}    {'^'*len(LINE[4:])}")
        print(f"{COLORS['red']}Invalid reference{COLORS['reset']}")
    elif ERROR == "InvalidDynamicTask":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}          {'^'*len(LINE[10:])}")
        print(f"{COLORS['red']}Invalid dynamic task{COLORS['reset']}")
    elif ERROR == "TriedToAssignValueToFinal":
        BOTTOM_LINE = mark_chars(LINE, '=', BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Cannot assign a value when setting it to final{COLORS['reset']}")
    elif ERROR == 'Used<Error':
        BOTTOM_LINE = simple_mark_chars(LINE, '<', BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Cannot use (<), This Version of Versace expects (<<){COLORS['reset']}")
    elif ERROR == "InvalidKeyword":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE.strip()}{WHITESPACE_TYPE*WHITESPACE} {'^'*len(LINE_LIST[0])}")
        # check what the keyword is most likely to be and suggest it
        from difflib import get_close_matches
        # CLASSES, VARIABLES, FUNCTIONS
        KEYWORDS = list(TOKENS.keys()) + list(GLOBAL_VARIABLES.ALL_PYTHON_KEYWORDS) + list(CLASSES.keys())
        SUGGESTED_KEYWORD = get_close_matches(LINE_LIST[0], KEYWORDS, n=1)
        PRINT_LINE = f", {COLORS['red']}if you meant to assign a value to a declared variable, use {COLORS['green']}'let'{COLORS['red']} instead.{COLORS['reset']}"
        if SUGGESTED_KEYWORD:
            if LINE_LIST[0] in ('tuple', 'dict'):
                if LINE_LIST[0] == 'tuple':
                    SUGGESTED_KEYWORD = ['array']
                elif LINE_LIST[0] == 'dict':
                    SUGGESTED_KEYWORD = ['map']
            PRINT_LINE = f"{COLORS['red']}, did you mean {COLORS['yellow']}'{SUGGESTED_KEYWORD[0]}{COLORS['reset']}{COLORS['yellow']}'{COLORS['red']}?{COLORS['reset']}"
        print(f"{COLORS['red']}Invalid Keyword {COLORS['yellow']}'{LINE_LIST[0]}'{COLORS['reset']}{COLORS['red']} was used{PRINT_LINE}")
    elif ERROR == "badReturn":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE)}")
        print(f"{COLORS['red']}Return has to be followed by something to return, if you are intending to return nothing, use {COLORS['yellow']}'return 0'{COLORS['red']} or {COLORS['yellow']}'return NULL'{COLORS['red']}{COLORS['reset']}")
    elif ERROR == "CyclicIncludeError":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE)}")
        print(f"{COLORS['red']}Circular include detected for {COLORS['yellow']}\"{OPTIONAL}\"{COLORS['red']}, this is not allowed{COLORS['reset']}")
        print(f"{COLORS['yellow']}\nNOTE: This means that one of your files is trying to include itself, or another file that includes it. \n{COLORS['red']}(The shown module, is the last module that was checked and my not be right.){COLORS['reset']}")
    elif ERROR == 'InvalidEnumType':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE.strip()}{WHITESPACE_TYPE*WHITESPACE} {'^'*len(LINE_LIST[0])}")
        print(f"{COLORS['red']}Invalid enum type, {COLORS['yellow']}\"{LINE_LIST[0]}\"{COLORS['red']} is not a valid enum type, Only valid enum types are {COLORS['yellow']}(int, str){COLORS['reset']}")
    elif ERROR == 'IllegalChar':
        BOTTOM_LINE = mark_chars(LINE, OPTIONAL, BOTTOM_LINE, SPACE='~', MARK_AFTER=True)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Illegal character {COLORS['yellow']}\"{OPTIONAL}\"{COLORS['red']} was used{COLORS['reset']}")
    elif ERROR == 'ConstCallOutsideGlobal':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE.strip()}{WHITESPACE_TYPE*WHITESPACE} {'^'*len(LINE_LIST[0])}")
        print(f"{COLORS['red']}Cannot define a constant outside of the global scope.{COLORS['reset']}")
    elif ERROR == 'AssignedValueToConstant':
        BOTTOM_LINE = mark_chars(LINE, '=', BOTTOM_LINE, SPACE='~')
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}Cannot assign a value to a constant.{COLORS['reset']}")
    elif ERROR == 'TriedOverloadingGlobalOperator':
        BOTTOM_LINE = mark_chars(LINE, OPTIONAL, BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}You can not overload the global operators, {COLORS['yellow']}\"{OPTIONAL}\"{COLORS['red']} is a global operator\n{COLORS['yellow']}NOTE: You can overload class operators only.{COLORS['reset']}")
    elif ERROR == 'CanNotFixSize':
        BOTTOM_LINE = mark_chars(LINE, '*', BOTTOM_LINE, MARK_BEFORE=True, SPACE='~')
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{COLORS['red']}You can not fix the size of anything other than a list, {COLORS['yellow']}\"{LINE_LIST[0]}\"{COLORS['red']} is not a list{COLORS['reset']}")
    elif ERROR == 'InvalidCopySyntax':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE.strip())}")
        print(f"{COLORS['red']}Invalid copy syntax, syntax should look like: {COLORS['yellow']}\"copy var -> new_var\"{COLORS['reset']}")
    elif ERROR == 'InvalidRemoveSyntax':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE.strip())}")
        print(f"{COLORS['red']}Invalid remove syntax, syntax should look like: {COLORS['yellow']}\"rem var\"{COLORS['reset']}")
    elif ERROR == 'ColorModuleNotIncludedError':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE.strip())}")
        print(f"{COLORS['red']}You can not use colors without including the {COLORS['yellow']}\"colors.v\"{COLORS['red']} module{COLORS['reset']}")
    elif ERROR == 'StylesModuleNotIncludedError':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE.strip())}")
        print(f"{COLORS['red']}You can not use styles without including the {COLORS['yellow']}\"styles.v\"{COLORS['red']} module{COLORS['reset']}")
    elif ERROR == 'InvalidExtends':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}      {' '*len(LINE_LIST[0])} {' '*len(LINE_LIST[1])} {' '*len(LINE_LIST[2])} {'^'*len(LINE_LIST[3])}")
        from difflib import get_close_matches
        KEYWORDS = list(CLASSES.keys())
        SUGGESTED_KEYWORD = get_close_matches(LINE_LIST[3], KEYWORDS, n=1)
        if not SUGGESTED_KEYWORD:
            print(f"{COLORS['red']}Invalid extension of class, {COLORS['yellow']}\"{OPTIONAL}\"{COLORS['red']} is not valid class{COLORS['reset']}")
        else:
            print(f"{COLORS['red']}Invalid extension of class, {COLORS['yellow']}\"{OPTIONAL}\"{COLORS['red']} is not valid class, did you mean {COLORS['yellow']}\"{SUGGESTED_KEYWORD[0]}\"{COLORS['reset']}")
    elif ERROR == 'InvalidTypeSyntax':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE.strip())}")
        print(f"{COLORS['red']}Invalid type syntax, syntax should look like: {COLORS['yellow']}\"type newTypeName = type;\"{COLORS['red']} or {COLORS['yellow']}\"type newTypeName;\"{COLORS['reset']}")
    elif ERROR == 'BadInstanceCreation':
        BOTTOM_LINE = mark_words(LINE_LIST, OPTIONAL, BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        #print(f"{BOTTOM_LINE}{'^'*len(LINE_LIST[LINE_LIST.index(OPTIONAL)+1:])}")
        print(f"{BOTTOM_LINE}")
        from difflib import get_close_matches
        KEYWORDS = list(CLASSES.keys())
        SUGGESTED_KEYWORD = get_close_matches(OPTIONAL, KEYWORDS, n=1)
        if SUGGESTED_KEYWORD:
            print(f"{COLORS['red']}Invalid instance creation, Unknown class: {COLORS['yellow']}\"{OPTIONAL}{COLORS['reset']}{COLORS['yellow']}\"{COLORS['red']}, did you mean {COLORS['yellow']}\"{SUGGESTED_KEYWORD[0]}{COLORS['reset']}{COLORS['yellow']}\"{COLORS['reset']}")
        else:
            print(f"{COLORS['red']}Invalid instance creation, Unknown class: {COLORS['yellow']}\"{OPTIONAL}\"{COLORS['reset']}")
    elif ERROR == 'badFunction':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE.strip())}")
        print(f"{COLORS['red']}Invalid function syntax, you can not have keyword arguments or parameters without type declaration in function definition.\nIf you do not understand this search for {COLORS['yellow']}\"ID 46 66756E63\"{COLORS['red']} in the documentation.{COLORS['reset']}")
    elif ERROR == 'NoIncludesError':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE.strip())}")
        print(f"{COLORS['red']}You can not include a file with the {COLORS['yellow']}\"no_includes\"{COLORS['red']} set to true in the config file{COLORS['reset']}")
    elif ERROR == 'InvalidListDeclaration':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE.strip())}")
        print(f"{COLORS['red']}Invalid list declaration, syntax should look like: {COLORS['yellow']}\"list new_list_name = [1, 2, 3, 4, 5];\"{COLORS['reset']}")
        print(f"{COLORS['red']}Or you can use the {COLORS['yellow']}\"list new_list_name;\"{COLORS['red']} syntax to create an empty list{COLORS['reset']}")
        print(f"{COLORS['red']}Or you can use the {COLORS['yellow']}\"list*[<int>] new_list_name;\"{COLORS['red']} syntax to create an empty list with a fixed length{COLORS['reset']}")
    elif ERROR == 'GenericError':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(LINE.strip())}")
        print(f"{COLORS['red']}During execution an error occurred{COLORS['reset']}")
    else:
        print(f"{COLORS['red']}During execution {'another' if ERROR == 'other' else 'an'} error occurred{COLORS['reset']}")
        print(f"{COLORS['red']}{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{OPTIONAL}")
        print(f"{ERROR}{COLORS['reset']}")
        if '-*- all errors -*-' in OPTIONAL_ARGS_IN_FILE:
            print(f"{COLORS['yellow']}NOTE: This last error was not generated by Versace, so the line marking may be incorrect.{COLORS['reset']}")
        else:
            print(f"{COLORS['yellow']}\nNOTE: This error was not generated by Versace, so the line marking may be incorrect.{COLORS['reset']}")
    if '-d' in PASS_LIST:
        print(f"\n{COLORS['red']}{'-'*int((TERMINAL_WIDTH-12)/2)} DEBUG INFO {'-'*int((TERMINAL_WIDTH-11)/2)}")
        from rich.pretty import pprint as r_pprint
        r_pprint(org_args_passed, expand_all=True)
        if '-all' in PASS_LIST:
            COLLECT_DATA()
            from rich import console as c_console; rich_print = c_console.Console().print # Define the O__CODE_PRINT variable
            _system("")
            from rich.syntax import Syntax

            if INCLUDES:
                for i in INCLUDES:
                    with open(i, "r", encoding="utf-8") as f:
                        print(f"\n{COLORS['red']}{'-'*int((TERMINAL_WIDTH-31)/2)} Original Data From {path.basename(i)} {'-'*int((TERMINAL_WIDTH-31-1)/2)}{COLORS['reset']}")
                        OUTPUT = highlight(f.read(), lexer, formatter).rstrip()
                        print(OUTPUT)
                        f.close()
                    continue
            else:
                print(f"\n{COLORS['red']}{'-'*int((TERMINAL_WIDTH-31)/2)} Original Data From {path.basename(i)} {'-'*int((TERMINAL_WIDTH-31-1)/2)}{COLORS['reset']}")
                OUTPUT = highlight(''.join(LINES_FROM_FILE_RAW), lexer, formatter).rstrip()
                print(OUTPUT)

            print(f"\n{COLORS['red']}{'-'*int((TERMINAL_WIDTH-33)/2)} Python Code Generated by Versace {'-'*int((TERMINAL_WIDTH-33)/2)}")
            OUTPUT = Syntax('\n'.join(FINAL_LIST), "python", theme="one-dark", line_numbers=True, background_color="default") # Define the D__TOKENS variable
            rich_print(OUTPUT) # Print the D__TOKENS
        print(f"{COLORS['red']}{'-'*int((TERMINAL_WIDTH))}{COLORS['reset']}")
        exit()
    if '-*- all errors -*-' in OPTIONAL_ARGS_IN_FILE: return
    else: exit(2)
def GET_LINE_NUMBER(LINE, MODE=None, RETURN_TYPE=0) -> str:
    """
    \n Gets the correct line number for the line from the original file.
    \n Outputs the line number or 'Line is not in file' if the line is not in the original file.
    \n Input: line - The line to get the line number for. (string)
    \n Output: line number - The line number of the line. (int)
    """
    if type(LINE) != str:
        LINE = (''.join(LINE)).replace(' ', '')
    LINE = LINE.strip().replace(' ', '')
    if '<INDENTATIONSEP>' in LINE: LINE = LINE.replace('<INDENTATIONSEP>', '{')
    if '<DEDENTATIONSEP>' in LINE: LINE = LINE.replace('<DEDENTATIONSEP>', '}')
    if LINE.endswith(';') == False:
        if LINE.endswith(('{', '}', '(', ')', '[', ']', ',')) == False:
            LINE += ';'

    FILE_NAME = None
    LINES_FROM_INCLUDED_FILE_RAW: list[str] = []*100
    SIMILARITY_FILE: list[str] = []*100
    NEW_LINES_FROM_FILE_RAW: list[str] = LINES_FROM_FILE_RAW.copy()
    IN_STRING = False
    IN_COMMENT = False
    U_LINE_NUMBER = 0
    for i in NEW_LINES_FROM_FILE_RAW:
        for index, j in enumerate(i):
            if IN_COMMENT:
                NEW_LINES_FROM_FILE_RAW[NEW_LINES_FROM_FILE_RAW.index(i)] = ''
                if j == '*' and i[index+1] == '/':
                    IN_COMMENT = False
            if j ==  '"':
                IN_STRING = not IN_STRING
            if not IN_STRING:
                if j == '/' and i[index+1] == '/':
                    NEW_LINES_FROM_FILE_RAW[NEW_LINES_FROM_FILE_RAW.index(i)] = i[:index]
                    break
                elif j == '/' and i[index+1] == '*':
                    IN_COMMENT = True

    if INCLUDES == []*100:
        if MODE is None:
            for _I_ in NEW_LINES_FROM_FILE_RAW:
                if LINE == _I_.strip().replace(' ', ''):
                    U_LINE_NUMBER: int = int(NEW_LINES_FROM_FILE_RAW.index(_I_) + 1)
                    return U_LINE_NUMBER, FILE_NAME

        SIMILARITY: list[float] = []*100
        SIMILAR_LINE: list[int] = []*100

        for __I__ in range(len(NEW_LINES_FROM_FILE_RAW)):
            if len(NEW_LINES_FROM_FILE_RAW[__I__]) == 0:
                continue
            # remove all the spaces from the line
            RATIO: float = APPROXIMATE_LINE(NEW_LINES_FROM_FILE_RAW[__I__].replace(' ', '').strip(), LINE.strip())
            SIMILARITY.append(RATIO)
            SIMILAR_LINE.append(__I__ + 1)

        for __I__ in range(len(SIMILARITY)):
            if SIMILARITY[__I__] == max(SIMILARITY):
                if max(SIMILARITY) < 0.5:
                    if RETURN_TYPE == 1: return int(SIMILAR_LINE[__I__]), FILE_NAME
                    return int(SIMILAR_LINE[__I__]), FILE_NAME
                return int(SIMILAR_LINE[__I__]), FILE_NAME
    else:
        U_LINE_NUMBER = 0
        SIMILARITY: list[float] = []*100
        SIMILAR_LINE: list[int] = []*100
        for _INDEX_, _I_ in enumerate(INCLUDES):
            FILE_NAME = _I_
            LINES_FROM_INCLUDED_FILE_RAW = []*100

            with open(_I_, 'r', encoding='utf-8') as f:
                LINES_FROM_INCLUDED_FILE_RAW = f.readlines()

            for __I__ in range(len(LINES_FROM_INCLUDED_FILE_RAW)):
                if len(LINES_FROM_INCLUDED_FILE_RAW[__I__]) == 0:
                    continue
                # remove all the spaces from the line
                RATIO: float = APPROXIMATE_LINE(LINES_FROM_INCLUDED_FILE_RAW[__I__].replace(' ', '').strip(), LINE.strip())
                SIMILARITY.append(RATIO)
                SIMILAR_LINE.append(__I__ + 1)
                SIMILARITY_FILE.append(_I_)

        for __I__ in range(len(SIMILARITY)):
            if SIMILARITY[__I__] == max(SIMILARITY):
                if max(SIMILARITY) < 0.5:
                    U_LINE_NUMBER = 0
                    break
                U_LINE_NUMBER = int(SIMILAR_LINE[__I__])
                FILE_NAME = SIMILARITY_FILE[__I__]
    return U_LINE_NUMBER, FILE_NAME
def APPROXIMATE_LINE(LINE_1: str, LINE_2: str) -> int:
    """
    \n Compares two strings and returns the similarity percentage.
    \n Input: compare - The string to compare.
    \n        compare_to - The string to compare to.
    \n Output: The similarity percentage. (0.0 - 1.0)
    """
    from difflib import SequenceMatcher
    return SequenceMatcher(None, LINE_1, LINE_2).ratio()
def MAKE_ERROR_CODE(ERROR) -> str:
    if isinstance(ERROR, str) is False:
        ERROR = str(ERROR)
    new_code = '0xE'
    for i in range(0, len(ERROR)):
        new_code += str(hex(ord(ERROR[i]))[2:]).upper()
    return new_code.strip()
def DECODE_ERROR_CODE(ERROR) -> str:
    ERROR = ERROR.replace('0xE', '')
    ERROR = ERROR.lower()
    new_code = ''
    for i in range(0, len(ERROR), 2):
        new_code += chr(int(ERROR[i:i+2], 16))
    return new_code.strip()

# ------------------------ Misc Functions ------------------------ #
@ASYNC
def DUMMY_CALL(*args, **kwargs) -> None:
    """
    \n This function does nothing. It takes any number of arguments and returns nothing.
    """
    return
@ASYNC
def LATCH(ITEM: bool) -> bool:
    """
    \n This function is used to latch a boolean value.
    \n Input: ITEM - The boolean value to latch.
    \n Output: The latched value.
    """
    return not ITEM
@MEMOIZE
def BOX_PRINT(text: str, text_color: str = 'green', box_color: str = 'green') -> None:
    print(f"{COLORS[box_color]}╭{'─'*(TERMINAL_WIDTH-2)}╮{COLORS['reset']}")
    text = wrap(text, TERMINAL_WIDTH-4)
    for line in text:
        print(f"{COLORS[box_color]}│ {COLORS[text_color]}{line}{COLORS[box_color]}{' '*((TERMINAL_WIDTH-len(line))-4)} │{COLORS['reset']}")
    print(f"{COLORS[box_color]}╰{'─'*(TERMINAL_WIDTH-2)}╯{COLORS['reset']}")
def REBUILD_VERSACE_FILE() -> None:
    try:
        import cx_Freeze
    except (ImportError, ModuleNotFoundError):
        print(f"{COLORS['red']}[FATAL]{COLORS['YELLOW']} cx_Freeze is not installed. Please install it using the command: pip install cx_Freeze{COLORS['reset']}")
        exit()
    with open('build.py', 'w', encoding='utf-8') as f:
        # get the name of current file
        from os import path
        f.write(f"""
from cx_Freeze import setup, Executable
from os import remove

base = None
build_exe_options = {{"packages":[ "collections", "contextlib", "subprocess", "re",
                                  "sys", "os", "io", "pickle", "textwrap", "copy",
                                  "functools", "ast", "threading", "tempfile", "time", "types",
                                  "difflib", "string", "random", "rich", "psutil", "platform",
                                  "dataclasses", "typing", "subprocess"
                                ]
                    }}
executables = [Executable("{path.relpath(__file__)}", base=base, target_name = 'Versace', icon='{str(path.relpath(__file__)).replace(str(path.basename(__file__)), 'Icon.ico')}',
                           copyright="Copyright © 2001-2023 Versace Software. All Rights Reserved. Copyright © 2005-2023 Dhruvan Enterprises, Software Division (DESD). All Rights Reserved.")]

setup(name='Versace',
      version = '{VERSION}',
      description = 'Versace Transpiler',
      options={{"build_exe": build_exe_options}},
      executables = executables
)

remove(__file__)
""")
    print(f"{COLORS['green']}Created build.py{COLORS['reset']}")
    print(f"{COLORS['green']}Run '{path.basename(PYTHON_PATH)} build.py build' to build the executable.{COLORS['reset']}")

# ------------------------ Parser/Lexical Analysis Functions ------------------------ #
def PARSER(BALANCE_IN, BALANCE_OUT, MISSING_DECLARATION, LINES_FROM_FILE_RAW_COPY) -> None:
    global FINAL_LIST, INDENTATION_COUNT, STATIC_FOR_CALLS, IN_STATIC_FOR, STATIC_FOR_LINE
    CURRENT_INDENTATION_COUNT: list[int] = []*100
    ADD: bool = False
    TRY: int = 1
    _LINE_LIST_COPY_ = []
    for _INDEX_, _LINE_LIST_ in enumerate(TOKENIZED_LIST):
        _LINE_LIST_COPY_ = _LINE_LIST_.copy()
        INDENTATION_LEVEL = 0
        #print(f"{COLORS['green']}Line {GET_LINE_NUMBER(' '.join(_LINE_LIST_))}: {COLORS['yellow']}{_LINE_LIST_}{COLORS['reset']}")
        #print(f"{str(mode):<7} |" , _INDEX_, '|', *_LINE_LIST_)
        for index_1, j in enumerate(_LINE_LIST_):
            # check if j is in private functions or private classes
            if CHECK_IF_DECLARED(j, _LINE_LIST_[index_1], TYPE=1):
                _LINE_LIST_[index_1] = '__' + _LINE_LIST_[index_1]
            continue
        for index_2, ii in enumerate(_LINE_LIST_):
            for iii in ii:
                if '\"' not in iii:
                    if CHECK_IF_DECLARED(iii, ii, TYPE=0):
                        _LINE_LIST_[index_2] = '__' + _LINE_LIST_[index_2]
        for index, i in enumerate(_LINE_LIST_):
            #if i == '|' and _LINE_LIST_[index + 1] == '|':
            #    FINAL_LIST.append(' '.join(_LINE_LIST_).replace('||', ''))
            if i in GLOBAL_VARIABLES.CHANGE_WORDS:
                _LINE_LIST_[index] = GLOBAL_VARIABLES.CHANGE_WORDS[i]
            if i == '.':
                if _LINE_LIST_[index - 1].isnumeric() is False and _LINE_LIST_[index + 1].isnumeric() is False:
                    ERROR_REPORTING(_LINE_LIST_, 'dotUsed')
            if '::' in i:
                _LINE_LIST_[index] = i.replace('::', '.')

        if _LINE_LIST_[-1] == '++':
            _LINE_LIST_[-1] = '+='
            _LINE_LIST_.append('1')
        elif _LINE_LIST_[-1] == '--':
            _LINE_LIST_[-1] = '-='
            _LINE_LIST_.append('1')
        elif _LINE_LIST_[-1] == '**':
            _LINE_LIST_[-1] = '*='
            if _LINE_LIST_[0] == 'let': _LINE_LIST_.append(_LINE_LIST_[1])
            else: _LINE_LIST_.append(_LINE_LIST_[0])

        if _LINE_LIST_[0] == 'else' and _LINE_LIST_[1] == 'if':
            LINE = TOKENS['else if'](_LINE_LIST_)      # <---------------------------------------------------- USING TOKEN
            if not isinstance(LINE, str): LINE = ''
            FINAL_LIST.append(LINE.replace('<INDENTATIONSEP>', ':').replace('<DEDENTATIONSEP>', ''))
        elif _LINE_LIST_[0] in TOKENS:
            LINE = TOKENS[_LINE_LIST_[0]](_LINE_LIST_) # <---------------------------------------------------- USING TOKEN
            if not isinstance(LINE, str): LINE = ''
            FINAL_LIST.append(LINE.replace('<INDENTATIONSEP>', ':').replace('<DEDENTATIONSEP>', ''))
        else:
            if '=' in _LINE_LIST_:
                for i in MISSING_DECLARATION:
                    if i[0] == _LINE_LIST_[0]:
                        MISSING_DECLARATION.remove(i)
                FOUND: bool = False
                FOUND = True if [__I__ for __I__ in FUNCTIONS if __I__ == _LINE_LIST_[0]] else FOUND
                FOUND = True if [__I__ for __I__ in CLASSES if __I__ == _LINE_LIST_[0]] else FOUND
                FOUND = True if [__I__ for __I__ in KEYWORDS if __I__ == _LINE_LIST_[0]] else FOUND
                if not FOUND:
                    ERROR_REPORTING(_LINE_LIST_, 'InvalidKeyword', _LINE_LIST_[0])
                    FINAL_LIST.append('')
                LINE = SYNTAX_ANALYSIS.__variable__.V_VARIABLE(_LINE_LIST_) # <------------------------------------ USING SYNTAX ANALYSIS
                FINAL_LIST.append(LINE.replace('<INDENTATIONSEP>', ':').replace('<DEDENTATIONSEP>', ''))
            else:
                try:
                    if 'func' == _LINE_LIST_[1] or 'enum' == _LINE_LIST_[1] or 'struct' == _LINE_LIST_[1] or 'async' == _LINE_LIST_[1]:
                        if CHECK_IF_DECLARED(_LINE_LIST_[0], _LINE_LIST_, 11, 'InvalidKeyword') is False:
                            FINAL_LIST.append('')
                        LINE = SYNTAX_ANALYSIS.__variable__.V_VARIABLE(_LINE_LIST_) # <------------------------------------ USING SYNTAX ANALYSIS
                        FINAL_LIST.append(LINE.replace('<INDENTATIONSEP>', ':').replace('<DEDENTATIONSEP>', ''))
                    else:
                        LINE = ' '.join(_LINE_LIST_).replace('<INDENTATIONSEP>', ':').replace('<DEDENTATIONSEP>', '')
                        if not isinstance(LINE, str): LINE = ''
                        FINAL_LIST.append(INDENTATION * INDENTATION_COUNT + LINE)
                except IndexError:
                    LINE = ' '.join(_LINE_LIST_).replace('<INDENTATIONSEP>', ':').replace('<DEDENTATIONSEP>', '')
                    if not isinstance(LINE, str): LINE = ''
                    FINAL_LIST.append(INDENTATION * INDENTATION_COUNT + LINE)



        if len(IN_STATIC_FOR) != 0:
            CURRENT_INDENTATION_COUNT.append(INDENTATION_COUNT) if len(CURRENT_INDENTATION_COUNT) + 1 == STATIC_FOR_CALLS else None

        if '-*- no indent -*-' not in OPTIONAL_ARGS_IN_FILE:
            INDENTATION_LEVEL = 0
            if '<DEDENTATIONSEP>' in _LINE_LIST_:
                # count the number of <DEDENTATIONSEP> in the line
                INDENTATION_LEVEL = _LINE_LIST_.count('<DEDENTATIONSEP>')
                # remove the <DEDENTATIONSEP> from the line
                TOKENIZED_LIST[_INDEX_][TOKENIZED_LIST[_INDEX_].index('<DEDENTATIONSEP>')] = ''
                # subtract the number of <DEDENTATIONSEP> from the INDENTATION_COUNT variable
                INDENTATION_COUNT -= INDENTATION_LEVEL

                for i in range(INDENTATION_LEVEL):
                    _LINE_LIST_COPY_ = ' '.join(_LINE_LIST_COPY_)

                    _LINE_LIST_COPY_ = (_LINE_LIST_COPY_.replace('<DEDENTATIONSEP>', '}'), _LINE_LIST_COPY_.count('<DEDENTATIONSEP>')*'}')
                    BALANCE_IN.insert(0, (_INDEX_, _LINE_LIST_COPY_))
            INDENTATION_LEVEL = 0
            if '<INDENTATIONSEP>' in _LINE_LIST_:
                # count the number of <INDENTATIONSEP> in the line
                INDENTATION_LEVEL = _LINE_LIST_.count('<INDENTATIONSEP>')
                # remove the <INDENTATIONSEP> from the line
                TOKENIZED_LIST[_INDEX_][TOKENIZED_LIST[_INDEX_].index('<INDENTATIONSEP>')] = ':'
                # add the number of <INDENTATIONSEP> to the INDENTATION_COUNT variable
                INDENTATION_COUNT += INDENTATION_LEVEL

                for i in range(INDENTATION_LEVEL):
                    _LINE_LIST_COPY_ = ' '.join(_LINE_LIST_COPY_)
                    _LINE_LIST_COPY_ = (_LINE_LIST_COPY_.replace('<INDENTATIONSEP>', '{'), _LINE_LIST_COPY_.count('<INDENTATIONSEP>')*'{')

                    BALANCE_OUT.insert(0, (_INDEX_, _LINE_LIST_COPY_))
        else: INDENTATION_COUNT = 0
        if len(IN_STATIC_FOR) != 0:
            if INDENTATION_COUNT == CURRENT_INDENTATION_COUNT[-1]:
                if 'main' not in STATIC_FOR_LINE[-1]:
                    FINAL_LIST.append((INDENTATION*(CURRENT_INDENTATION_COUNT[-1] + 1)) + STATIC_FOR_LINE[-1])
                else: FINAL_LIST.append((INDENTATION*(CURRENT_INDENTATION_COUNT[-1])) + STATIC_FOR_LINE[-1])
                if 'return' in STATIC_FOR_LINE[-1]:
                    INDENTATION_COUNT -= 1
                    FINAL_LIST.pop(-1)
                    FINAL_LIST.append((INDENTATION*(CURRENT_INDENTATION_COUNT[-1])) + STATIC_FOR_LINE[-1])
                if 'update' in STATIC_FOR_LINE[-1]:
                    INDENTATION_COUNT -= 1
                    FINAL_LIST.pop(-1)
                    FINAL_LIST.append(STATIC_FOR_LINE[-1])
                CURRENT_INDENTATION_COUNT.pop(-1)
                IN_STATIC_FOR.pop(-1)
                STATIC_FOR_CALLS -= 1
                STATIC_FOR_LINE.pop(-1)

    for index, i in enumerate(FINAL_LIST):
        if '\\:' in i:
            FINAL_LIST[index] = i.replace('\\:', '::')
    return BALANCE_IN, BALANCE_OUT, MISSING_DECLARATION
def LEXICAL_ANALYSIS(mode = None, INCLUDE_LIST=None) -> int:
    global FINAL_LIST, INDENTATION_COUNT, STATIC_FOR_CALLS, IN_STATIC_FOR, STATIC_FOR_LINE
    LINES_FROM_FILE_RAW_COPY: list[str] = deepcopy(LINES_FROM_FILE_RAW)
    if INCLUDE_LIST is None:
        global TOKENIZED_LIST
    else:
        TOKENIZED_LIST = INCLUDE_LIST.copy()
    if IN_INTERPRETED_MODE:
        FINAL_LIST = []*100
    _LINE_LIST_: list[str] = []*100
    DO_NOTHING = False
    IN_MULTI_LINE_COMMENT: bool = False
    """
    This is the code that checks for missing semicolons, its absolutely horrible and needs to be fixed.
    """

    CHARS_DONT_NEED_SEMI_COLON: tuple = ( '{',  '}', '(', '[', ',', '...', '<<')

    for index, i in enumerate(LINES_FROM_FILE_RAW_COPY):
        if IN_MULTI_LINE_COMMENT :
            LINES_FROM_FILE_RAW_COPY[index] = ''
        for index2, j in enumerate(i):
            try:
                if j == '/' and i[index2+1] == '/':
                    LINES_FROM_FILE_RAW_COPY[index] = LINES_FROM_FILE_RAW_COPY[index][:index2]
                    break
                if j == '/' and i[index2+1] == '*':
                    IN_MULTI_LINE_COMMENT = True
                    LINES_FROM_FILE_RAW_COPY[index] = ''
                if j == '*' and i[index2+1] == '/':
                    IN_MULTI_LINE_COMMENT = False
                    LINES_FROM_FILE_RAW_COPY[index] = ''
                if IN_MULTI_LINE_COMMENT :
                    LINES_FROM_FILE_RAW_COPY[index] = ''
                    break
            except IndexError: pass
    LINES_FROM_FILE_RAW_COPY = [i.strip() for i in LINES_FROM_FILE_RAW_COPY if i != '']
    if '-*- no newline -*-' not in OPTIONAL_ARGS_IN_FILE:
        for index, i in enumerate(LINES_FROM_FILE_RAW_COPY):
            i = i.strip()
            if i == '':
                continue
            elif i.endswith(';') is False and i.endswith(CHARS_DONT_NEED_SEMI_COLON) is False:
                # check the line after the current line to see if it starts or ends with CHARS_DONT_NEED_SEMI_COLON skip comments and blank lines

                if i.endswith('~'):
                    continue
                if i.startswith('@') is False: ERROR_REPORTING(i, "MissingSemiColon")
    for _line_ in TOKENIZED_LIST:
        for i in _line_:
            if i.startswith("'") or i.endswith("'"):
                ERROR_REPORTING(_line_, "InvalidDelimiter")
    for _INDEX_, _LINE_ in enumerate(TOKENIZED_LIST):
        # if : ['float', 'a', '=', '5', '.', '5', ';'] then ['float', 'a', '=', '5.5', ';']
        for INDEX, CHAR in enumerate(_LINE_):
            if CHAR == '.':
                if _LINE_[INDEX-1].isnumeric() and _LINE_[INDEX+1].isnumeric():
                    _LINE_[INDEX-1] = _LINE_[INDEX-1] + _LINE_[INDEX] + _LINE_[INDEX+1]
                    _LINE_.pop(INDEX)
                    _LINE_.pop(INDEX)
                    TOKENIZED_LIST[_INDEX_] = _LINE_
                    break
    for _INDEX_, _LINE_ in enumerate(TOKENIZED_LIST):
        if '{' in _LINE_ and '}' in _LINE_:
            DO_NOTHING = True
        else: DO_NOTHING = False
        for INDEX, CHAR in enumerate(_LINE_):
            if CHAR == '{':
                # if { is equal to CHAR then split the list at the index of CHAR
                # example : ['public', 'main', '()', '{', 'out', '<<', '<string>"Hello World!"', '<<', 'endl', ';<newline>', 'out', '<<', '<string>"Press any key to continue..."', '<<', 'endl', ';<newline>', '}']
                # becomes : ['public', 'main', '()', '{'] and ['out', '<<', '<string>"Hello World!"', '<<', 'endl', ';<newline>', 'out', '<<', '<string>"Press any key to continue..."', '<<', 'endl', ';<newline>', '}']
                if DO_NOTHING: continue
                TOKENIZED_LIST[_INDEX_] = _LINE_[:INDEX + 1]
                TOKENIZED_LIST.insert(_INDEX_ + 1, _LINE_[INDEX + 1:])
                break
            elif CHAR == ';<newline>':
                TOKENIZED_LIST[_INDEX_] = _LINE_[:INDEX]
                TOKENIZED_LIST.insert(_INDEX_ + 1, _LINE_[INDEX + 1:])
                break
    for _INDEX_, _LINE_LIST_ in enumerate(TOKENIZED_LIST):
        if '{' in _LINE_LIST_ and '}' in _LINE_LIST_: continue
        if '{' in _LINE_LIST_:
            # example line: ['public', 'main', '()', '{', 'out', '<<', '"Hello World!"', '<<', 'endl!']
            # becomes: ['public', 'main', '()', '<INDENTATIONSEP>', 'out', '<<', '"Hello World!"', '<<', 'endl!']
            TOKENIZED_LIST[_INDEX_].insert(TOKENIZED_LIST[_INDEX_].index('{') + 1, '<INDENTATIONSEP>')
            TOKENIZED_LIST[_INDEX_].remove('{')

        if '}' in _LINE_LIST_:
            # example line: ['public', 'main', '()', '<INDENTATIONSEP>', 'out', '<<', '"Hello World!"', '<<', 'endl!']
            # becomes: ['public', 'main', '()', '<INDENTATIONSEP>', 'out', '<<', '"Hello World!"', '<<', 'endl!', '<DEDENTATIONSEP>']
            TOKENIZED_LIST[_INDEX_].insert(TOKENIZED_LIST[_INDEX_].index('}') + 1, '<DEDENTATIONSEP>')
            TOKENIZED_LIST[_INDEX_].remove('}')

    BALANCE_OUT: list[str] = []*100
    BALANCE_IN: list[str] = []*100
    _INDEX_ = 0
    MISSING_DECLARATION: list[str] = []*100
    for _INDEX_, _LINE_ in enumerate(TOKENIZED_LIST):
        [ERROR_REPORTING(_LINE_, "IllegalChar", CHAR) for INDEX, CHAR in enumerate(_LINE_) if CHAR in GLOBAL_VARIABLES.ILLEGAL_CHARS]
        if '<DEDENTATIONSEP>' == _LINE_[0] or '<INDENTATIONSEP>' == _LINE_[0]:
            continue
        if _LINE_[0] in TOKEN_KEYS or _LINE_[0] in GLOBAL_VARIABLES.DEF_CHARS or _LINE_[0] in tuple(GLOBAL_VARIABLES.CHANGE_WORDS.keys()):
            continue
        if _LINE_[0] in GLOBAL_VARIABLES.ALL_PYTHON_KEYWORDS and ALLOW_PYTHONIC_SYNTAX:
            continue
        #ERROR_REPORTING(_LINE_, "InvalidKeyword")
        MISSING_DECLARATION.append((_LINE_[0], _INDEX_))
        if IN_INTERPRETED_MODE: return "remove"

    BALANCE_IN, BALANCE_OUT, MISSING_DECLARATION = PARSER(BALANCE_IN, BALANCE_OUT, MISSING_DECLARATION, LINES_FROM_FILE_RAW_COPY)

    #if MISSING_DECLARATION:
    #    for i in MISSING_DECLARATION:
    #        # check if the missing declarations are declared now
    #        CHECK_IF_DECLARED(i[0], TOKENIZED_LIST[i[1]], 11, ERROR="InvalidKeyword")
    # Get back if use is found TODO

    if mode == 'include': return FINAL_LIST
    if mode != 'include':
        if '-*- no main -*-' in OPTIONAL_ARGS_IN_FILE:
            pass
        else:
            if PUBLIC_MAIN_FOUND is False and IN_INTERPRETED_MODE is False:
                try:
                    ERROR_REPORTING(FINAL_LIST[1], f"NoMain")
                except IndexError: ERROR_REPORTING('', f"NoMain")
    if INDENTATION_COUNT != 0:
        #print(*BALANCE_OUT, f"{COLORS['red']}Balance IN: {COLORS['reset']}", *BALANCE_IN, INDENTATION_COUNT, sep='\n')
        #exit()
        for index, i in enumerate(TOKENIZED_LIST):
            if index in BALANCE_OUT:
                ERROR_REPORTING(' '.join(i).replace(':', '{', 1), 'NeverClosed')
                continue
    if mode != 'include':
        if ERROR_REPORTING_CALLED:
            if IN_INTERPRETED_MODE: return "remove"
            if '-f' in PASS_LIST: console(FREEZE_COMMAND)
            # exit code for bad transpilation : 1
            # exit with error code
            from sys import exit as _exit
            _exit(1)
        for _INDEX_, _LINE_ in enumerate(FINAL_LIST):
            for index, char in enumerate(_LINE_):
                if char in ascii_letters and char in digits and char in punctuation and char in whitespace: continue
                if char in EMOJI_UNICODE: FINAL_LIST[_INDEX_] = _LINE_.replace(char, EMOJI_UNICODE[char])
        if PUBLIC_CLOSE_FOUND and PUBLIC_MAIN_FOUND:
            FINAL_LIST.append('\nmain({1:"1"}, 321, "str", 1)')
            FINAL_LIST.append('\nclose( "str", 321, {1:"1"}, 1)')
        elif PUBLIC_MAIN_FOUND and not PUBLIC_CLOSE_FOUND:
            FINAL_LIST.append('\nmain({1:"1"}, 321, "str", 1)')
        elif PUBLIC_CLOSE_FOUND and not PUBLIC_MAIN_FOUND:
            FINAL_LIST.append('\nclose( "str", 321, {1:"1"}, 1)')

        # check if there is a difference between the original file data and the data that is going to be written to the file
        if '-c' in PASS_LIST:
            DEFAULT_MODE = {1:__1__, 2:__2__, 3:__3__}
            if BINARY > 3 or BINARY < 1:
                raise UnhandledException(f"The binary mode {BINARY} specified in the config file is not supported. Only (1, 2, 3) are supported.")
            if '-1' in PASS_LIST:
                COMPILER(__1__())
            elif '-2' in PASS_LIST:
                COMPILER(__2__())
            elif '-3' in PASS_LIST:
                COMPILER(__3__())
            else:
                COMPILER(DEFAULT_MODE[BINARY]())
        elif '-t' in PASS_LIST:
            TRANSPILER()
        else:
            EXECUTION()
        if IN_INTERPRETED_MODE:
            FINAL_LIST = []*100
        return 0

# ----------------- Interpreter ----------------- #
def INTERPRETER(CODE=None) -> None:
    global TOKENIZED_LIST, OPTIONAL_ARGS_IN_FILE, IN_INTERPRETED_MODE, LINES, LINES_FROM_FILE_RAW, TERMINAL_WIDTH, FILE_PATH, PASS_LIST
    IN_INTERPRETED_MODE = True
    OPTIONAL_ARGS_IN_FILE.append('-*- no main -*-')
    PREVIOUS_LINES = []
    if FILE_PATH != (VERSACE_PATH + path_sep + 'VINTP.tmp'):
        FILE_PATH = VERSACE_PATH + path_sep + 'VINTP.tmp'
        PASS_LIST[0] = VERSACE_PATH + path_sep + 'VINTP.tmp'
    if not CODE:
        print(f"{COLORS['yellow']}Welcome to the Versace interpreter!{COLORS['reset']}")
        print(f"{COLORS['yellow']}Type {COLORS['red']}\"exit()\"{COLORS['yellow']} to exit the interpreter.{COLORS['reset']}")
        print(f"{COLORS['yellow']}Type {COLORS['red']}\"clear()\"{COLORS['yellow']} to clear the screen.{COLORS['reset']}")
        print(f"{COLORS['yellow']}Type {COLORS['red']}\"help\"{COLORS['yellow']}, {COLORS['red']}\"copyright\"{COLORS['yellow']}, {COLORS['red']}\"credits\"{COLORS['yellow']} or {COLORS['red']}\"license\"{COLORS['yellow']} for more information.{COLORS['reset']}")
    if CODE:
        INDENT_COUNT = 0
        _system("")
        TERMINAL_WIDTH = get_terminal_size().columns
        TOKENIZED_LIST = []
        print(f"{COLORS['green']}> {COLORS['reset']}", end='')
        line = CODE
        if line == 'exit()':
            exit()
        elif line == 'clear()':
            console(CLEAR_SCREEN)
            print(f"{COLORS['yellow']}You are using the Versace interpreter{COLORS['reset']}")
            exit()
        elif line == 'help':
            MISCELLANEOUS().HELP_MENU()
            exit()
        elif line == 'copyright':
            MISCELLANEOUS().COPYRIGHT()
            exit()
        elif line == 'credits':
            MISCELLANEOUS().CREDITS()
            exit()
        elif line == 'license':
            MISCELLANEOUS().LICENSE()
            exit()
        if line.endswith(('{', '(', '[', ',', 'if', 'else', 'while', 'for', 'def', 'class')):
            INDENT_COUNT += 1
            while True:
                try:
                    print(f"{COLORS['green']}. {COLORS['reset']}", end='')
                    line += input().strip()
                    if line.endswith(('{', '(', '[', ',', 'if', 'else', 'while', 'for', 'def', 'class','func','struct', 'enum', '{;', '(;', '[;', ',', 'if;', 'else;', 'while;', 'for;', 'func;', 'def;', 'struct;', 'enum;', 'class;')):
                        INDENT_COUNT += 1
                    if line.endswith(('}', ')', ']', ',', 'if', 'else', 'while', 'for', 'def', 'class', 'func','struct', 'enum', '{;', '(;', '[;', ',', 'if;', 'else;', 'while;', 'for;', 'func;', 'def;', 'struct;', 'enum;', 'class;')):
                        INDENT_COUNT -= 1
                    if INDENT_COUNT == 0:
                        break
                    if INDENT_COUNT < 0:
                        ERROR_REPORTING(line, "NeverClosed")
                        exit()
                except KeyboardInterrupt:
                    break
            if INDENT_COUNT != 0:
                ERROR_REPORTING(line, "NeverClosed")
                exit()
        if len(PREVIOUS_LINES) > 0:
            if line == PREVIOUS_LINES[-1]:
                PREVIOUS_LINES.pop(-1)
        if line.endswith(';') != True:
            if line.endswith(('{', '(', '[', ',', 'if', 'else', 'while', 'for', 'def', 'class', 'func','struct', 'enum', '{;', '(;', '[;', ',', 'if;', 'else;', 'while;', 'for;', 'func;', 'def;', 'struct;', 'enum;', 'class;')) != True or line.endswith(('}', ')', ']', ',', 'if', 'else', 'while', 'for', 'def', 'class', 'func','struct', 'enum', '{;', '(;', '[;', ',', 'if;', 'else;', 'while;', 'for;', 'func;', 'def;', 'struct;', 'enum;', 'class;')) != True:
                ERROR_REPORTING(line, "MissingSemiColon")
                exit()
        PREVIOUS_LINES.append(line)
        LINES = PREVIOUS_LINES.copy()
        LINES_FROM_FILE_RAW = PREVIOUS_LINES.copy()
        if '-d' in PASS_LIST:
            _T_TOKENS_ = TOKENS.copy()
            FOUND_VALID_TOKEN = False
            for token in _T_TOKENS_:
                if line.startswith(token):
                    _T_TOKENS_[token] = "Status 1"
                else:
                    _T_TOKENS_[token] = "Status 0"
            print(f"{COLORS['yellow']}Tokens:{COLORS['reset']}")
            print(f"{COLORS['red']}{{{COLORS['reset']}")
            for token in _T_TOKENS_:
                if _T_TOKENS_[token] == "Status 1":
                    FOUND_VALID_TOKEN = True
                    print(f"    {COLORS['green']}{token}: {COLORS['reset']}Status 1")
                else:
                    print(f"    {COLORS['red']}{token}: {COLORS['reset']}Status 0")
            print(f"{COLORS['red']}}}{COLORS['reset']}")
            if FOUND_VALID_TOKEN is False:
                print(f"{COLORS['red']}No valid matching token found.{COLORS['reset']}")
            else:
                print(f"{COLORS['green']}Valid matching token found.{COLORS['reset']}")
            exit()
        TOKENIZE_FILE()
        if LEXICAL_ANALYSIS() == 'remove':
            PREVIOUS_LINES.pop(-1)
            exit()
    if not CODE:
        while True:
            try:
                INDENT_COUNT = 0
                print(f"{COLORS['green']}▲ ~ {COLORS['reset']}", end='')
                _system("")
                TERMINAL_WIDTH = get_terminal_size().columns
                TOKENIZED_LIST = []*100
                line = input().strip()
                if line == 'exit()':
                    exit()
                elif line == 'clear()':
                    _system(CLEAR_SCREEN)
                    print(f"{COLORS['yellow']}You are using the Versace interpreter{COLORS['reset']}")
                    continue
                elif line == 'help':
                    MISCELLANEOUS().HELP_MENU()
                    continue
                elif line == 'copyright':
                    MISCELLANEOUS().COPYRIGHT()
                    continue
                elif line == 'credits':
                    MISCELLANEOUS().CREDITS()
                    continue
                elif line == 'license':
                    MISCELLANEOUS().LICENSE()
                    continue
                if line.endswith(('{', '(', '[', ',', 'if', 'else', 'while', 'for', 'class')):
                    INDENT_COUNT += 1
                    while True:
                        try:
                            print(f"{COLORS['green']}▲ . {COLORS['reset']}", end='')
                            line += input().strip()
                            if line.endswith(('{', '(', '[', ',', 'if', 'else',
                                              'while', 'for', 'class','func','struct',
                                              'enum', '{;', '(;', '[;', ',', 'if;',
                                              'else;', 'while;', 'for;', 'func;',
                                              'struct;', 'enum;', 'class;')):
                                INDENT_COUNT += 1

                            if line.endswith(('}', ')', ']', ',', 'if', 'else',
                                              'while', 'for', 'class', 'func','struct',
                                              'enum', '{;', '(;', '[;', ',', 'if;',
                                              'else;', 'while;', 'for;', 'func;',
                                              'struct;', 'enum;', 'class;')):
                                INDENT_COUNT -= 1
                            if INDENT_COUNT == 0:
                                break
                            if INDENT_COUNT < 0:
                                ERROR_REPORTING(line, "NeverClosed")
                                continue
                        except KeyboardInterrupt:
                            break
                    if INDENT_COUNT != 0:
                        ERROR_REPORTING(line, "NeverClosed")
                        continue
                if len(PREVIOUS_LINES) > 0:
                    if line == PREVIOUS_LINES[-1]:
                        PREVIOUS_LINES.pop(-1)
                if line.endswith(';') != True:
                    if line.endswith(('{', '(', '[', ',', '}', ')', ']',
                                      '};', '];', ');', ',', 'if', '\f',
                                      'while', 'for', 'class', 'func', '\v'
                                      'enum', '{;', '(;', '[;', '\n', '\t',
                                      'struct;', 'enum;', 'class;','\r',
                                      'if;', 'else;', 'while;', 'for;',
                                      'struct', 'func;', 'else')) != True or line != '':
                        # print the raw line, with anything that was passed, eg: \n shows as \n instead of a new line
                        try:
                            ERROR_REPORTING(line, "MissingSemiColon", LINE_NO=0)
                        except Exception: pass
                        continue

                PREVIOUS_LINES.append(line)
                LINES = PREVIOUS_LINES.copy()
                LINES_FROM_FILE_RAW = PREVIOUS_LINES.copy()

                if '-d' in PASS_LIST:
                    _T_TOKENS_ = TOKENS.copy()
                    FOUND_VALID_TOKEN = False
                    for token in _T_TOKENS_:
                        if line.startswith(token):
                            _T_TOKENS_[token] = "Status 1"
                        else:
                            _T_TOKENS_[token] = "Status 0"
                    print(f"{COLORS['yellow']}Tokens:{COLORS['reset']}")
                    print(f"{COLORS['red']}{{{COLORS['reset']}")
                    for token in _T_TOKENS_:
                        if _T_TOKENS_[token] == "Status 1":
                            FOUND_VALID_TOKEN = True
                            print(f"    {COLORS['green']}{token}: {COLORS['reset']}Status 1")
                        else:
                            print(f"    {COLORS['red']}{token}: {COLORS['reset']}Status 0")
                    print(f"{COLORS['red']}}}{COLORS['reset']}")
                    if FOUND_VALID_TOKEN is False:
                        print(f"{COLORS['red']}No valid matching token found.{COLORS['reset']}")
                    else:
                        print(f"{COLORS['green']}Valid matching token found.{COLORS['reset']}")
                    continue
                TOKENIZE_FILE()
                if LEXICAL_ANALYSIS() == 'remove':
                    PREVIOUS_LINES.pop(-1)
                    continue
            except KeyboardInterrupt:
                print(f'{COLORS["red"]}To exit the interpreter, type "exit()"{COLORS["reset"]}')

# ----------------- Compiler Related Functions ----------------- #
@OVERLOAD(__1__)
def COMPILER(type: __1__) -> None:
    global FINAL_LIST, PASS_LIST, IN_COMPILING, COMPILE_SAVE_PATH
    if SYSTEM.path_exists(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled") is False:
        SYSTEM.make_dirs(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled")
    TEMP_FILE = VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + f'{path.basename(FILE_PATH).split(".")[0]}.tmp'
    PASS_LIST.pop(0)
    PASS_LIST.remove('-c')
    PASS_LIST.remove('-1') if '-1' in PASS_LIST else PASS_LIST
    PASS_LIST.pop(0)
    for i in PASS_LIST:
        if '.' in i:
            TEMP_FILE = i
            break
    else:
        TEMP_FILE = VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + f'{path.basename(TEMP_FILE).split(".")[0]}.tmp'

    print(PASS_LIST, TEMP_FILE)

    if '.' not in TEMP_FILE:
        TEMP_FILE += EXE_FILE_TYPE
    if SYSTEM.get_c_dir() not in TEMP_FILE and ':' not in TEMP_FILE:
        TEMP_FILE = SYSTEM.get_c_dir() + path_sep + TEMP_FILE
    COMPILE_SAVE_PATH = TEMP_FILE
    with open(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + f'{path.basename(TEMP_FILE).split(".")[0]}.tmp', 'w', encoding="utf-8") as f:
        f.write(VERSACE_BOILERPLATE().replace("with open(__file__, \'r\') as f:\n" + f"{INDENTATION*1}THIS_FILE_DATA = f.readlines()\n", "THIS_FILE_DATA=['coding', 'GENERATED', 'Versace, https, Ze7111']\n") + '\n')
        f.write('\n'.join(FINAL_LIST))

    print(f"{COLORS['red']}Is this a window or console application? (w/c) : {COLORS['reset']}", end='')
    WC_TYPE = input().lower().strip()

    print(f"{COLORS['red']}Enter icon path (leave blank if you do not want to use an icon): {COLORS['reset']}", end='')
    ICON = input().strip().replace("\'", '\"')

    if ICON.strip() != '':
        ICON = f'--icon {ICON}' if '\"' in ICON else f'--icon "{ICON}"'
    else:
        ICON = f'--icon "{VERSACE_PATH}{path_sep}base{path_sep}icon.ico"'

    if WC_TYPE == 'w':
        WC_TYPE = '--windowed'
    else:
        WC_TYPE = '--console'

    FINAL_COMMAND: list[str] = ["pyinstaller", "--noconfirm", "--onefile", f'{WC_TYPE}', f"{ICON}", TEMP_FILE.replace(SYSTEM.get_c_dir() + path_sep, '')]
    FINAL_COMMAND = [str(i) for i in FINAL_COMMAND if i != '']

    TIME_IT = get_time()
    EXECUTE_COMPILE_COMMAND(FINAL_COMMAND, MODE=2)
    IN_COMPILING = True
    COUNT: int = 0
    print(f"{COLORS['green']}\nVersace Compiler Version: {VERSION}")
    while True:
        if LOADING_IN_PROGRESS:
            print(f"{COLORS['red']}Compiling {COUNT} [{COLORS['red']}{'━'*COUNT}{COLORS['red']}]{COLORS['reset']}", end='\r')
            wait(0.5)
            COUNT += 1
        else:
            TIME_IT = round(get_time() - TIME_IT, 3)
            break

    IN_COMPILING = False

    print(f"{COLORS['red']}Compiling {COUNT} [{COLORS['green']}{'━'*COUNT}{COLORS['red']}]{COLORS['reset']}")
    print(f"{COLORS['red']}  Compilation completed in {COLORS['green']}{TIME_IT}{COLORS['red']} seconds. Using Optimizer: {COLORS['green']}One File (1){COLORS['reset']}")

    remove(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + path.basename(TEMP_FILE).split('.')[0] + ".tmp")
    rmtree(SYSTEM.get_c_dir() + path_sep + "build" + path_sep + path.basename(TEMP_FILE).split('.')[0])

    for i in listdir(SYSTEM.get_c_dir() + path_sep + "dist"):
        move(SYSTEM.get_c_dir() + path_sep + "dist" + path_sep + i, SYSTEM.get_c_dir() + path_sep + i)

    if len(listdir(SYSTEM.get_c_dir() + path_sep + "dist")) == 0:
        rmtree(SYSTEM.get_c_dir() + path_sep + "dist")
    if len(listdir(SYSTEM.get_c_dir() + path_sep + "build")) == 0:
        rmtree(SYSTEM.get_c_dir() + path_sep + "build")
    if len(listdir(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled")) == 0:
        rmtree(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled")

    for i in listdir(SYSTEM.get_c_dir()):
        if i.endswith('.spec'):
            remove(i)
@OVERLOAD(__2__)
def COMPILER(type: __2__) -> None:
    global FINAL_LIST, PASS_LIST, IN_COMPILING, COMPILE_SAVE_PATH
    if SYSTEM.path_exists(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled") is False:
        SYSTEM.make_dirs(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled")
    TEMP_FILE = VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + f'{path.basename(FILE_PATH).split(".")[0]}.tmp'
    PASS_LIST.remove(FILE_PATH)
    PASS_LIST.remove('-c')
    PASS_LIST.remove('-2') if '-2' in PASS_LIST else PASS_LIST
    PASS_LIST.pop(0)
    for i in PASS_LIST:
        if '.' in i:
            TEMP_FILE = i
            break
    else:
        TEMP_FILE = path.basename(FILE_PATH).split('.')[0]
    if '.' not in TEMP_FILE:
        TEMP_FILE += EXE_FILE_TYPE
    if SYSTEM.get_c_dir() not in TEMP_FILE and ':' not in TEMP_FILE:
        TEMP_FILE = SYSTEM.get_c_dir() + path_sep + TEMP_FILE
    COMPILE_SAVE_PATH = TEMP_FILE
    with open(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + f'{path.basename(TEMP_FILE).split(".")[0]}.tmp', 'w', encoding="utf-8") as f:
        f.write(VERSACE_BOILERPLATE().replace("with open(__file__, \'r\') as f:\n" + f"{INDENTATION*1}THIS_FILE_DATA = f.readlines()\n", "THIS_FILE_DATA=['coding', 'GENERATED', 'Versace, https, Ze7111']\n") + '\n')
        f.write('\n'.join(FINAL_LIST))

    print(f"{COLORS['red']}Is this a window or console application? (w/c) : {COLORS['reset']}", end='')
    WC_TYPE = input().lower().strip()

    print(f"{COLORS['red']}Enter icon path (leave blank if you do not want to use an icon): {COLORS['reset']}", end='')
    ICON = input().strip().replace("\'", '\"')

    if ICON.strip() != '':
        ICON = f'--icon {ICON}' if '\"' in ICON else f'--icon "{ICON}"'
    else:
        ICON = f'--icon "{SYSTEM.get_user_dir()}{path_sep}.versace{path_sep}base{path_sep}icon.ico"'

    if WC_TYPE == 'w':
        WC_TYPE = '--windowed'
    else:
        WC_TYPE = '--console'

    FINAL_COMMAND: list[str] = ["pyinstaller", "--noconfirm", "--onedir", f'{WC_TYPE}', f"{ICON}", TEMP_FILE.replace(SYSTEM.get_c_dir() + path_sep, '')]
    FINAL_COMMAND = [str(i) for i in FINAL_COMMAND if i != '']

    TIME_IT = get_time()
    EXECUTE_COMPILE_COMMAND(FINAL_COMMAND, MODE=2)
    IN_COMPILING = True
    COUNT: int = 0
    print(f"{COLORS['green']}\nVersace Compiler Version: {VERSION}")
    while True:
        if LOADING_IN_PROGRESS:
            print(f"{COLORS['red']}Compiling {COUNT} [{COLORS['red']}{'━'*COUNT}{COLORS['red']}]{COLORS['reset']}", end='\r')
            wait(0.5)
            COUNT += 1
        else:
            TIME_IT = round(get_time() - TIME_IT, 3)
            break

    IN_COMPILING = False

    print(f"{COLORS['red']}Compiling {COUNT} [{COLORS['green']}{'━'*COUNT}{COLORS['red']}]{COLORS['reset']}")
    print(f"{COLORS['red']}  Compilation took {COLORS['green']}{TIME_IT}{COLORS['red']} seconds. Using Optimizer: {COLORS['green']}One Directory (2){COLORS['reset']}")

    remove(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + path.basename(TEMP_FILE).split('.')[0] + ".tmp")
    rmtree(SYSTEM.get_c_dir() + path_sep + "build" + path_sep + path.basename(TEMP_FILE).split('.')[0])

    for i in listdir(SYSTEM.get_c_dir() + path_sep + "dist"):
        move(SYSTEM.get_c_dir() + path_sep + "dist" + path_sep + i, SYSTEM.get_c_dir() + path_sep + i)

    if len(listdir(SYSTEM.get_c_dir() + path_sep + "dist")) == 0:
        rmtree(SYSTEM.get_c_dir() + path_sep + "dist")
    if len(listdir(SYSTEM.get_c_dir() + path_sep + "build")) == 0:
        rmtree(SYSTEM.get_c_dir() + path_sep + "build")
    if len(listdir(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled")) == 0:
        rmtree(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled")

    for i in listdir(SYSTEM.get_c_dir()):
        if i.endswith('.spec'):
            remove(i)
@OVERLOAD(__3__)
def COMPILER(type: __3__) -> None:
    print(f"{COLORS['red']}This optimization level is broken (i am working on a fix), do you want to continue (y/n): {COLORS['reset']}", end='')
    CONTINUE = input().lower().strip()
    if CONTINUE != 'y':
        return
    global FINAL_LIST, PASS_LIST, IN_COMPILING, COMPILE_SAVE_PATH
    if SYSTEM.path_exists(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled") is False:
        SYSTEM.make_dirs(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled")
    TEMP_FILE = VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + f'{path.basename(FILE_PATH).split(".")[0]}.tmp'
    PASS_LIST.remove(FILE_PATH)
    PASS_LIST.remove('-c')
    PASS_LIST.remove('-3') if '-3' in PASS_LIST else PASS_LIST
    PASS_LIST.pop(0)
    for i in PASS_LIST:
        if '.' in i:
            TEMP_FILE = i
            break
    else:
        TEMP_FILE = path.basename(FILE_PATH).split('.')[0]
    if '.' not in TEMP_FILE:
        TEMP_FILE += EXE_FILE_TYPE
    if SYSTEM.get_c_dir() not in TEMP_FILE and ':' not in TEMP_FILE:
        TEMP_FILE = SYSTEM.get_c_dir() + path_sep + TEMP_FILE
    COMPILE_SAVE_PATH = TEMP_FILE
    with open(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + f'{path.basename(TEMP_FILE).split(".")[0]}.tmp', 'w', encoding="utf-8") as f:
        f.write(VERSACE_BOILERPLATE().replace("with open(__file__, \'r\') as f:\n" + f"{INDENTATION*1}THIS_FILE_DATA = f.readlines()\n", "THIS_FILE_DATA=['coding', 'GENERATED', 'Versace, https, Ze7111']\n") + '\n')
        f.write('\n'.join(FINAL_LIST))

    print(f"{COLORS['red']}Is this a window or console application? (w/c) : {COLORS['reset']}", end='')
    WC_TYPE = input().lower().strip()

    print(f"{COLORS['red']}Enter icon path (leave blank if you do not want to use an icon): {COLORS['reset']}", end='')
    ICON = input().strip().replace("\'", "").replace('\"', "")

    print(f"{COLORS['red']}Enter version of the application (1.0.0): {COLORS['reset']}", end='')
    VERSION = input().strip().replace("\'", "").replace('\"', "")

    print(f"{COLORS['red']}Enter description of the application (leave blank if you do not want to use a description): {COLORS['reset']}", end='')
    DESCRIPTION = input().strip().replace("\'", "").replace('\"', "")

    if ICON.strip() != '':
        ICON = f'{ICON}'
    else:
        ICON = f'{VERSACE_PATH}{path_sep}base{path_sep}icon.ico'

    if WC_TYPE.strip() == 'w':
        WC_TYPE = 'base=None\nif platform == \"win32\":\n\tbase=\"Win32GUI\"'
    else:
        WC_TYPE = 'base=None'

    if VERSION.strip() == '':
        VERSION = '1.0.0'

    if DESCRIPTION.strip() == '':
        DESCRIPTION = 'None'

    CX_FREEZE_DATA: list = [
        "from cx_Freeze import setup, Executable; import sys, os",
        f"{WC_TYPE}",
        f"executables = [Executable(r\"{TEMP_FILE}\", base=base, target_name=r\"{path.basename(TEMP_FILE).split('.')[0]}\", icon=r\"{ICON}\")]",
        f"setup(name=r\"{path.basename(TEMP_FILE).split('.')[0]}\", version=r\"{VERSION}\", description=r\"{DESCRIPTION}\", executables=executables)"
    ]

    CX_FREEZE_FILE = VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + 'setup.py'
    with open(CX_FREEZE_FILE, 'w', encoding="utf-8") as f:
        f.write('\n'.join(CX_FREEZE_DATA))
    print(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + 'setup.py')
    FINAL_COMMAND = [ORG_PYTHON_PATH, f"\"{CX_FREEZE_FILE}\"", "build"]
    FINAL_COMMAND = [str(i) for i in FINAL_COMMAND if i != '']
    TIME_IT = get_time()
    EXECUTE_COMPILE_COMMAND(FINAL_COMMAND, MODE=2)
    IN_COMPILING = True
    COUNT: int = 0
    print(f"{COLORS['green']}\nVersace Compiler Version: {VERSION}")
    while True:
        if LOADING_IN_PROGRESS:
            print(f"{COLORS['red']}Compiling {COUNT} [{COLORS['red']}{'━'*COUNT}{COLORS['red']}]{COLORS['reset']}", end='\r')
            wait(0.5)
            COUNT += 1
        else:
            TIME_IT = round(get_time() - TIME_IT, 3)
            break

    IN_COMPILING = False

    print(f"{COLORS['red']}Compiling {COUNT} [{COLORS['green']}{'━'*COUNT}{COLORS['red']}]{COLORS['reset']}")
    print(f"{COLORS['red']}  Compilation took {COLORS['green']}{TIME_IT}{COLORS['red']} seconds. Using Optimizer: {COLORS['green']}Max Optimized (3){COLORS['reset']}")

    remove(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + path.basename(TEMP_FILE).split('.')[0] + ".tmp")
@ASYNC
def EXECUTE_COMPILE_COMMAND(FINAL_COMMAND, MODE) -> None:
    global LOADING_IN_PROGRESS
    if MODE == 3: exit()
    if LOADING_IN_PROGRESS is False:
        LOADING_IN_PROGRESS = True
        execute_no_output(' '.join(FINAL_COMMAND), stdout=DEVNULL, stderr=STDOUT)
        LOADING_IN_PROGRESS = False
    return 0

# ------------------ Transpiler Related Functions ------------------ #
def TRANSPILER() -> None:
    global FINAL_LIST, PASS_LIST
    _system("")
    try:
        SAVE_PATH = PASS_LIST[PASS_LIST.index('-t') + 1]
    except IndexError:
        raise UnhandledException("No path specified for the transpiled file.")
    PASS_LIST.remove('-t')
    if '.' not in SAVE_PATH:
        SAVE_PATH += '.py'
    if SYSTEM.get_c_dir() not in SAVE_PATH:
        SAVE_PATH = SYSTEM.get_c_dir() + path_sep + SAVE_PATH
    with open(SAVE_PATH, 'w', encoding="utf-8") as f:
        f.write(VERSACE_BOILERPLATE() + '\n')
        f.write('\n'.join(FINAL_LIST))
    BOX_PRINT(f"Transpiled {path.basename(FILE_PATH)} to {SAVE_PATH}", 'green', 'green')

# ------------------- Runtime Related Functions ------------------- #
def EXECUTION() -> None:
    global print
    if '-py' in PASS_LIST:
        PASS_LIST.remove('-py')
    # Import the NamedTemporaryFile and gettempdir functions from the tempfile module
    EXEC_PATH = f'{VERSACE_PATH}{path_sep}temp{path_sep}{path.basename(FILE_PATH)}.py'
    if SYSTEM.path_exists(f'{VERSACE_PATH}{path_sep}temp') is False:
        SYSTEM.make_dirs(f'{VERSACE_PATH}{path_sep}temp')
    with open(EXEC_PATH, 'w', encoding="utf-8") as f:
        f.write('v_print = print\n')
        f.write(VERSACE_BOILERPLATE() + '\n')
        f.write('\n'.join(FINAL_LIST))
        f.write('\nprint = v_print')
        f.write('\nsys.exit(0)') #if '-no-py' not in PASS_LIST else None
        f.close()
    if '-no-py' in PASS_LIST and '-ast' not in PASS_LIST:
        from ast import parse
        _system("")
        if not SYSTEM.path_exists(EXEC_PATH):
            with open(EXEC_PATH, 'w', encoding="utf-8") as f:
                f.write(VERSACE_BOILERPLATE() + '\n')
                f.write('\n'.join(FINAL_LIST))
                f.close()
        with open(EXEC_PATH, 'r', encoding="utf-8") as f:
            tree = parse(f.read())
            compiled = compile(tree, EXEC_PATH, 'exec')
            try:
                def isolated_process():
                    from subprocess import Popen, PIPE
                    p = Popen([ORG_PYTHON_PATH, EXEC_PATH], stdout=PIPE, stderr=PIPE)
                    out, err = p.communicate() 
                    return out.decode('utf-8'), err.decode('utf-8')
                out, err = isolated_process()
                if err:
                    errors = str(err)
                    errors = errors.splitlines()
                    # invert the dict
                    INVERTED_DICT = {v: k for k, v in GLOBAL_VARIABLES.CHANGE_WORDS.items()}
                    error_line = errors[-3].strip()
                    #print(error_line)
                    SequenceMatch: dict[float, str] = {}
                    for i in open(__file__, 'r', encoding="utf-8").readlines():
                        from difflib import SequenceMatcher
                        SequenceMatch[SequenceMatcher(None, i.strip(), error_line).ratio()] = i.strip()
                    # sort SequenceMatch from highest to lowest
                    SequenceMatch = {k: v for k, v in sorted(SequenceMatch.items(), key=lambda item: item[0], reverse=True)}
                    try:
                        if SequenceMatch[list(SequenceMatch.values())[0]] > 0.6:
                            raise Exception(err)
                    except (KeyError, IndexError): pass
                    for value in INVERTED_DICT:
                        if value in error_line:
                            error_line = error_line.replace(value, INVERTED_DICT[value])
                    error_line = GET_LINE_NUMBER(error_line, MODE='error')
                    error_line_text = LINES_FROM_FILE_RAW[error_line-1].strip() if isinstance(error_line, int) else errors[-3].strip() + ' (Could not locate the exact line)'
                    ERROR_REPORTING(error_line_text, errors[-1][errors[-1].find(':')+1:].strip(), errors[-2][4:], errors[-1][:errors[-1].find(':')+1], DEBUG_LINE=errors[-3].strip(), DEBUG_FILE=errors[0].strip())
                    exit(1)
                print(out)
                
            except Exception as e:
                raise VersaceCodeBaseError("unknown issue\nError Code: 52")
            except KeyboardInterrupt:
                print(f"{COLORS['red']}Keyboard Interrupt Detected (ctrl+c){COLORS['reset']}")
                exit(1)
            except SystemExit:
                pass
        _system(f"")
    elif '-ast' in PASS_LIST:
        with open(EXEC_PATH, 'w', encoding="utf-8") as f:
            f.write('\n'.join(FINAL_LIST))
            f.close()
        SECURE_EXECUTION([PYTHON_PATH, EXEC_PATH])
    else:
        SECURE_EXECUTION([PYTHON_PATH, EXEC_PATH])
    return


@EXEC_TIME
def SECURE_EXECUTION(command: list) -> None:
    if SYSTEM.path_exists(f'{VERSACE_PATH}{path_sep}temp{path_sep}error.txt'):
        remove(f'{VERSACE_PATH}{path_sep}temp{path_sep}error.txt')
    error_file = open(f'{VERSACE_PATH}{path_sep}temp{path_sep}error.txt', 'w+', encoding="utf-8")
    error_file.write('')
    try:
        # get all errors from the execution
        if '-ast' in PASS_LIST:
            from ast import parse, dump
            import astpretty
            if '-all' in PASS_LIST:
                command.insert(1, '-m'); command.insert(2, 'dis')
                execute(command, stderr=error_file, check=False)
            else:
                from ast import parse
                tree = parse('\n'.join(FINAL_LIST))
                for subtree in range(len(tree.body) - 2):
                    astpretty.pprint(tree.body[subtree], show_offsets=False, indent=INDENTATION)
            exit(0)
        try:
            execute(command, stderr=error_file, check=False)
        except KeyboardInterrupt: UnhandledException("Keyboard Interrupt Detected (Ctrl+C)")
        errors = error_file.read()
        if errors != '':
            errors = errors.splitlines()
            # invert the dict
            INVERTED_DICT = {v: k for k, v in GLOBAL_VARIABLES.CHANGE_WORDS.items()}
            error_line = errors[-3].strip()
            for value in INVERTED_DICT:
                if value in error_line:
                    error_line = error_line.replace(value, INVERTED_DICT[value])
            error_line = GET_LINE_NUMBER(error_line, MODE='error')
            error_line_text = LINES_FROM_FILE_RAW[error_line-1].strip() if isinstance(error_line, int) else errors[-3].strip() + ' (Could not locate the exact line)'
            ERROR_REPORTING(error_line_text, errors[-1][errors[-1].find(':')+1:].strip(), errors[-2][4:], errors[-1][:errors[-1].find(':')+1], DEBUG_LINE=errors[-3].strip(), DEBUG_FILE=errors[0].strip())
            exit(1)
        error_file.close()
        return
    except FileNotFoundError:
        if '-d' in PASS_LIST:
            from rich.console import Console
            console = Console()
            console.print_exception(show_locals=True, width=TERMINAL_WIDTH)
        raise UnhandledException('Execution failed, this could be caused by one or more of the following errors:\n\t- Python Path provided in the Config file is invalid.\n\t- Versace could not locate the transpiled file to execute.\n\t- The Cache File is corrupted.')
    finally:
        error_file.close()
        return

# --------------------- Startup --------------------- #
def INITIALIZER() -> None:
    global LOADING_IN_PROGRESS
    from os import system as os_system
    """
    This function is the main function of the program.
    It runs all the other functions and does all the other stuff.
    """
    #GEN_NEW_SYNTAX_HIGHLIGHTING_DATA() # uncomment this line to generate new syntax highlighting data, ONLY USE THIS IF YOU CHANGED THE TOKENS
    #DECODE_ERROR_CODE("0xE1242") # uncomment this line to decode an error code
    try:
        #CHECK IF INITIALIZE_NEW_PROJECT RETURNS A VALUE AND IF 'new' in PASS_LIST or '--new' in PASS_LIST AND ONLY THEN SHALL FILE_PATH BE SET TO THE RETURN VALUE
        INITIALIZE()
        READ_SYS_ARGS()
        INITIALIZE_CHECKS()
        INNIT_DATA_COLLECTOR(FILE_PATH)
        CHECK_ARGS(FILE_PATH)
        mode = OPEN_FILE(FILE_PATH)
        if mode == "Empty":
            os_system("") if WINDOWS else None
            print(COLORS["reset"], end="") if not COLOR_MODULE else None
            if '-f' in PASS_LIST:
                console(FREEZE_COMMAND)
                exit()
            if '-d' in PASS_LIST:
                COLLECT_DATA()
                SHOW_DEBUG_DATA()
                DUMP_DATA()
            del globals()['INITIALIZE']
            del globals()['READ_SYS_ARGS']
            del globals()['INITIALIZE_CHECKS']
            del globals()['INNIT_DATA_COLLECTOR']
            del globals()['CHECK_ARGS']
            del globals()['OPEN_FILE']
            del globals()['COLLECT_DATA']
            del globals()['SHOW_DEBUG_DATA']
            del globals()['DUMP_DATA']
            return
        del mode
        TOKENIZE_FILE()
        LEXICAL_ANALYSIS()
        if '-d' in PASS_LIST:
            COLLECT_DATA()
            SHOW_DEBUG_DATA()
            DUMP_DATA()
    except KeyboardInterrupt:
        LOADING_IN_PROGRESS = False
        UnhandledException("Keyboard Interrupt Detected.", no_exit=True)
    except Exception as e:
        LOADING_IN_PROGRESS = False
        os_system("") if WINDOWS else None
        # print the full traceback
        if '-d' in PASS_LIST:
            from rich.console import Console as RichConsole
            r_console = RichConsole()
            r_console.print_exception(show_locals=True, width=TERMINAL_WIDTH)
        else:
            print(f"{COLORS['red']}Unhandled Internal Exception: {e}, use --debug/-d to see the full internal error.{COLORS['reset']}")
    finally:
        LOADING_IN_PROGRESS = False
        os_system("") if WINDOWS else None
        if IN_COMPILING:
            remove(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled" + path_sep + path.basename(COMPILE_SAVE_PATH).split('.')[0] + ".tmp")
            rmtree(SYSTEM.get_c_dir() + path_sep + "build" + path_sep + path.basename(COMPILE_SAVE_PATH).split('.')[0])
            # q: regex to detect full line that starts with remove( or rmtree( and ends with )
            # a: remove\((.+)\)

            for i in listdir(SYSTEM.get_c_dir() + path_sep + "dist"):
                move(SYSTEM.get_c_dir() + path_sep + "dist" + path_sep + i, SYSTEM.get_c_dir() + path_sep + i)

            if len(listdir(SYSTEM.get_c_dir() + path_sep + "dist")) == 0:
                rmtree(SYSTEM.get_c_dir() + path_sep + "dist")
            if len(listdir(SYSTEM.get_c_dir() + path_sep + "build")) == 0:
                rmtree(SYSTEM.get_c_dir() + path_sep + "build")
            if len(listdir(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled")) == 0:
                rmtree(VERSACE_PATH + path_sep + 'temp' + path_sep + "compiled")
            for i in listdir(SYSTEM.get_c_dir()):
                if i.endswith('.spec'):
                    remove(i)

        print('\r', COLORS["reset"], '\r', end="") if not COLOR_MODULE else None

        if '-f' in PASS_LIST:
            console(FREEZE_COMMAND)
            exit()
        return

if '--test' in PASS_LIST:
    TEST_MODE()

# --------------------- Check if Imported or Running Directly --------------------- #
if __name__ == "__main__":
    if ('--profile' in PASS_LIST and '--all' in PASS_LIST) or ('-p' in PASS_LIST and '-all' in PASS_LIST) or ('--profile' in PASS_LIST and '-all' in PASS_LIST):
        from cProfile import run as cProfileRun
        cProfileRun('INITIALIZER()', sort='time')
        exit()
    INITIALIZER()
else:
    import sys
    def _VS(code):
        execute(f"{sys.executable} {__file__} -i \"{code}\"", shell=True, check=False)
