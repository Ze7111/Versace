# -*- coding: utf-8 -*-
# THIS FILE WAS GENERATED BY VERSACE 4.0.1
# Versace can be found here: "https://github.com/Ze7111/Verscae-Programing-language/"
# Versace Documentation can be found here: "https://dhruvan.gitbook.io/vs/"

# pylint: disable=E1101
# how to use type annotations: https://www.python.org/dev/peps/pep-0484/

__doc__ = """ ---------------- This is in Markdown format ----------------
----------------------------------------------------------------------------------------------------------------------------------
# Execution Model (Versace)
-------------------------
1. Tokenize
2. Parse
3. Transpile
4. Execute/Compile/Translate

## Tokenize
--------
### The tokenizer in versace is different from most other languages.
It works by reading all the code from the file as one continous string without leading/trailing whitespace.
it then reads each character, and if it a part of the alphabet, it will read the next character until it is not unless it starts with (").
it will then merge all the newly read characters into one token(list), and repeat the process until it reaches the end of the file.
It will also look for (;) and if it finds one, it will split that token into two tokens with the first one being the token before the (;) and the second one being the token after the (;).
Finally it will make a nested list of all the tokens, and then move on to the next step.
#### Example of a line getting tokenized:
```
int a = 1;

Stage 1: ['i', 'n', 't', 'a', '=', '1', ';']
Stage 2: [['int', 'a', '=', '1', ';']]
```
- Result: [['int', 'a', '=', '1']]
#### Example of multiple lines getting tokenized:
```
int a = 1;
str b = "hello world";

Stage 1: ['i', 'n', 't', 'a', '=', '1', ';', 's', 't', 'r', 'b', '=', '"', 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd', '"', ';']
Stage 2: [['int', 'a', '=', '1', ';', 'str', 'b', '=', '"hello world"', ';']]
```
- Result: [['int', 'a', '=', '1'], ['str', 'b', '=', '"hello world"']]

Parse
-----
### The parser in versace is different from most other languages.
It will always check the first word in the token list, and if it is a keyword,
if it is a keyword it will then send that token list to the function that handles that keyword.
if it is not a keyword it will then check if a class with that name exists, and if not it will throw an error.
#### Example of a token getting parsed:
```
['int', 'a', '=', '1']

Stage 1: keyword = 'int'
Stage 2: boolean (does 'int' exist in the keywords list) = True
Stage 3: send token list to the function that handles the 'int' keyword
```
- Result: a: int = 1 (with type checking)

#### Example of multiple tokens getting parsed:
```
[['int', 'a', '=', '1'], ['str', 'b', '=', '"hello world"']]

Stage 1: keyword = 'int'
Stage 2: boolean (does 'int' exist in the keywords list) = True
Stage 3: send token list to the function that handles the 'int' keyword
```
- Result: a: int = 1 (with type checking)

```
Stage 1: keyword = 'str'
Stage 2: boolean (does 'str' exist in the keywords list) = True
Stage 3: send token list to the function that handles the 'str' keyword
```
- Result: b: str = "hello world" (with type checking)

## Parse Tree:
### All the keywords currently in versace:
1. `public`
1. `priv`
1. `method`
1. `with`
1. `call`
1. `if`
1. `else`
1. `else if`
1. `for`
1. `while`
1. `return`
1. `class`
1. `struct`
1. `static`
1. `enum`
1. `func`
1. `async`
1. `await`
1. `coroutine`
1. `const`
1. `ref`
1. `let`
1. `final`
1. `out`
1. `in`
1. `include`
1. `import`
1. `from`
1. `pyc`
1. `@`
1. `int`
1. `float`
1. `complex`
1. `double`
1. `str`
1. `usize`
1. `bool`
1. `list`
1. `map`
1. `array`
1. `set`
1. `bytes`
1. `char`
1. `memoryview`
1. `bytearray`
1. `frozenset`
1. `range`
1. `None`
1. `NoneType`
1. `u8`
1. `u16`
1. `u32`
1. `u64`
1. `u128`
1. `i8`
1. `i16`
1. `i32`
1. `i64`
1. `i128`
1. `f32`
1. `f64`

## Transpile
---------
### The transpiler in versace is different from most other languages.
It will work by taking the parse tree and converting it into a string of python code.
It will then write that string to a file and then run it using the python interpreter.
#### Example of a parse tree getting transpiled:
```
a: int = 1
Stage 1: check if 'a' is a variable, if yes throw an error as we tried to declare a variable that already exists without using the `let` keyword
Stage 2: check if 'a' is a variable, if no, check if '1' matches the type of 'int'
Stage 3: check if '1' is a variable, if yes, get the type of '1' and check if it matches the type of 'int'
Stage 4: repeat stage 3 until it reaches the end of the parse tree
```

- Result: a: int = 1 # the : int means we are declaring a variable with the type of int, and not assigning a already existing variable
    
## Execute/Compile/Translate
-------------------------
### The execution stage in versace is different from most other languages.
It will work by taking the transpiled code and running it using the python interpreter (with the extra lines in the code, to make it execute a lot faster).
It will securly run the code using the python interpreter, and then print the output (Versace uses `subprocess` to run the code on any platform, and uses `_winapi` to run the code on windows).
The code will be run in a seperate process, and will not be able to access any program in the main process (unless specified).

### The compiler stage in versace is different from most other languages.
The Versace compiler uses `pyinstaller` to compile the code into a .exe file. Or cx_freeze to compile the code into a .exe file.
The compiler takes the transpiled code and executes a `pyinstaller/cx_freeze` command in a seperate process (hence why you see a loading bar and not the raw output of the command).
If the complation is successful, it will then move the .exe file to the directory of the versace file.
If the complation is not successful, it will then print the error message and delete any files that were created during the complation process.

### The translator stage works in the following way.
It will save the transpiled code to a file.

----------------------------------------------------------------------------------------------------------------------------------

This is the Soruce code for the Versace programming language.
This code does kinda not follow PEP8, but it is still readable and understandable.
A lot of code is not commented, but it is still understandable.
Most functions and classes have docstrings.

For more information about Versace, please visit the Versace documentation at
https://dhruvan.gitbook.io/vs/

RSTAB: TYPE-ANNOTATIONS USED IN THIS FILE
"""

__VERSION__: str = '4.0.1'
__ALLOW_PYTHONIC_SYNTAX__: bool = True  # do not change this, unless you know exactly what you are doing.

def __GET_OS__() -> str and bool:
    """Get the operating system"""
    try:
        import msvcrt
        __WINDOWS__ = True
        __OS__ = 'nt' # noqa: F841
        del msvcrt
    except ImportError:
        __WINDOWS__ = False
        __OS__ = 'posix'
    return (__WINDOWS__, __OS__)
__WINDOWS__, __OS__ = __GET_OS__()

import _winapi
from sys import exit
from re import search
from io import StringIO
from pickle import dumps
from time import strftime
from textwrap import wrap
from random import choice
from copy import deepcopy
from functools import wraps
from ast import literal_eval
from threading import Thread
from time import perf_counter
from time import sleep as wait
from tempfile import gettempdir
from os import get_terminal_size
from os import stat as temp_stat
from emojis import EMOJI_UNICODE
from time import time as get_time
from types import MappingProxyType
from collections import OrderedDict
from sys import path as __SYS_PATH__
from subprocess import run as execute
from contextlib import redirect_stdout
from sys import executable as __PYTHON_PATH__
from sys import stdout, argv, setrecursionlimit
from ctypes import windll, create_unicode_buffer
from subprocess import call as execute_no_output
from subprocess import check_call, DEVNULL, STDOUT
from string import ascii_letters, digits, punctuation, whitespace
_winapi.WaitForSingleObject = lambda handle, timeout: _winapi.WaitForMultipleObjects((handle,), 0, timeout)

if __WINDOWS__:
    class _CImplementaiton:
        """
        This class remakes, most of the slower items implemented by the os, sys module to work much quicker.
        This class is only used on windows.
        Sub-classes:
            error : raise an error
            enable_color : enable color in the console
            console : call the windows console with a command
            std_out : print to the console
            path_exists : check if a path exists
            get_file_size : get the size of a file
            base_name : get the base name of a path
            join_path : join two paths
            list_dir : list the files in a directory
            get_user_dir : get the user directory
            make_dirs : make a directory
            del_file : delete a file
            del_dir_and_files : delete a directory and all of its files
            make_dir : make a directory
            change_dir : change the current directory
            get_c_dir : get the current directory
            move_file : move a file

        """
        sep = str('\\')
        path_exists_cache = dict()
        get_file_size_cache = dict()
        get_user_dir_cache = str()
        get_c_dir_cache = str()
        std_out_cache = dict()
        list_dir_cache = dict()
        absolute_path_cache = dict()
        base_name_cache = dict()
        join_path_cache = dict()
        setrecursionlimit(100000)
        def error(self, error_type: str, message: str):
            self.enable_color()
            print(f"\033[1;31m{error_type}: " + message + "\033[0m")
            exit()
        def __init__(self, *args, **kwargs):
            self.args = args
            self.kwargs = kwargs
        def enable_color(self) -> None:
            windll.kernel32.SetConsoleMode(windll.kernel32.GetStdHandle(-11), 7)
        def console(self, command: str) -> None:
            # create a custom console function for windows
            # call the windows console with the command
            if command == '': self.enable_color(); return
            buff: object = create_unicode_buffer(300)
            windll.kernel32.GetEnvironmentVariableW('COMSPEC', buff, 300)
            command = f"{buff.value} /c {command}"
            windll.kernel32.WinExec(command, 1)
        def std_out(self, string: str, end: str = '\n', n_py_flush: bool = False) -> None:
            if str(string) in self.std_out_cache:
                stdout.write(self.std_out_cache[string] + end)
                return
            self.std_out_cache[str(string)] = str(string)
            if n_py_flush:
                stdout.flush()
            stdout.write(str(string) + end)
        def path_exists(self, NON_SYS_PATH: str) -> bool:
            if NON_SYS_PATH in self.path_exists_cache:
                return self.path_exists_cache[NON_SYS_PATH]
            if windll.kernel32.GetFileAttributesW(NON_SYS_PATH) == -1:
                self.path_exists_cache[NON_SYS_PATH] = False
                return False
            else:
                self.path_exists_cache[NON_SYS_PATH] = True
                return True
        def get_file_size(self, NON_SYS_PATH: str) -> int:
            if NON_SYS_PATH in self.get_file_size_cache:
                return self.get_file_size_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                buf: object = create_unicode_buffer(300)
                windll.kernel32.GetFullPathNameW(NON_SYS_PATH, 300, buf, None)
                NON_SYS_PATH = buf.value
                size: int = temp_stat(NON_SYS_PATH).st_size
                self.get_file_size_cache[NON_SYS_PATH] = size
                return size
            else:
                self.error("FileNotFoundError", f"File not found: {NON_SYS_PATH}")
        def absolute_path(self, NON_SYS_PATH: str) -> str:
            if NON_SYS_PATH in self.absolute_path_cache:
                return self.absolute_path_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                buf: object = create_unicode_buffer(300)
                windll.kernel32.GetFullPathNameW(NON_SYS_PATH, 300, buf, None)
                NON_SYS_PATH = buf.value
                self.absolute_path_cache[NON_SYS_PATH] = NON_SYS_PATH
                return NON_SYS_PATH
            else:
                self.error("FileNotFoundError", f"File not found: {NON_SYS_PATH}")
        def base_name(self, NON_SYS_PATH: str) -> str:
            if NON_SYS_PATH in self.base_name_cache:
                return self.base_name_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                buf: object = create_unicode_buffer(300)
                windll.kernel32.GetFullPathNameW(NON_SYS_PATH, 300, buf, None)
                NON_SYS_PATH = buf.value
                self.base_name_cache[NON_SYS_PATH] = NON_SYS_PATH.split('\\')[-1]
                return NON_SYS_PATH.split('\\')[-1]
            else:
                self.error("FileNotFoundError", f"File not found: {NON_SYS_PATH}")
        def join_path(self, *args) -> str:
            if args in self.join_path_cache:
                return self.join_path_cache[args]
            self.join_path_cache[args] = self.sep.join(args)
            return self.sep.join(args)
        def list_dir(self, NON_SYS_PATH: str) -> list:
            if NON_SYS_PATH in self.list_dir_cache:
                return self.list_dir_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                buf: object = create_unicode_buffer(300)
                windll.kernel32.GetFullPathNameW(NON_SYS_PATH, 300, buf, None)
                NON_SYS_PATH = buf.value
                self.list_dir_cache[NON_SYS_PATH] = [f for f in NON_SYS_PATH.split('\\') if f != '']
                return [f for f in NON_SYS_PATH.split('\\') if f != '']
            else:
                self.error("FileNotFoundError", f"Directory not found: {NON_SYS_PATH}")
        def get_user_dir(self) -> str:
            if self.get_user_dir_cache != '':
                return self.get_user_dir_cache
            buf: object = create_unicode_buffer(300)
            windll.shell32.SHGetFolderPathW(None, 5, None, 0, buf)
            self.get_user_dir_cache = self.sep.join((buf.value.split(self.sep)[:-1]))
            return self.sep.join((buf.value.split(self.sep)[:-1]))
        def make_dirs(self, NON_SYS_PATH: str, exist_ok: bool = False) -> None:
            if not self.path_exists(NON_SYS_PATH):
                windll.kernel32.CreateDirectoryW(NON_SYS_PATH, None)
            else:
                if exist_ok:
                    return
                self.error("FileExistsError", f"File or directory already exists: {NON_SYS_PATH}")
            return
        def del_file(self, NON_SYS_PATH: str) -> None:
            if self.path_exists(NON_SYS_PATH):
                windll.kernel32.DeleteFileW(NON_SYS_PATH)
            return
        def del_dir_and_files(self, NON_SYS_PATH: str) -> None:
            if self.path_exists(NON_SYS_PATH):
                windll.kernel32.RemoveDirectoryW(NON_SYS_PATH)
            return
        def make_dir(self, NON_SYS_PATH: str, exist_ok: bool = False) -> None:
            if not self.path_exists(NON_SYS_PATH):
                windll.kernel32.CreateDirectoryW(NON_SYS_PATH, None)
            else:
                if exist_ok:
                    return
                self.error("FileExistsError", f"File or directory already exists: {NON_SYS_PATH}")
            return
        def change_dir(self, NON_SYS_PATH: str) -> None:
            if self.path_exists(NON_SYS_PATH):
                windll.kernel32.SetCurrentDirectoryW(NON_SYS_PATH)
            return
        def get_c_dir(self) -> str:
            if self.get_c_dir_cache != '':
                return self.get_c_dir_cache
            buf: object = create_unicode_buffer(300)
            windll.kernel32.GetCurrentDirectoryW(300, buf)
            self.get_c_dir_cache = buf.value
            return buf.value
        def move_file(self, src: str, dst: str) -> None:
            if self.path_exists(src):
                windll.kernel32.MoveFileW(src, dst)
            return
else:
    import os; import shutil
    class _CImplementaiton:
        __doc__ = """
        This class remakes, most of the slower items implemented by the os, sys module to work much quicker.
        This class is only used on Linux/MacOS.
        Sub-classes:
            error : raise an error
            enable_color : enable color in the console
            console : call the windows console with a command
            std_out : print to the console
            path_exists : check if a path exists
            get_file_size : get the size of a file
            base_name : get the base name of a path
            join_path : join two paths
            list_dir : list the files in a directory
            get_user_dir : get the user directory
            make_dirs : make a directory
            del_file : delete a file
            del_dir_and_files : delete a directory and all of its files
            make_dir : make a directory
            change_dir : change the current directory
            get_c_dir : get the current directory
            move_file : move a file

        """
        sep: str = '/'
        get_file_size_cache: dict = {}
        absolute_path_cache: dict = {}
        base_name_cache: dict = {}
        join_path_cache: dict = {}
        list_dir_cache: dict = {}
        get_user_dir_cache: str = ''
        get_c_dir_cache: str = ''
        setrecursionlimit(100000)
        def error(self, error_type: str, message: str):
            self.enable_color()
            print(f"\033[1;31m{error_type}: " + message + "\033[0m")
            exit()
        def enable_color(self) -> None:
            os.system('')
        def path_exists(self, NON_SYS_PATH: str) -> bool:
            return os.NON_SYS_PATH.exists(NON_SYS_PATH)
        def get_file_size(self, NON_SYS_PATH: str) -> int:
            if NON_SYS_PATH in self.get_file_size_cache:
                return self.get_file_size_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                size: int = os.stat(NON_SYS_PATH).st_size
                self.get_file_size_cache[NON_SYS_PATH] = size
                return size
            else:
                self.error("FileNotFoundError", f"File not found: {NON_SYS_PATH}")
        def console(self, text: str) -> None:
            os.system(text)
            return
        def make_dirs(self, NON_SYS_PATH: str, exist_ok: bool = False) -> None:
            if not self.path_exists(NON_SYS_PATH):
                os.makedirs(NON_SYS_PATH)
            else:
                if exist_ok:
                    return
                self.error("FileExistsError", f"File or directory already exists: {NON_SYS_PATH}")
            return
        def absolute_path(self, NON_SYS_PATH: str) -> str:
            if NON_SYS_PATH in self.absolute_path_cache:
                return self.absolute_path_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                NON_SYS_PATH = os.NON_SYS_PATH.abspath(NON_SYS_PATH)
                self.absolute_path_cache[NON_SYS_PATH] = NON_SYS_PATH
                return NON_SYS_PATH
            else:
                self.error("FileNotFoundError", f"File not found: {NON_SYS_PATH}")
        def base_name(self, NON_SYS_PATH: str) -> str:
            if NON_SYS_PATH in self.base_name_cache:
                return self.base_name_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                NON_SYS_PATH = os.NON_SYS_PATH.basename(NON_SYS_PATH)
                self.base_name_cache[NON_SYS_PATH] = NON_SYS_PATH
                return NON_SYS_PATH
            else:
                self.error("FileNotFoundError", f"File not found: {NON_SYS_PATH}")
        def join_path(self, *args) -> str:
            if args in self.join_path_cache:
                return self.join_path_cache[args]
            self.join_path_cache[args] = self.sep.join(args)
            return self.sep.join(args)
        def list_dir(self, NON_SYS_PATH: str) -> list:
            if NON_SYS_PATH in self.list_dir_cache:
                return self.list_dir_cache[NON_SYS_PATH]
            if self.path_exists(NON_SYS_PATH):
                NON_SYS_PATH = os.listdir(NON_SYS_PATH)
                self.list_dir_cache[NON_SYS_PATH] = NON_SYS_PATH
                return NON_SYS_PATH
            else:
                self.error("FileNotFoundError", f"Directory not found: {NON_SYS_PATH}")
        def get_user_dir(self) -> str:
            if self.get_user_dir_cache != '':
                return self.get_user_dir_cache
            self.get_user_dir_cache = os.NON_SYS_PATH.expanduser("~")
            return os.NON_SYS_PATH.expanduser("~")
        def get_c_dir(self) -> str:
            if self.get_c_dir_cache != '':
                return self.get_c_dir_cache
            self.get_c_dir_cache = os.getcwd()
            return os.getcwd()
        def change_dir(self, NON_SYS_PATH: str) -> None:
            if self.path_exists(NON_SYS_PATH):
                os.chdir(NON_SYS_PATH)
            return
        def make_dir(self, NON_SYS_PATH: str, exist_ok: bool = False) -> None:
            if not self.path_exists(NON_SYS_PATH):
                os.mkdir(NON_SYS_PATH)
            else:
                if exist_ok:
                    return
                self.error("FileExistsError", f"File or directory already exists: {NON_SYS_PATH}")
            return
        def del_file(self, NON_SYS_PATH: str) -> None:
            if self.path_exists(NON_SYS_PATH):
                os.remove(NON_SYS_PATH)
            return
        def std_out(self, *args, **kwargs) -> None:
            print(*args, **kwargs)
            return
        def move_file(self, src: str, dst: str) -> None:
            if self.path_exists(src):
                os.rename(src, dst)
            return
        def del_dir_and_files(self, NON_SYS_PATH: str) -> None:
            if self.path_exists(NON_SYS_PATH):
                shutil.rmtree(NON_SYS_PATH)

__SYSTEM__: object = _CImplementaiton()

path_sep: object = __SYSTEM__.sep
def remove(NON_SYS_PATH: str) -> None:
    __SYSTEM__.del_file(NON_SYS_PATH)
def stat(NON_SYS_PATH: str) -> int:
    return __SYSTEM__.get_file_size(NON_SYS_PATH)
def print(*args, **kwargs):
    args = list(args)
    for arg in args:
        if isinstance(arg, str) == False:
            args[args.index(arg)] = str(arg)
    args = tuple(args)
    __SYSTEM__.std_out(*args, **kwargs)
    return
def console(*args, **kwargs):
    __SYSTEM__.console(*args, **kwargs)
    return
def listdir(NON_SYS_PATH: str) -> list:
    return __SYSTEM__.list_dir(NON_SYS_PATH)
def rmtree(NON_SYS_PATH: str) -> None:
    __SYSTEM__.del_dir_and_files(NON_SYS_PATH)
def move(src: str, dst: str) -> None:
    __SYSTEM__.move_file(src, dst)
class path:
    abspath: object = __SYSTEM__.absolute_path
    basename: object = __SYSTEM__.base_name
    join: object = __SYSTEM__.join_path
if __SYSTEM__.path_exists(__SYSTEM__.get_user_dir() + path_sep + "Versace" + path_sep + "ABS-Path.path"):
    with open(__SYSTEM__.get_user_dir() + path_sep + "Versace" + path_sep + "ABS-Path.path", "rb") as f:
        __ORG_PYTHON_PATH__ = f.readlines()[1].decode("utf-32-le").strip()
else:
    execute(["python", __SYSTEM__.get_user_dir() + path_sep + "Versace" + path_sep + "ABS-Path.py"], stdout=DEVNULL, stderr=STDOUT, check=True)
    if __SYSTEM__.path_exists(__SYSTEM__.get_user_dir() + path_sep + "Versace" + path_sep + "ABS-Path.path") is False:
        execute(["python3", __SYSTEM__.get_user_dir() + path_sep + "Versace" + path_sep + "ABS-Path.py"], stdout=DEVNULL, stderr=STDOUT, check=True)
        if __SYSTEM__.path_exists(__SYSTEM__.get_user_dir() + path_sep + "Versace" + path_sep + "ABS-Path.path") is False:
            print(f"ERROR: ABS-Path.rf not found. Please reinstall Versace. Or run this file manually: \"{__SYSTEM__.get_user_dir() + path_sep + 'Versace' + path_sep + 'ABS-Path.py'}\"")
            exit()
    if __SYSTEM__.path_exists(__SYSTEM__.get_user_dir() + path_sep + "Versace" + path_sep + "ABS-Path.path"):
        with open(__SYSTEM__.get_user_dir() + path_sep + "Versace" + path_sep + "ABS-Path.path", "rb") as f:
            __ORG_PYTHON_PATH__ = f.readlines()[1].decode("utf-32-le").strip()

__PYTHON_PATH__: str = __ORG_PYTHON_PATH__
_MAP_: MappingProxyType = MappingProxyType
__PASS_LIST__ = argv.copy()
__DEBUG_DATA__: list[str] = []
base_print = print
print = base_print
# q: what are all symbols allowed in python? eg: *, @, #
# a: https://docs.python.org/3/reference/lexical_analysis.html#identifiers
class __GLOBAL_VARIABLES__():
    __doc__ = """
    This class is used to store global variables used by Versace.
    """
    __ALL_PYTHON_KEYWORDS__: tuple[str, ...] = (
        'return',
        'break',
        'continue',
        'pass',
        'from',
        'nonlocal',
        'lambda',
        'try',
        'finally',
        'assert',
        'with',
        'yield',
        'in',
        'is',
        'not',
        'and',
        'or',
        'True',
        'False',
        'None',
        'async',
        'await',
        'from',
        'nonlocal',
        'self',
        'super',
        'cls',
    )
    __KEYWORDS_NEED_INDENTATION__: tuple[str, ...] = (
        'if',
        'else if',
        'else',
        'for',
        'while',
        'func',
        'public',
        'async',
        'try',
        'catch',
        'finally',
        'class',

        # python keywords that need indentation
        'except',
        'with',
        '{',
        '}',
        '(',
        ')',
        '[',
        ']',
        ',',
        '/*',
        '*/',
    )
    __NON_NORMAL_CHARS__: tuple[str, ...] = (
        ' ' ,
        '@' ,
        '#' ,
        '$' ,
        '%' ,
        '^' ,
        '&' ,
        '*' ,
        '!' ,
        '(' ,
        ')' ,
        '-' ,
        '+' ,
        '=' ,
        '[' ,
        ']' ,
        '{' ,
        '}' ,
        ';' ,
        ':' ,
        ',' ,
        '.' ,
        '<' ,
        '>' ,
        '/' ,
        '?' ,
        '`' ,
        '~' ,
        '|' ,
        '\\',
    )
    __DATA_TYPES__: tuple[str, ...] = (
        'array',
        'arr',
        'int',
        'float',
        'complex',
        'double',
        'str',
        'usize',
        'bool',
        'list',
        'map',
        'tuple',
        'set',
        'bytes',
        'char',
        'memoryview',
        'bytearray',
        'frozenset',
        'range',
        'nullType',
    )
    __END_TYPES__: MappingProxyType[str, str] = _MAP_(
        {
            'newl' : r'\n\n',
            'tab' : r'\t',
            'rw' : r'\r',
            'space' : r' ',
            'endl' : r'',
            'erase' : r'\x1b[2K',
        }
    )
    __JUSTIFY_TYPES__: tuple[str, ...] = (
        'left',
        'right',
        'center',
        'justify',
    )
    __COLOR_TYPES__: tuple[str, ...] = (
    # primitive colors
        'red',
        'green',
        'yellow',
        'blue',
        'magenta',
        'cyan',
        'white',
        'black',
        'bold red',
        'bold green',
        'bold yellow',
        'bold blue',
        'bold magenta',
        'bold cyan',
        'bold white',
        'bold black',
        'bright_red',
        'bright_green',
        'bright_yellow',
        'bright_blue',
        'bright_magenta',
        'bright_cyan',
        'bright_white',
        'bright_black',
    )
    __STYLE_TYPES__: tuple[str, ...] = (
        'bold',
        'dim',
        'italic',
        'underline',
        'blink',
        'reverse',
        'hidden',
        'strike',
    )
    __RESERVED_WORDS__: tuple[str, ...] = (
        'if',
        'else if',
        'else',
        'for',
        'while',
        'func',
        'public',
        'async',
        'try',
        'catch',
        'finally',
        'class',
        'include',
        'from',
        'const',
        'out',
        'in',
        'stop',
        'throw',
        'null',
        'True',
        'static',
        'self',
        'super',
        'struct',
        'enum',
        'False',
        'set',
        'frozenset',
        'map',
        'list',
        'tuple',
        'pack',
        'unpack',
        'range',
        'bytearray',
        'memoryview',
        'bytes',
        'char',
        'str',
        'double',
        'complex',
        'float',
        'int',
        'bool',
        'usize',
        'array',
        'arr',
        'nullType',
        'print',
        'input',
        'pyc',
        'exec',
        'alloc',
        'free',
        'exit',
    )
    __OPTIANAL_ARGS_ALLOWED__: tuple[str, str, str, str, str, str, str, str, str] = (
        r'-*- no types -*-',
        r'-*- no color -*-',
        r'-*- no indent -*-',
        r'-*- no main -*-',
        r'-*- no newline -*-',
        r'-*- py -*-',
        r'-*- cache -*-',
        r'-*- exec -*-',
        r'-*- all errors -*-',
    )
    __CHANGE_WORDS__: MappingProxyType[str, str] = _MAP_(
        {
            'null'     : 'None',
            'true'     : 'True',
            'false'    : 'False',
            'nullType' : 'NoneType',
            'catch'    : 'except',
            'throw'    : 'raise',
            'NULL'     : 'None',
            'NULLTYPE' : 'NoneType',
            'NONE'     : 'None',
            'NONETYPE' : 'NoneType',
            '~'        : '*',
            '~~'       : '**',
            'invert'   : 'reversed',
            'rem'      : 'del',
            'double'   : 'float',
            'char'     : 'str',
            '&&'       : 'and',
            '||'       : 'or',
            'repr'     : '__init__',
        }
    )
    __OPPRATORS__: tuple[str, ...] = (
        '<',
        '>',
        '=',
        '!',
        '+',
        '-',
        '*',
        '/',
        '%',
        '^',
        '&',
        '|',
        '>>',
        '<<',
        '**',
        ':',
    )
    __DEF_CHARS__: tuple[str, ...] = (
        '(',
        ')',
        '[',
        ']',
        '{',
        '}',
        ',',
        ':',
        ';',
        '.',
        '@',
        '_',
        '<',
        '>',
        '=',
        '!',
        '+',
        '-',
        '*',
        '/',
        '%',
        '^',
        '&',
        '|',
        '>=',
        '==',
        '!=',
        '+=',
        '-=',
        '*=',
        '/=',
        '%=',
        '^=',
        '&=',
        '|=',
    )
    __ILLIGAL_CHARS__: tuple[str, ...] = (
        '\\',
        '`',
        '!',
        '?',
        '$',
        '#',
        '@=',
    )
    __PYTHON_TO_VERSACE__: MappingProxyType[str, str] = _MAP_(
        {
            'def'       : 'func',
            'elif'      : 'else if',
            'print'     : 'out',
            'input'     : 'in',
            '+= 1'      : '++',
            '-= 1'      : '--',
            '*'         : '~',
            '**'        : '~~',
            'TaskGroup' : 'coroutine',
            '@_async'   : 'async',
            'raise'     : 'throw',
            'except'    : 'catch',
        }
    )
    __OPRATOR_OVERLOADS__: MappingProxyType[str, str] = _MAP_(
        {
            '-='  : '__isub__',
            '+='  : '__iadd__',
            '*='  : '__imul__',
            '/='  : '__idiv__',
            '//=' : '__ifloordiv__',
            '%='  : '__imod__',
            '**=' : '__ipow__',
            '>>=' : '__irshift__',
            '<<=' : '__ilshift__',
            '&='  : '__iand__',
            '|='  : '__ior__',
            '^='  : '__ixor__',
            '<'   : '__lt__',
            '>'   : '__gt__',
            '<='  : '__le__',
            '>='  : '__ge__',
            '=='  : '__eq__',
            '!='  : '__ne__',
            '+'   : '__add__',
            '–'   : '__sub__',
            '-'   : '__sub__',
            '*'   : '__mul__',
            '/'   : '__truediv__',
            '//'  : '__floordiv_',
            '%'   : '__mod__',
            '**'  : '__pow__',
            '>>'  : '__rshift__',
            '<<'  : '__lshift__',
            '&'   : '__and__',
            '|'   : '__or__',
            '^'   : '__xor__',
        }
    )
    __STRING_TYPES__: tuple[str, ...] = (
         "r", "u", "R", "U", "f", "F", "fr", "Fr", "fR", "FR", "rf", "rF",
         "Rf", "RF", "b", "B", "br", "Br", "bR", "BR", "rb", "rB", "Rb", "RB"
    )
    __BLANK_DATA__: MappingProxyType[str, str] = _MAP_(
        {
            'str'           : "''",
            'int'           : '0',
            'float'         : '0.0',
            'bool'          : 'False',
            'list'          : '[NULL]',
            'tuple'         : '(NULL)',
            'dict'          : '{}',
            'set'           : 'set()',
            'frozenset'     : 'frozenset()',
            'complex'       : '0j',
            'bytes'         : 'b""',
            'bytearray'     : 'bytearray()',
            'None'          : 'None',
        }
    )
__BINARY__: int = 1
__FILE_PATH__: str = ''
__LINES__: list[str] = []
__INDENTATION__: str = ''
__VERSACE_PATH__: str = ''
__EXECUTNG__: bool = False
__USE_CACHE__: bool = False
__MAX_INCLUDES__: int = 100
__LIB_ADDED__: bool = False
__TRACEBACK_LIMIT__: int = 0
__BINARY_FILE_EXT__: str = ''
__STATIC_FOR_CALLS__: int = 0
__RECURSIVE_CYCLES__: int = 0
__NO_INCLUDES__: bool = False
__IN_COMPILING__: bool = False
__ALLOW_UPDATE__: bool = False
__FINAL_LIST__: list[str] = []
__INDENTATION_LEVEL__: int = 0
__INDENTATION_COUNT__: int = 0
__COMPILE_SAVE_PATH__: str = ''
__NO_ARGS_START__: bool = False
__ALLOW_TRACKING__: bool = False
__KEEP_PERF_DATA__: bool = False
__TRANSPILE_FILE_EXT__: str = ''
__CLASSES__: dict[str, dict] = {}
__IN_STATIC_FOR__: list[bool] = []
__NO_VERSION_CHECK__: bool = False
__TOKENIZED_LIST__: list[list] = []
__EXTRA_INDENTATION__: bool = False
__PUBLIC_INIT_FOUND__: bool = False
__VARIABLES__: dict[str, dict] = {}
__FUNCTIONS__: dict[str, dict] = {}
__STATIC_FOR_LINE__: list[str] = []
__PRE_SPLIT_LIST__: list[list] = []
__OVERLOAD_FUNCTION_REG__: dict = {}
__PUBLIC_CLOSE_FOUND__: bool = False
__PUBLIC_UPDATE_FOUND__: bool = False
__IN_INTREPRETED_MODE__: bool = False
__LINES_FROM_FILE_RAW__: list[str] = []
__ERROR_REPORTING_CALLED__: bool = False
__OPTIANAL_ARGS_IN_FILE__: list[str] = []
__ALWAYS_MONITOR_PERF_DATA__: bool = False
__CURRENT_YEAR__: int = int(strftime("%Y"))
__TERMINAL_WIDTH__: int = get_terminal_size().columns
__CLEAR_SCREEN__: str = 'cls' if __WINDOWS__ else 'clear'
__EXE_FILE_TYPE__: str = '.exe' if __WINDOWS__ else '.out'
__COLOR_SUPPORT__ = stdout.isatty()
__FREEZE_COMMAND__: str = 'pause' if __WINDOWS__ else 'read -p \'Press Enter to continue...\' var'

__COLORS__: MappingProxyType[str, str] = _MAP_ \
    (
        {
        'bold red' : '\033[1;31m' if __COLOR_SUPPORT__ else '',
        'bold green' : '\033[1;32m' if __COLOR_SUPPORT__ else '',
        'bold yellow' : '\033[1;33m' if __COLOR_SUPPORT__ else '',
        'bold blue' : '\033[1;34m' if __COLOR_SUPPORT__ else '',
        'bold magenta' : '\033[1;35m' if __COLOR_SUPPORT__ else '',
        'bold cyan' : '\033[1;36m' if __COLOR_SUPPORT__ else '',
        'bold white' : '\033[1;37m' if __COLOR_SUPPORT__ else '',

        'red' : '\033[91m' if __COLOR_SUPPORT__ else '',
        'green' : '\033[92m' if __COLOR_SUPPORT__ else '',
        'yellow' : '\033[93m' if __COLOR_SUPPORT__ else '',
        'blue' : '\033[94m' if __COLOR_SUPPORT__ else '',
        'magenta' : '\033[95m' if __COLOR_SUPPORT__ else '',
        'cyan' : '\033[96m' if __COLOR_SUPPORT__ else '',
        'white' : '\033[97m' if __COLOR_SUPPORT__ else '',
        'grey' : '\033[90m' if __COLOR_SUPPORT__ else '',

        'underline' : '\033[4m' if __COLOR_SUPPORT__ else '',
        'italic' : '\033[3m' if __COLOR_SUPPORT__ else '',
        'blink' : '\033[5m' if __COLOR_SUPPORT__ else '',
        'reverse' : '\033[7m' if __COLOR_SUPPORT__ else '',
        'reset' : '\033[0m' if __COLOR_SUPPORT__ else '',
        }
    )

class VersaceCodeBaseError(Exception):
    __doc__ = """This is raised when there is a error in the Versace Code Base"""
    __slots__ = ('message')
    def __init__(self, message):
        print("\033[1;31mVersaceError: " + message + "\033[0m")
        exit()
class NotImplementedYet(Exception):
    __doc__ = """
    \n This class is used to raise an error when there is no main function
    """
    __slots__ = ('__ERROR_WORD__', '__LINE__')
    def __init__(self, __ERROR_WORD__: str) -> exit:
        console("")
        print(f'{__COLORS__["bold red"]}Not Implemented Yet: {__COLORS__["yellow"]}{__ERROR_WORD__}{__COLORS__["reset"]}')
        exit()
    @staticmethod
    def MATCH_FIRST(__LINE__: list, __ERROR_WORD__: str) -> exit:
        console("")
        if isinstance(__LINE__, str) == False:
            __LINE__ = ' '.join(__LINE__)
        __LINE__ = __LINE__.replace('<INDENTATIONSEP>', '{').replace('<DEDENTATIONSEP>', '}')
        if __LINE__.endswith(';') == False:
            if __LINE__.endswith(('{', '}', '(', ')', '[', ']', ',')) == False:
                __LINE__ += ';'
        topline: str = f"{__COLORS__['red']}Reported Traceback in File \"{__FILE_PATH__}\", line {__GET_LINE_NUMBER__(__LINE__)} {__COLORS__['reset']}"
        topline_len = f"\u2502   UnknownError:"
        print(topline)
        print(f'{__COLORS__["red"]}\u2502   UnknownError: {__COLORS__["yellow"]}{__LINE__}{__COLORS__["reset"]}')
        print(f'{__COLORS__["red"]}╰{"─"*(len(topline_len.strip()) - 2)}> {"^"*(len(__ERROR_WORD__))}{__COLORS__["reset"]}')
        print(f'{__COLORS__["bold red"]}ERROR :{__COLORS__["yellow"]} This keyword is not implemented.{__COLORS__["reset"]}')
        exit()
class UnhandledException(Exception):
    __doc__ = """
    \n This class is used to raise an error when there is an unhandled error
    """
    __slots__ = ('__ERROR_WORD__', 'no_exit')
    def __init__(self, __ERROR_WORD__: str, no_exit=None) -> exit:
        console("")
        print(f'{__COLORS__["bold red"]}Unhandled Exception: {__COLORS__["yellow"]}{__ERROR_WORD__}{__COLORS__["reset"]}')
        exit() if no_exit is None else None

class __DISPATCH__(object):
    __doc__ = """
    \n This class is used to dispatch functions based on their arguments
    \n It is used to make a function that can take multiple arguments and return different values based on the arguments
    Args:
        NAME: The name of the function

    Returns:
        It returns a function that can take multiple arguments and return different values based on the arguments
    """
    __slots__ = ('__TYPE_MAP__', 'NAME')
    def __init__(self, NAME):
        self.NAME = NAME
        self.__TYPE_MAP__ = {}
    def __call__(self, *ARGUMENTS):
        __TYPES__ = tuple(argument.__class__ for argument in ARGUMENTS) # a generator expression!
        FUNCTION = self.__TYPE_MAP__.get(__TYPES__)
        if FUNCTION is None:
            VersaceCodeBaseError(f"No registered function for types \"{__TYPES__}\"")
        return FUNCTION(*ARGUMENTS)
    def __register__(self, __TYPES__, FUNCTION):
        if __TYPES__ in self.__TYPE_MAP__:
            VersaceCodeBaseError(f"Duplicate registration for function \"{FUNCTION.__name__}\"")
        self.__TYPE_MAP__[__TYPES__] = FUNCTION
class MemoizeMutable:
    __doc__ = """
    \n This class is used to cache the results of a function
    \n It is used to make a function that can take multiple arguments and return different values based on the arguments
    Returns:
        It returns a function that can take multiple arguments and return different values based on the arguments
    """
    __slots__ = ('func', 'cache')
    def __init__(self, func):
        self.func = func
        self.cache = {}
    def __call__(self, *args, **kwargs):
        key = dumps((args, kwargs))
        if key not in self.cache:
            self.cache[key] = self.func(*args, **kwargs)
        return self.cache[key]
class __MISSALANEOUS__:
    __doc__ = """
    \n This class is used to store miscellaneous functions that are used in the VersaceCodeBase
    \n    Help Menu: This function is used to print the help menu
    \n    Copyright: This function is used to print the copy right information
    \n    License: This function is used to print the license information
    \n    Credits: This function is used to print the credits information
    \n    Version: This function is used to print the version information
    """
    __slots__ = ('None')
    def __HELP_MENU__(self) -> None:
        console("")
        print(f'{__COLORS__["yellow"]}Copyright © {__CURRENT_YEAR__} Versace{__COLORS__["reset"]}')
        print(f'{__COLORS__["green"]}If you need help, please read the documentation here: {__COLORS__["blue"]}https://dhruvan.gitbook.io/vs/{__COLORS__["reset"]}')
    def __COPYRIGHT__(self) -> None:
        console("")
        print(f'{__COLORS__["yellow"]}Copyright © 2001-{__CURRENT_YEAR__} Versace Software.{__COLORS__["reset"]}')
        print(f'{__COLORS__["yellow"]}All Rights Reserved.\n{__COLORS__["reset"]}')
        print(f'{__COLORS__["yellow"]}Copyright © 2000 GitHub, Inc.{__COLORS__["reset"]}')
        print(f'{__COLORS__["yellow"]}All Rights Reserved.\n{__COLORS__["reset"]}')
        print(f'{__COLORS__["yellow"]}Copyright © 2005-{__CURRENT_YEAR__} Dhruvan Enterprises, Software Division (DESD).{__COLORS__["reset"]}')
        print(f'{__COLORS__["yellow"]}All Rights Reserved.\n{__COLORS__["reset"]}')
    def __LICENSE__(self) -> None:
        console("")
        print(f"{__COLORS__['yellow']}Copyright {__CURRENT_YEAR__} Ze7111 (Dhruvan Kartik)\n{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}Permission is hereby granted, free of charge, to any persons obtaining{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}a copy of thissoftware and associated documentation files (the \"Software\"), {__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}to deal in the Software, without limitation any persons can {__COLORS__['bold red']}NOT{__COLORS__['reset']}{__COLORS__['yellow']} distribute, {__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}and/or sublicense this software without the permission of the author, however{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}to deal in the Software, without limitation the rights to use, copy, modify, merge,{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}and/or publish the Software.\n{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}To permit persons to whom the Software is furnished to do so, subject to the{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}following conditions:{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}\tThe above copyright notice and this permission notice shall be included in all{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}\tcopies or substantial portions of the Software.\n{__COLORS__['reset']}")
        print(f"{__COLORS__['red']}THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}\tincluding but not limited to the warranties of merchantability, fitness for a{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}\tparticular purpose and noninfringement. In no event shall the authors or{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}\tcopyright holders be liable for any claim, damages or other liability, whether{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}\tin an action of contract, tort or otherwise, arising from, out of or in{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}\tconnection with the software or the use or other dealings in the Software.\n{__COLORS__['reset']}")
    def __CREDITS__(self) -> None:
        console("")
        print(f"{__COLORS__['green']}Copyright {__CURRENT_YEAR__} Ze7111 (Dhruvan Kartik){__COLORS__['reset']}\n")
        print(f'{__COLORS__["green"]}Version: {__COLORS__["yellow"]}{__VERSION__}{__COLORS__["reset"]}')
        print(f'{__COLORS__["green"]}Author: {__COLORS__["yellow"]}Ze7111 (Dhruvan Kartik){__COLORS__["reset"]}')
        print(f'{__COLORS__["green"]}Moral Support: {__COLORS__["yellow"]}(Amr E.){__COLORS__["reset"]}')
        print(f'{__COLORS__["green"]}Devlopment team of Versace.{__COLORS__["reset"]}')
    def __VERSION__(self) -> None:
        console("")
        print(f'{__COLORS__["green"]}You are Running Versace Version: {__VERSION__}{__COLORS__["reset"]}')

class __1__:
    """This is a fake data type, to be used for overloading only"""
    __slots__ = "value"
    pass
class __2__:
    """This is a fake data type, to be used for overloading only"""
    __slots__ = "value"
    pass
class __3__:
    """This is a fake data type, to be used for overloading only"""
    __slots__ = "value"
    pass

class __INCLUDE_STATEMENTS__:
    __doc__ = """
    \n This class is used to store the include statements.
    """
    __slots__ = ["__FILE_NAME__", "__AS_STATEMENT__", "__LINE__"]
    @staticmethod
    def __VERSACE_HEADER__(__FILE_NAME__: str, __AS_STATEMENT__: str, __LINE__: list) -> str:
        global __RECURSIVE_CYCLES__
        for i in __AS_STATEMENT__: __ASSIGN_CLASS__(i.replace('\"', ''), "INCLUDE")
        __RECURSIVE_CYCLES__ += 1
        if __RECURSIVE_CYCLES__ >= __MAX_INCLUDES__: __ERROR_REPORTING__(__LINE__, "CyclicIncludeError", __FILE_NAME__); exit()
        __FOUND__ = False
        __FILE_NAME__ = __FILE_NAME__.replace(__SYSTEM__.get_c_dir(), '')
        if __SYSTEM__.path_exists(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}include{path_sep}{__FILE_NAME__}"):
            __FILE_NAME__ = f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}include{path_sep}{__FILE_NAME__}"
            __FOUND__ = True
        if __FOUND__ is False:
            if __SYSTEM__.path_exists(f"{__SYSTEM__.get_c_dir()}{path_sep}{__FILE_NAME__}") and path.basename(__FILE_PATH__) != __FILE_NAME__:
                __FILE_NAME__ = f"{__SYSTEM__.get_c_dir()}{path_sep}{__FILE_NAME__}"
                __FOUND__ = True
        else:
            if __FOUND__ is False:
                __ERROR_REPORTING__(__LINE__, 'FileNotFound', f"{__FILE_NAME__}")
                return ''
        with open(__FILE_NAME__, 'r', encoding="utf-8") as __FILE__:
            __LINES__ = __FILE__.readlines()
        __DEFAULT_NAME__ = ''
        __REQUIRED_MODULES__: list[str] = []
        # check if the type of __AS_STATEMENT__ is a list
        if isinstance(__AS_STATEMENT__, list):
            __AS_STATEMENT__ = ''.join(__AS_STATEMENT__)

        for _INDEX_, _LINE_ in enumerate(__LINES__):
            if _LINE_.strip().startswith('$'):
                _LINE_ = _LINE_.strip().replace('$', '')

                if _LINE_.strip().startswith('<:name:>'):
                    __DEFAULT_NAME__ = _LINE_.replace('<:name:>', '').replace('=', '').strip()
                    __LINES__.pop(_INDEX_)
                    continue

        for _INDEX_, _LINE_ in enumerate(__LINES__):
            if _LINE_.strip().startswith('$'):
                _LINE_ = _LINE_.strip().replace('$', '')

                if _LINE_.strip().startswith('<:modules:>'):
                    for i in range(len(_LINE_)):
                        if _LINE_[i] == '=':
                            __REQUIRED_MODULES__ = _LINE_[i+1:].strip().split(',')
                    __LINES__.pop(_INDEX_)
                    continue

        __REQUIRED_MODULES__ = [i.strip() for i in __REQUIRED_MODULES__ if i.strip() != '']
        if __DEFAULT_NAME__ == '':
            __ERROR_REPORTING__(__FILE_NAME__, "BadHeader")
        if __AS_STATEMENT__ == '':
            __AS_STATEMENT__ = __DEFAULT_NAME__
        for _INDEX_, _LINE_ in enumerate(__LINES__):

            if '<:name:>' in _LINE_:
                __LINES__[_INDEX_] = _LINE_.replace('<:name:>', __AS_STATEMENT__)
                continue
        return __LINES__
    @staticmethod
    def __VERSACE_MODULE__(__FILE_NAME__: str, __LINE__: str) -> str:
        global __TOKENIZED_LIST__, __FINAL_LIST__, __RECURSIVE_CYCLES__
        __RECURSIVE_CYCLES__ += 1
        if __RECURSIVE_CYCLES__ >= __MAX_INCLUDES__: __ERROR_REPORTING__(__LINE__, "CyclicIncludeError", __FILE_NAME__); exit()
        # check if this files name is the same as the file name of the file that is being run
        __FOUND__ = False
        __FILE_NAME__ = __FILE_NAME__.replace(__SYSTEM__.get_c_dir(), '')
        if __SYSTEM__.path_exists(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}include{path_sep}{__FILE_NAME__}"):
            __FILE_NAME__ = f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}include{path_sep}{__FILE_NAME__}"
            __FOUND__ = True
        if __FOUND__ is False:
            if __SYSTEM__.path_exists(f"{__SYSTEM__.get_c_dir()}{path_sep}{__FILE_NAME__}") and path.basename(__FILE_PATH__) != __FILE_NAME__:
                __FILE_NAME__ = f"{__SYSTEM__.get_c_dir()}{path_sep}{__FILE_NAME__}"
                __FOUND__ = True
        else:
            if __FOUND__ is False:
                __ERROR_REPORTING__(__LINE__, 'FileNotFound', f"{__FILE_NAME__}")
                return ''
        __SPLIT_LIST_COPY__: list[str] = __TOKENIZED_LIST__.copy()
        __TEMP_LINES_DATA__ = __OPEN_FILE__(__FILE_NAME__, mode='include')
        __TEMP_SPLIT_LIST__: list[str] = []
        __TEMP_SPLIT_LIST__ = __SPLIT_ALL_LINES__(mode='include', __DATA__=__TEMP_LINES_DATA__)
        __NEW_DATA__ = __LEXICAL_ANALYSIS__(mode='include',  __INCLUDE_LIST__=__TEMP_SPLIT_LIST__)
        __TOKENIZED_LIST__ = __SPLIT_LIST_COPY__.copy()
        del __TEMP_LINES_DATA__, __TEMP_SPLIT_LIST__
        return
    @staticmethod
    def __PYTHON_MODULE__(__LINE__: str, __AS_STATEMENT__: str) -> str:
        if 'from' in __LINE__:
            __MODULES__: list[str] = __LINE__[__LINE__.index('from') + 1:]
            for i in __MODULES__:
                __ASSIGN_CLASS__(i.replace('\"', ''), "INCLUDE")
            __FUNCTIONS__: list[str] = __LINE__[__LINE__.index('include') + 1:__LINE__.index('from')]
            for i in __FUNCTIONS__:
                __ASSIGN_FUNCTION__(i.replace('\"', ''), "INCLUDE", "none")
            if 'as' in __LINE__:
                __MODULES__ = __MODULES__[:__MODULES__.index('as')]
            for index, i in enumerate(__FUNCTIONS__):
                if '\"' in i:
                    __FUNCTIONS__[index] = i.replace('\"', '')
            for index, i in enumerate(__MODULES__):
                if '\"' in i:
                    __MODULES__[index] = i.replace('\"', '')
            __OUTPUT__ = f'from {" ".join(__MODULES__)} import {" ".join(__FUNCTIONS__)}'
            if 'as' in __LINE__:
                for i in __AS_STATEMENT__:
                    __ASSIGN_CLASS__(i.replace('\"', ''), "INCLUDE")
                __AS_STATEMENT__ = ' '.join(__AS_STATEMENT__).replace('\"', '')
                __OUTPUT__ += f" as {__AS_STATEMENT__}"
            return __INDENTATION__*__INDENTATION_COUNT__ + __OUTPUT__
        else:
            __OUTPUT__ = ' '.join(__LINE__[1:]).replace('\"', '')
            return __INDENTATION__*__INDENTATION_COUNT__ + f"import {__OUTPUT__}"
    @staticmethod
    def __PYTHON_FILE__(__FILE_NAME__: str, __LINE__: str) -> str:
        global __RECURSIVE_CYCLES__
        __RECURSIVE_CYCLES__ += 1
        if __RECURSIVE_CYCLES__ >= __MAX_INCLUDES__: __ERROR_REPORTING__(__LINE__, "CyclicIncludeError", __FILE_NAME__); exit()
        __FOUND__ = False
        __FILE_NAME__ = __FILE_NAME__.replace(__SYSTEM__.get_c_dir(), '')
        if __SYSTEM__.path_exists(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}include{path_sep}{__FILE_NAME__}"):
            __FILE_NAME__ = f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}include{path_sep}{__FILE_NAME__}"
            __FOUND__ = True
        if __FOUND__ is False:
            if __SYSTEM__.path_exists(f"{__SYSTEM__.get_c_dir()}{path_sep}{__FILE_NAME__}") and path.basename(__FILE_PATH__) != __FILE_NAME__:
                __FILE_NAME__ = f"{__SYSTEM__.get_c_dir()}{path_sep}{__FILE_NAME__}"
                __FOUND__ = True
        else:
            if __FOUND__ is False:
                __ERROR_REPORTING__(__LINE__, 'FileNotFound', f"{__FILE_NAME__}")
                return ''
        with open(f"{__SYSTEM__.get_c_dir()}{path_sep}{__FILE_NAME__}", 'r', encoding="utf-8") as f:
            __DATA__: list = f.readlines()
        return __DATA__
class __SYNTAX_ANALYSIS__:
    __doc__ = """
    This class contains all the sub-classes that are used to convert Versace code to python code
    It contians the following sub-classes:
    \n    __io__: This class contains the functions that are used to convert the io functions to python code
    \n    __access_modifiers__: This class contains the functions that are used to convert the access modifiers to python code
    \n    __control_flow__: This class contains the functions that are used to convert the control flow to python code
    \n    __function__: This class contains the functions that are used to convert the functions to python code
    \n    __variable__: This class contains the functions that are used to convert the variables to python code
    \n    __data_classes__: This class contains the functions that are used to convert the data classes to python code
    Returns:
    \n    str: the converted line
    """
    __slots__ = '__LINE__'
    class __io__:
        __doc__ = """
        \n Inputs: the line to change
        \n Outputs: the line with the iosstream removed
        \n Input/Output: output, input, include, from, import, pyc
        """
        __slots__ = '__LINE__'
        @staticmethod
        def __OUTPUT__(__LINE__: list) -> str:
            global __INDENTATION_COUNT__,__INDENTATION_LEVEL__,  __OPTIANAL_ARGS_IN_FILE__, __VARIABLES__, __FUNCTIONS__, __CLASSES__
            """
            \n Inputs: the line to change
            \n Outputs: python converted line
            \n This function converts Versace code to python code
            """
            __ORG_LINE__ = __LINE__.copy()
            __OUTPUT_LINE__: str = ''
            FOUND_OUT = False
            __LINE__ = ' '.join(__LINE__)
            __LINE__ = __LINE__.split('<<')
            __LINE__ = [x.strip() for x in __LINE__]
            if '<' in __ORG_LINE__:
                __ERROR_REPORTING__(__ORG_LINE__, 'Used<Error')
                return ''
            for _I_ in __LINE__:
                if _I_ == 'out':
                    if FOUND_OUT is False:
                        FOUND_OUT = True
                        __OUTPUT_LINE__ = "print("
                    else:
                        __ERROR_REPORTING__(__ORG_LINE__, 'outCalledError')
                        return ''
                elif _I_ in __GLOBAL_VARIABLES__.__END_TYPES__:
                    __OUTPUT_LINE__ += f', end="{__GLOBAL_VARIABLES__.__END_TYPES__[_I_]}"'
                elif _I_ in __GLOBAL_VARIABLES__.__JUSTIFY_TYPES__:
                    if "-*- no color -*-" not in __OPTIANAL_ARGS_IN_FILE__:
                        __OUTPUT_LINE__ += f', justify="{_I_}"'
                elif _I_ in __GLOBAL_VARIABLES__.__COLOR_TYPES__ or _I_ in __GLOBAL_VARIABLES__.__STYLE_TYPES__:
                    if "-*- no color -*-" not in __OPTIANAL_ARGS_IN_FILE__:
                        __OUTPUT_LINE__ += f', style="{_I_}"'
                elif _I_ == '<<':
                    continue
                else:
                    if ' ' in _I_ and '\"' not in _I_:
                        # check if even a part of _I_ is in either __VARIABLES__ or __FUNCTIONS__ or __CLASSES__
                        __SPLIT_UP_LINE__: str = __SPLIT_LINE__(_I_)
                        for index, i in enumerate(__SPLIT_UP_LINE__):
                            if __CHECK_IF_DELARED__(i, __ORG_LINE__, __TYPE__=1):
                                __SPLIT_UP_LINE__[index] = '__' + __SPLIT_UP_LINE__[index]
                        _I_ = ' '.join(__SPLIT_UP_LINE__)
                    __OUTPUT_LINE__ += f',{_I_}'

            __OUTPUT_LINE__ += ')'
            for i in range(len(__OUTPUT_LINE__)):
                # remove the first comma
                if __OUTPUT_LINE__[i] == ',':
                    __OUTPUT_LINE__ = __OUTPUT_LINE__[:i] + __OUTPUT_LINE__[i + 1:]
                    break
            return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
        @staticmethod
        def __INPUT__(__LINE__: list) -> str:
            global __INDENTATION_LEVEL__, __OPTIANAL_ARGS_IN_FILE__, __INDENTATION_COUNT__
            """
            \n Inputs: the line to change
            \n Outputs: python converted line
            \n This function converts Versace code to python code
            """

            __ORG_LINE__ = __LINE__
            __OUTPUT_LINE__: str = ''
            FOUND_OUT = False
            __LINE__ = ' '.join(__LINE__)
            __LINE__ = __LINE__.split('<<')
            __LINE__ = [x.strip() for x in __LINE__]
            if '<' in __ORG_LINE__:
                __ERROR_REPORTING__(__ORG_LINE__, 'Used<Error')
                return ''
            __OUTPUT_LINE__ += "print("
            # example line : in somevar << "Enter your name: " << endl << int
            # example output : print("Enter your name: ", end = "")\n somevar = int(input())
            __VAR__ = __LINE__[0].split(' ')[1]
            #print(__LINE__, __VAR__)
            __LINE__ = __LINE__[1:]
            __LINE_TYPE__: str = ''
            for _I_ in __LINE__:
                if _I_ in __GLOBAL_VARIABLES__.__END_TYPES__:
                    __OUTPUT_LINE__ += f', end="{__GLOBAL_VARIABLES__.__END_TYPES__[_I_]}"'
                elif _I_ in __GLOBAL_VARIABLES__.__JUSTIFY_TYPES__:
                    if "-*- no color -*-" not in __OPTIANAL_ARGS_IN_FILE__:
                        __OUTPUT_LINE__ += f', justify="{_I_}"'
                elif _I_ in __GLOBAL_VARIABLES__.__COLOR_TYPES__ or _I_ in __GLOBAL_VARIABLES__.__STYLE_TYPES__:
                    if "-*- no color -*-" not in __OPTIANAL_ARGS_IN_FILE__:
                        __OUTPUT_LINE__ += f', style="{_I_}"'
                elif _I_ == '<<':
                    continue
                elif _I_ in __GLOBAL_VARIABLES__.__DATA_TYPES__:
                    __LINE_TYPE__ = _I_
                else:
                    __OUTPUT_LINE__ += f',{_I_}'
            if 'end=' not in __OUTPUT_LINE__:
                __OUTPUT_LINE__ += ', end=""'
            __OUTPUT_LINE__ += ')'
            for i in range(len(__OUTPUT_LINE__)):
                # remove the first comma
                if __OUTPUT_LINE__[i] == ',':
                    __OUTPUT_LINE__ = __OUTPUT_LINE__[:i] + __OUTPUT_LINE__[i + 1:]
                    break
            if __LINE_TYPE__ == '':
                __LINE_TYPE__ = 'str'
            return (''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])) + f'\n{__INDENTATION__*__INDENTATION_COUNT__}{__VAR__} = {__LINE_TYPE__}(input())'
        @staticmethod
        def __INCLUDE__(__LINE__: list) -> str:
            global __INDENTATION_LEVEL__,    __INDENTATION_COUNT__, __FINAL_LIST__, __TOKENIZED_LIST__
            __LINE__ = [__LINE__.replace('f"', '\"') for __LINE__ in __LINE__]
            __ITEMS_TO_INCLUDE__: list = []
            __AS_STATEMENT__: str = ''
            __ITEMS_TO_INCLUDE__ = __LINE__[1:]
            if __SYSTEM__.path_exists(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}include") is False:
                __SYSTEM__.make_dirs(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}include")
            if __NO_INCLUDES__: return ''
            if 'as' in __ITEMS_TO_INCLUDE__:
                __ITEMS_TO_INCLUDE__ = __ITEMS_TO_INCLUDE__[:__ITEMS_TO_INCLUDE__.index('as')]
                __AS_STATEMENT__ = __LINE__[__LINE__.index('as') + 1:]
            __ITEMS_TO_INCLUDE__ = [x for x in __ITEMS_TO_INCLUDE__ if x != ',']
            __NEW_DATA__: list = []
            for index, i in enumerate(__ITEMS_TO_INCLUDE__):
                __ITEMS_TO_INCLUDE__[index] = i.replace('\"', '') if '\"' in i else i
            for i in __ITEMS_TO_INCLUDE__:
                if __SYSTEM__.get_c_dir() + path_sep in i:
                    i = i.replace(__SYSTEM__.get_c_dir() + path_sep, '')

                if i.endswith('.vh'):
                    for _data in __INCLUDE_STATEMENTS__.__VERSACE_HEADER__(i, __AS_STATEMENT__, __LINE__):
                        __NEW_DATA__.append((__INDENTATION__*__INDENTATION_COUNT__) + _data)

                elif i.endswith('.v'):
                    __INCLUDE_STATEMENTS__.__VERSACE_MODULE__(i, __LINE__)

                elif i.endswith('.py'):
                    for _data in __INCLUDE_STATEMENTS__.__PYTHON_FILE__(i, __LINE__):
                        __NEW_DATA__.append((__INDENTATION__*__INDENTATION_COUNT__) + _data)
                else:
                    return __INCLUDE_STATEMENTS__.__PYTHON_MODULE__(__LINE__, __AS_STATEMENT__)

            for index, i in enumerate(__NEW_DATA__):
                if i.endswith('\n'):
                    __NEW_DATA__[index] = i[:-1]

            __OUTPUT__ = '\n'.join(__NEW_DATA__)

            del __ITEMS_TO_INCLUDE__, __AS_STATEMENT__, __NEW_DATA__
            if type(__OUTPUT__) != str:
                __OUTPUT__ = ''
            return __OUTPUT__
        @staticmethod
        def __FROM__(__LINE__: list) -> str:
            NotImplementedYet.MATCH_FIRST(__LINE__, 'FROM')
            exit()
        @staticmethod
        def __IMPORT__(__LINE__: list) -> str:
            NotImplementedYet.MATCH_FIRST(__LINE__, 'IMPORT')
            exit()
        @staticmethod
        def __PYC__(__LINE__: list) -> str:
            if 'file' in __LINE__ and '=' in __LINE__:
                with open(__LINE__[__LINE__.index('=') + 1].replace('\"', ''), 'r', encoding="utf-8") as f:
                    __DATA__ = f.readlines()
                for index, i in enumerate(__DATA__):
                    __DATA__[index] = f"{__INDENTATION__*__INDENTATION_COUNT__}{i}"
                return ''.join(__DATA__)
            else:
                return ''.join(__LINE__[1:])[2:-1]
    class __access_modifiers__:
        __doc__ = """
        \n Inputs: the line to change
        \n Outputs: the line with the access modifiers words removed
        \n Access Modifiers: public, private, method, attribute, with, call
        """
        __slots__ = '__LINE__'
        @staticmethod
        def __PUBLIC__(__LINE__: list) -> str:
            """
            \n Inputs: the line to change
            \n Outputs: the line with the public removed
            \n This function removes the public from the line
            """
            # main({1:"1"}, 1, "str", 321)
            # close( "str", 321, {1:"1"}, 1)
            # update(321, "str", 1, {1:"1"})
            global __INDENTATION_LEVEL__,    __INDENTATION_COUNT__, __PUBLIC_CLOSE_FOUND__, __PUBLIC_INIT_FOUND__, __PUBLIC_UPDATE_FOUND__, __STATIC_FOR_LINE__, __IN_STATIC_FOR__, __STATIC_FOR_CALLS__
            __OUTPUT_LINE__: str = ''
            __TEMP_LINE__: str = ' '.join(__LINE__)
            __TEMP_LINE__ = __TEMP_LINE__.split(' ')
            __TEMP_LINE__ = [x.strip() for x in __TEMP_LINE__]
            if '()' not in __TEMP_LINE__:
                __ERROR_REPORTING__(__LINE__, 'AddedArgumentsToPublic')
                return ' '
            __TEMP_LINE__ = __TEMP_LINE__[1:]
            __TEMP_LINE__.insert(0, 'def')
            if __TEMP_LINE__[1] == 'close':
                __TEMP_LINE__ = __TEMP_LINE__[:-2]
                __TEMP_LINE__.append('(a, b, c, d) <INDENTATIONSEP>\n')
            __TEMP_LINE__ = ' '.join(__TEMP_LINE__)
            __OUTPUT_LINE__ = __TEMP_LINE__
            __FUNCTION_NAME__ = __LINE__[1]
            if __FUNCTION_NAME__ == 'main':
                __PUBLIC_INIT_FOUND__ = True
                __OUTPUT_LINE__ = (__INDENTATION__*__INDENTATION_COUNT__) + '@overload(dict, int, str, int)\n'
                __OUTPUT_LINE__ += (__INDENTATION__*__INDENTATION_COUNT__) + 'def main(a, b, c, d) <INDENTATIONSEP>\n'
                __STATIC_FOR_LINE__.append('main({1:"1"}, 321, "str", 1)')
                __IN_STATIC_FOR__.append(True)
                __STATIC_FOR_CALLS__ += 1
                return __OUTPUT_LINE__
            if __FUNCTION_NAME__ == 'update':
                __PUBLIC_UPDATE_FOUND__ = True
                __OUTPUT_LINE__  = (__INDENTATION__*__INDENTATION_COUNT__) + '@_async\n'
                __OUTPUT_LINE__ += (__INDENTATION__*__INDENTATION_COUNT__) + '@overload(int, str, int, dict)\n'
                __OUTPUT_LINE__ += (__INDENTATION__*__INDENTATION_COUNT__) + 'def update(a, b, c, d):\n'
                __OUTPUT_LINE__ += (__INDENTATION__*(__INDENTATION_COUNT__ + 1)) + 'while True:\n'
                __OUTPUT_LINE__ += (__INDENTATION__*(__INDENTATION_COUNT__ + 2)) + 'if not main_thread().is_alive():\n'
                __OUTPUT_LINE__ += (__INDENTATION__*(__INDENTATION_COUNT__ + 3)) + 'exit()'
                __INDENTATION_COUNT__ += 1
                __STATIC_FOR_LINE__.append('update(321, "str", 1, {1:"1"})')
                __IN_STATIC_FOR__.append(True)
                __STATIC_FOR_CALLS__ += 1
                return __OUTPUT_LINE__
            if __FUNCTION_NAME__ == 'close':
                __OUTPUT_LINE__ = (__INDENTATION__*__INDENTATION_COUNT__) + '@overload(str, int, dict, int)\n' + __OUTPUT_LINE__
                __PUBLIC_CLOSE_FOUND__ = True
            return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
        @staticmethod
        def __PRIVATE__(__LINE__: list) -> str:
            __TEMP_ARGS__ = ''
            if '=' in __LINE__:
                _FOUND_DATA_TYPE_ = False
                for _INDEX_, _I_ in enumerate(__LINE__):
                    if _I_ in __GLOBAL_VARIABLES__.__DATA_TYPES__:
                        _FOUND_DATA_TYPE_ = True
                __LINE__ = __LINE__[1:]
                if _FOUND_DATA_TYPE_ is False:
                    __ASSIGN_VARIABLE__(__LINE__[0], "PRIVATE", __LINE__[:2])
                    return __INDENTATION__*__INDENTATION_COUNT__ + ' '.join(__LINE__)
                return ' '
            __OUTPUT_LINE__: str = ''
            __TEMP_LINE__: str = ' '.join(__LINE__)
            __TEMP_LINE__ = __TEMP_LINE__.split(' ')
            if 'func' not in __TEMP_LINE__:
                if __TEMP_LINE__[1] in __GLOBAL_VARIABLES__.__DATA_TYPES__:
                    __ERROR_REPORTING__(__LINE__, 'AddedDataTypesToPrivClass')
                    return ' '
                try:
                    __TEMP_LINE__[2] = '__' + __TEMP_LINE__[2]
                except IndexError: return ' '
                __ASSIGN_CLASS__(__TEMP_LINE__[2], "PRIVATE")

            elif 'func' in __TEMP_LINE__ and 'async' in __TEMP_LINE__:
                __ERROR_REPORTING__(__LINE__, 'AsyncAndPrivate')
                return ' '
            elif 'func' in __TEMP_LINE__:
                if __TEMP_LINE__[1] in __GLOBAL_VARIABLES__.__DATA_TYPES__:
                    __TEMP_LINE__[3] = '__' + __TEMP_LINE__[3]
                    __TEMP_LINE__ = __TEMP_LINE__[1:]
                else:
                    __TEMP_LINE__[2] = '__' + __TEMP_LINE__[2]
                __TEMP_LINE__ = __TEMP_LINE__[1:]
                __ASSIGN_FUNCTION__(__TEMP_LINE__[1], "PRIVATE", __TEMP_LINE__[2:-1])
                __ARGS_IN_LINE__ = ' '.join(__LINE__[4:-2]).strip()
                __IN_STRING__ = False
                __TEMP_ARGS__ = []
                __FUNCTION_NAME__ = __LINE__[1]
                word = ''
                for char in __ARGS_IN_LINE__:
                    if char == '\"':
                        __IN_STRING__ = __LATCH__(__IN_STRING__)
                    if char == '|' and not __IN_STRING__:
                        __TEMP_ARGS__.append(word.strip())
                        word = ''
                    else:
                        word += char
                __TEMP_ARGS__.append(word.strip())
                __T_TEMP_ARGS__ = __TEMP_ARGS__.copy()
                for index in range(len(__TEMP_ARGS__)):
                    if __TEMP_ARGS__[index].startswith(__GLOBAL_VARIABLES__.__DATA_TYPES__):
                        __TEMP_ARGS__[index] = __DATA_TYPE_TOKENS__[__TEMP_ARGS__[index].split(' ')[0]](__SPLIT_LINE__(__TEMP_ARGS__[index]))
                __ASSIGN_VARIABLE__(__LINE__[1], "REGULAR", ' '.join(__LINE__[2:-1]))
            __TEMP_LINE__ = [x.strip() for x in __TEMP_LINE__]
            __TEMP_LINE__ = __TEMP_LINE__[1:]
            if '(' not in __TEMP_LINE__ and ')' not in __TEMP_LINE__:
                if '()' in __TEMP_LINE__:
                    __TEMP_LINE__.insert(0, 'def')
            else:
                __TEMP_LINE__.insert(0, 'def')
            __TEMP_LINE__ = ' '.join(__TEMP_LINE__)
            __OUTPUT_LINE__ = __TEMP_LINE__
            for i in range(len(__TEMP_ARGS__)):
                __OUTPUT_LINE__ = __OUTPUT_LINE__.replace(__T_TEMP_ARGS__[i], __TEMP_ARGS__[i])
            return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
        @staticmethod
        def __METHOD__(__LINE__: list) -> str:
            global __INDENTATION_LEVEL__,    __INDENTATION_COUNT__, __IN_STATIC_FOR__, __STATIC_FOR_LINE__, __STATIC_FOR_CALLS__, __EXTRA_INDENTATION__
            __ARGUMENTS__ = []
            __ARGS__: str = 'args'
            __KEYWORD_ARGS__: str = 'kwargs'
            if 'async' in __LINE__:
                __ERROR_REPORTING__(__LINE__, 'UsedAsyncAndMethod')
                return ' '
            if '|' in __LINE__:
                for INDEX in range(len(__LINE__)):
                    if __LINE__[INDEX] == '*':
                        __ARGS__ = __LINE__[INDEX+1]
                    elif __LINE__[INDEX] == '**':
                        __KEYWORD_ARGS__ = __LINE__[INDEX+1]
                if '*' not in __LINE__ and '**' not in __LINE__:
                    __ARGUMENTS__ = __LINE__[__LINE__.index('|')+1:__LINE__.index(')')]
            __ARGUMENTS__ = f"{' '.join(__ARGUMENTS__)}, " if __ARGUMENTS__ != [] else ''
            __LINE_1__ = f"{(' '.join(__LINE__[1:__LINE__.index('|')])).strip()} )" if '|' in __LINE__ else (' '.join(__LINE__[1:__LINE__.index('<INDENTATIONSEP>')])).strip()
            __OUTPUT_LINE__ = ''.join([(__INDENTATION__*__INDENTATION_COUNT__),f"def {__LINE_1__}",':','\n'])
            __OUTPUT_LINE__ += (__INDENTATION__*(__INDENTATION_COUNT__+1)) + f"def method_{__LINE__[1].strip()}({__ARGUMENTS__}*{__ARGS__}, **{__KEYWORD_ARGS__})" + '<INDENTATIONSEP>'
            __STATIC_FOR_LINE__.append(f"return method_{__LINE__[1].strip()}")
            __ASSIGN_FUNCTION__(__LINE__[1], "METHOD", __LINE__[3:-2])
            __IN_STATIC_FOR__.append(True)
            __STATIC_FOR_CALLS__ += 1
            __EXTRA_INDENTATION__ = True
            __INDENTATION_COUNT__ += 1
            return __OUTPUT_LINE__
        @staticmethod
        def __AT__(__LINE__: list) -> str:

            __LINE__[0] = f'{__INDENTATION__*__INDENTATION_COUNT__}{__LINE__[0]}'
            for i in range(len(__LINE__)):
                if __LINE__[i] == 'async' and __LINE__[i+1] == 'func':
                    __ERROR_REPORTING__(__LINE__, 'UsedAsyncAndMethod')
                    return ' '
                if __LINE__[i] == 'func':
                    __LINE__[i] = f'\n{__INDENTATION__*__INDENTATION_COUNT__}def'
            return ' '.join(__LINE__)
        @staticmethod
        def __WITH__(__LINE__: list) -> str:
            __LINE__[0] = f'{__INDENTATION__*__INDENTATION_COUNT__}{__LINE__[0]}'
            return ' '.join(__LINE__)
        @staticmethod
        def __CALL__(__LINE__: list) -> str:
            __LINE__ = __LINE__[1:]
            __LINE__ = ' '.join(__LINE__).strip()
            __LINE__ = f"{__INDENTATION__*__INDENTATION_COUNT__}{__LINE__}"
            return __LINE__
    class __control_flow__:
        __doc__ = """
        \n Inputs: the line to change
        \n Outputs: the line with the control flow words removed
        \n Control Flow: if, else, else if, for, while, static for, return
        """
        __slots__ = '__LINE__'
        @staticmethod
        def __IF__(__LINE__: list) -> str:

            __OUTPUT_LINE__: str = ''
            __TEMP_LINE__: str = ' '.join(__LINE__)
            __TEMP_LINE__ = __TEMP_LINE__.split(' ')
            __TEMP_LINE__ = [x.strip() for x in __TEMP_LINE__]
            __TEMP_LINE__: str = ' '.join(__TEMP_LINE__)
            __FOUND_START__ = False
            if '(' in __TEMP_LINE__ or ')' in __TEMP_LINE__:
                for index, char in enumerate(__TEMP_LINE__):
                    if char == '(' and __TEMP_LINE__[index - 2] == 'f' and __TEMP_LINE__[index - 3] == 'i':
                        # example: if ( true ) :
                        # output: if true:
                        __FOUND_START__ = True
                        __TEMP_LINE__ = __TEMP_LINE__[:index] + __TEMP_LINE__[index + 1:]
                    elif char == ')':
                        if __TEMP_LINE__[index + 1] == ':' or __TEMP_LINE__[index + 1] == '<' and __TEMP_LINE__[index + 2] == 'I' and __TEMP_LINE__[index + 3] == 'N' and __TEMP_LINE__[index + 4] == 'D' and __TEMP_LINE__[index + 5] == 'E' and __TEMP_LINE__[index + 6] == 'N' and __TEMP_LINE__[index + 7] == 'T':
                            # example: if true ) :
                            # output: if true:
                            if __FOUND_START__:
                                __TEMP_LINE__ = __TEMP_LINE__[:index - 1] + __TEMP_LINE__[index + 1:]
            __OUTPUT_LINE__ = __TEMP_LINE__
            return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
        @staticmethod
        def __ELSE__(__LINE__: list) -> str:

            __LINE__ = [x.strip() for x in __LINE__]
            __OUTPUT_LINE__: str = ' '.join(__LINE__)
            return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
        @staticmethod
        def __ELSE_IF__(__LINE__: list) -> str:
            __OUTPUT_LINE__: str = ''
            __TEMP_LINE__ = __LINE__[2:]
            __TEMP_LINE__.insert(0, 'elif')
            __TEMP_LINE__: str = ' '.join(__TEMP_LINE__)
            __TEMP_LINE__ = __TEMP_LINE__.split(' ')
            __TEMP_LINE__ = [x.strip() for x in __TEMP_LINE__]
            __TEMP_LINE__: str = ' '.join(__TEMP_LINE__)
            __FOUND_START__ = False
            if '(' in __TEMP_LINE__ or ')' in __TEMP_LINE__:
                for index, char in enumerate(__TEMP_LINE__):
                    if char == '(' and __TEMP_LINE__[index - 2] == 'f' and __TEMP_LINE__[index - 3] == 'i':
                        # example: if ( true ) :
                        # output: if true:
                        __FOUND_START__ = True
                        __TEMP_LINE__ = __TEMP_LINE__[:index] + __TEMP_LINE__[index + 1:]
                    elif char == ')':
                        if __TEMP_LINE__[index + 1] == ':' or __TEMP_LINE__[index + 1] == '<' and __TEMP_LINE__[index + 2] == 'I' and __TEMP_LINE__[index + 3] == 'N' and __TEMP_LINE__[index + 4] == 'D' and __TEMP_LINE__[index + 5] == 'E' and __TEMP_LINE__[index + 6] == 'N' and __TEMP_LINE__[index + 7] == 'T':
                            # example: if true ) :
                            # output: if true:
                            if __FOUND_START__:
                                __TEMP_LINE__ = __TEMP_LINE__[:index - 1] + __TEMP_LINE__[index + 1:]
            __OUTPUT_LINE__ = __TEMP_LINE__
            return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
        @staticmethod
        def __FOR__(__LINE__: list) -> str:

            if '|' in __LINE__:
                return __SYNTAX_ANALYSIS__.__control_flow__.__STATIC_FOR__(__LINE__)
            __OUTPUT_LINE__: str = ''
            __TEMP_LINE__: str = ' '.join(__LINE__)
            __TEMP_LINE__ = __TEMP_LINE__.split(' ')
            __TEMP_LINE__ = [x.strip() for x in __TEMP_LINE__]
            __TEMP_LINE__: str = ' '.join(__TEMP_LINE__)
            __FOUND_START__ = False
            # recognize this pattern: for ( start, condition, increment ) :
            if '(' in __TEMP_LINE__ or ')' in __TEMP_LINE__:
                for index, char in enumerate(__TEMP_LINE__):
                    if char == '(' and __TEMP_LINE__[index - 2] == 'r' and __TEMP_LINE__[index - 3] == 'o' and __TEMP_LINE__[index - 4] == 'f':
                        # example: for ( true ) :
                        # output: for true:
                        __FOUND_START__ = True
                        __TEMP_LINE__ = __TEMP_LINE__[:index] + __TEMP_LINE__[index + 1:]
                    elif char == ')':
                        if __TEMP_LINE__[index + 1] == ':' or __TEMP_LINE__[index + 1] == '<' and __TEMP_LINE__[index + 2] == 'I' and __TEMP_LINE__[index + 3] == 'N' and __TEMP_LINE__[index + 4] == 'D' and __TEMP_LINE__[index + 5] == 'E' and __TEMP_LINE__[index + 6] == 'N' and __TEMP_LINE__[index + 7] == 'T':
                            # example: for true ) :
                            # output: for true:
                            if __FOUND_START__:
                                __TEMP_LINE__ = __TEMP_LINE__[:index - 1] + __TEMP_LINE__[index + 1:]
            __OUTPUT_LINE__ = __TEMP_LINE__
            return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
        @staticmethod
        def __WHILE__(__LINE__: list) -> str:

            __OUTPUT_LINE__: str = ''
            __TEMP_LINE__: str = ' '.join(__LINE__)
            __TEMP_LINE__ = __TEMP_LINE__.split(' ')
            __TEMP_LINE__ = [x.strip() for x in __TEMP_LINE__]
            __TEMP_LINE__: str = ' '.join(__TEMP_LINE__)
            __FOUND_START__ = False
            if '(' in __TEMP_LINE__ or ')' in __TEMP_LINE__:
                for index, char in enumerate(__TEMP_LINE__):
                    if char == '(' and __TEMP_LINE__[index - 2] == 'e' and __TEMP_LINE__[index - 3] == 'l' and __TEMP_LINE__[index - 4] == 'i' and __TEMP_LINE__[index - 5] == 'h' and __TEMP_LINE__[index - 6] == 'w':
                        # example: while ( true ) :
                        # output: while true:
                        __FOUND_START__ = True
                        __TEMP_LINE__ = __TEMP_LINE__[:index] + __TEMP_LINE__[index + 1:]
                    elif char == ')':
                        if __TEMP_LINE__[index + 1] == ':' or __TEMP_LINE__[index + 1] == '<' and __TEMP_LINE__[index + 2] == 'I' and __TEMP_LINE__[index + 3] == 'N' and __TEMP_LINE__[index + 4] == 'D' and __TEMP_LINE__[index + 5] == 'E' and __TEMP_LINE__[index + 6] == 'N' and __TEMP_LINE__[index + 7] == 'T':
                            # example: while true ) :
                            # output: while true:
                            if __FOUND_START__:
                                __TEMP_LINE__ = __TEMP_LINE__[:index - 1] + __TEMP_LINE__[index + 1:]
            __OUTPUT_LINE__ = __TEMP_LINE__
            return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
        @staticmethod
        def __STATIC_FOR__(__LINE__: list) -> str:
            global __INDENTATION_LEVEL__,    __INDENTATION_COUNT__, __IN_STATIC_FOR__, __STATIC_FOR_LINE__, __STATIC_FOR_CALLS__
            #print((' '.join(__LINE__)).replace('<INDENTATIONSEP>', '{'))
            MATCH = search(r'for\s*\((.+?)\|(.+?)\|(.+?)\)', (' '.join(__LINE__)).replace('<INDENTATIONSEP>', '{'))
            if not MATCH:
                __ERROR_REPORTING__(__LINE__, "badStaticForLoop")
            VARIABLE_TO_USE = MATCH.group(1).strip()
            CONDITION = MATCH.group(2).strip()
            INCREMENT = MATCH.group(3).strip()
            if VARIABLE_TO_USE.startswith(__GLOBAL_VARIABLES__.__DATA_TYPES__):
                VARIABLE_TO_USE = VARIABLE_TO_USE[len(VARIABLE_TO_USE.split(' ')[0]):].strip()
            __END_CONDITIONS__ = ('++', '--', '**', '//')
            __OTHER_CONDITIONS__ = ('<=', '>=', '==', '!=', '+=', '-=', '*=', '/=', '%=', '^=', '&=', '|=')
            if INCREMENT.endswith(__END_CONDITIONS__):
                if INCREMENT.endswith('++'):
                    INCREMENT = INCREMENT[:-3]
                    INCREMENT = f"{INCREMENT} += 1"
                elif INCREMENT.endswith('--'):
                    INCREMENT = INCREMENT[:-3]
                    INCREMENT = f"{INCREMENT} -= 1"
                elif INCREMENT.endswith('**'):
                    INCREMENT = INCREMENT[:-3]
                    INCREMENT = f"{INCREMENT} *= {INCREMENT[:2]}"
                elif INCREMENT.endswith('//'):
                    INCREMENT = INCREMENT[:-3]
                    INCREMENT = f"{INCREMENT} /= {INCREMENT[:2]}"
            else:
                # line could be: i+=1
                for condition in __OTHER_CONDITIONS__:
                    if condition in INCREMENT:
                        break
                else:
                    __ERROR_REPORTING__(__LINE__, "badStaticForLoop")

            #print(f"Variable: {__COLORS__['red']}\"{VARIABLE_TO_USE}\"{__COLORS__['reset']} | End Condition: {__COLORS__['red']}\"{CONDITION}\"{__COLORS__['reset']} | Increment: {__COLORS__['red']}\"{INCREMENT}\"{__COLORS__['reset']}")
            __OUTPUT_LINE__ = (__INDENTATION__*__INDENTATION_COUNT__) + VARIABLE_TO_USE + '\n'
            __OUTPUT_LINE__ += (__INDENTATION__*__INDENTATION_COUNT__) + 'while ' + CONDITION + ':'
            __STATIC_FOR_LINE__.append(INCREMENT)
            __IN_STATIC_FOR__.append(True)
            __STATIC_FOR_CALLS__ += 1
            return __OUTPUT_LINE__
        @staticmethod
        def __RETURN__(__LINE__: list) -> str:

            if len(__LINE__) == 1:
                __ERROR_REPORTING__(__LINE__, "badReturn")
            return (__INDENTATION__*__INDENTATION_COUNT__) + ' '.join(__LINE__)
    class __function__:
        __doc__ = """
        \n Inputs: the line to change
        \n Outputs: the line with the function changed
        \n Function: func, async func, await, coroutine
        """
        __slots__ = '__LINE__', 'RETURN_TYPE'
        @staticmethod
        def __FUNCTION__(__LINE__: list, RETURN_TYPE='') -> str:
            __LINE__ = [x.strip() for x in __LINE__]
            __LINE__ = __LINE__[1:]
            __LINE__.insert(0, 'def')

            __ARGS_IN_LINE__ = ' '.join(__LINE__[3:-2]).strip()
            __IN_STRING__ = False
            __TEMP_ARGS__ = []
            if __LINE__[1] in __GLOBAL_VARIABLES__.__OPRATOR_OVERLOADS__:
                if __INDENTATION_COUNT__ == 0: __ERROR_REPORTING__(__LINE__, "TriedOverloadingGlobalOperator", __LINE__[1])
                __LINE__[1] = __GLOBAL_VARIABLES__.__OPRATOR_OVERLOADS__[__LINE__[1]]
            word = ''
            for char in __ARGS_IN_LINE__:
                if char == '\"':
                    __IN_STRING__ = __LATCH__(__IN_STRING__)
                if char == '|' and not __IN_STRING__:
                    __TEMP_ARGS__.append(word.strip())
                    word = ''
                else:
                    word += char
            __TEMP_ARGS__.append(word.strip())
            for index in range(len(__TEMP_ARGS__)):
                if __TEMP_ARGS__[index].startswith(__GLOBAL_VARIABLES__.__DATA_TYPES__):
                    __TEMP_ARGS__[index] = __DATA_TYPE_TOKENS__[__TEMP_ARGS__[index].split(' ')[0]](__SPLIT_LINE__(__TEMP_ARGS__[index])).strip()
            __ASSIGN_FUNCTION__(__LINE__[1], "REGULAR", ' '.join(__LINE__[2:-1]))
            return ''.join([(__INDENTATION__*(__INDENTATION_COUNT__)), ' '.join(__LINE__[:2]), '(', ', '.join(__TEMP_ARGS__), ') ', RETURN_TYPE, ' '.join(__LINE__[-1:])])
        @staticmethod
        def __ASYNC_FUNCTION__(__LINE__: list) -> str:

            __LINE__ = [x.strip() for x in __LINE__]
            if 'method' in __LINE__:
                __ERROR_REPORTING__(__LINE__, 'UsedAsyncAndMethod')
            __LINE__ = __LINE__[2:]
            __LINE__.insert(0, 'def')
            __ARGS_IN_LINE__ = ' '.join(__LINE__[3:-2]).strip()
            __IN_STRING__ = False
            __TEMP_ARGS__ = []
            word = ''
            for char in __ARGS_IN_LINE__:
                if char == '\"':
                    __IN_STRING__ = __LATCH__(__IN_STRING__)
                if char == '|' and not __IN_STRING__:
                    __TEMP_ARGS__.append(word.strip())
                    word = ''
                else:
                    word += char
            __TEMP_ARGS__.append(word.strip())
            for index in range(len(__TEMP_ARGS__)):
                if __TEMP_ARGS__[index].startswith(__GLOBAL_VARIABLES__.__DATA_TYPES__):
                    __TEMP_ARGS__[index] = __DATA_TYPE_TOKENS__[__TEMP_ARGS__[index].split(' ')[0]](__SPLIT_LINE__(__TEMP_ARGS__[index]))
            __OUTPUT_LINE__ = ''.join([(__INDENTATION__*__INDENTATION_COUNT__), ' '.join(__LINE__[:2]), '(', ', '.join(__TEMP_ARGS__), ') ', ' '.join(__LINE__[-1:])])
            __ASSIGN_FUNCTION__(__LINE__[1], "ASYNC", ' '.join(__LINE__[2:-1]))
            return ''.join([((__INDENTATION__*__INDENTATION_COUNT__) + '@_async\n'), __OUTPUT_LINE__])
        @staticmethod
        def __AWAIT__(__LINE__: list) -> str:

            __OUTPUT_LINE__ = ''
            __LINE__ = [x.strip() for x in __LINE__]
            __LINE__ = __LINE__[1:]
            if '|' in __LINE__:
                __LINE__ = ' '.join(__LINE__).split('|')
                for index in range(len(__LINE__)):
                    __LINE__[index] += '.join()'
                    __OUTPUT_LINE__ += (__INDENTATION__*__INDENTATION_COUNT__) + __LINE__[index].strip() + '\n'
                return __OUTPUT_LINE__
            else:
                __LINE__.append('.join()')
                return (__INDENTATION__*__INDENTATION_COUNT__) + ' '.join(__LINE__)
        @staticmethod
        def __COROUTINE__(__LINE__: list) -> str:

            __RELEASE_POOL__: str = ''
            __ARGUMENTS__: list = []
            __FUNCTIONS__: list = []
            __AWAIT__: bool = False
            __OUTPUT_LINE__: str = ''
            __T_ARGUMENTS__: str = ''
            __C_LINE__ = __LINE__.copy()
            if __LINE__[1] == 'await':
                __AWAIT__ = True
                __LINE__.pop(1)
            if 'auto_clear' in __LINE__ and '=' in __LINE__:
                __RELEASE_POOL__ = f'TaskGroup.autorelease_pool({__LINE__[-1]})'
                try:
                    if isinstance(eval(__LINE__[-1]), bool): return (__INDENTATION__*__INDENTATION_COUNT__) + __RELEASE_POOL__
                    else: __ERROR_REPORTING__(__C_LINE__, "InvalidDynamicTask")
                except Exception:
                    __ERROR_REPORTING__(__C_LINE__, "InvalidDynamicTask")
                    return ''
                return (__INDENTATION__*__INDENTATION_COUNT__) + __RELEASE_POOL__
            elif 'clear' in __LINE__ and '()' in __LINE__:
                return (__INDENTATION__*__INDENTATION_COUNT__) + 'TaskGroup.clear()'
            elif 'exec' in __LINE__:
                return (__INDENTATION__*__INDENTATION_COUNT__) + f'TaskGroup.execute({" ".join(__LINE__[3:-1]).replace("|", ",")})'
            elif 'delete' in __LINE__:
                return (__INDENTATION__*__INDENTATION_COUNT__) + f'TaskGroup.remove({" ".join(__LINE__[3:-1]).replace("|", ",")})'
            elif '|' in __LINE__ or ( '(' in __LINE__ and ')' in __LINE__ ):
                __LINE__ = __LINE__[1:]
                __LINE__ = ' '.join(__LINE__).split('|') if '|' in __LINE__ else __LINE__
                __LINE__ = [x.strip() for x in __LINE__]
                if __LINE__[1] == '(' and __LINE__[-1] == ')':
                    __ARGUMENTS__.append(' '.join(__LINE__[2:-1]))
                    __FUNCTIONS__.append(__LINE__[0])
                else:
                    for i in range(len(__LINE__)):
                        if '(' in __LINE__[i] and ')' in __LINE__[i]:
                            for index, char in enumerate(__LINE__[i]):
                                if char == '(':
                                    __T_ARGUMENTS__ = __LINE__[i][index+1:]
                                    break
                            # now do the same loop in reverse
                            for index, char in enumerate(__LINE__[i][::-1]):
                                if char == ')':
                                    __T_ARGUMENTS__ += __LINE__[i][:index]
                                    break
                            __ARGUMENTS__.append(__T_ARGUMENTS__[:-1].strip())
                            __T_ARGUMENTS__ = ''
                            __FUNCTIONS__.append(__LINE__[i].split('(')[0].strip())
                for i, j in zip(__FUNCTIONS__, __ARGUMENTS__):
                    j = f", {j}" if j != '' else ''
                    __OUTPUT_LINE__ += (__INDENTATION__*__INDENTATION_COUNT__) + f"TaskGroup.add({i}{j})\n"
                return __OUTPUT_LINE__
            elif __LINE__.count('()') == 1:
                return (__INDENTATION__*__INDENTATION_COUNT__) + f"TaskGroup.add(task={__LINE__[1]})"
            else:
                __ERROR_REPORTING__(__C_LINE__, 'InvalidDynamicTask')
                return ' '
    class __variable__:
        __doc__ = """
        \n Inputs: the line to change
        \n Outputs: the line with the variable changed
        \n Variable: <all types>, const, refrence, kernel variables, let
        """
        __slots__ = '__LINE__'
        @staticmethod
        def __VARIABLE__(__LINE__: list) -> str:
            __ORG_LINE__: str = __LINE__.copy()
            __VAR_TYPE__: str = __LINE__[0]
            if 'enum' == __LINE__[1]: return __SYNTAX_ANALYSIS__.__data_classes__.__ENUM__(__LINE__[1:], __VAR_TYPE__)
            if __VAR_TYPE__ == __GLOBAL_VARIABLES__.__DATA_TYPES__:
                __ERROR_REPORTING__(__ORG_LINE__, 'InvalidDataType')
                return ' '

            if 'func' not in __LINE__:
                __VAR_NAME__: str = __ORG_LINE__[1]

                if '=' in __ORG_LINE__:
                    __VAR_ORG_VALUE__: str = (' '.join(__ORG_LINE__[__ORG_LINE__.index('=') + 1:])).strip()
                else:
                    __VAR_ORG_VALUE__: str = ''

                __LINE__= __LINE__[1:]
                __VAR_VALUE__: dict[str, str] = {}
                __VAR_ORG_VALUE__ = __VAR_ORG_VALUE__.strip()

                if __VAR_TYPE__ == 'list':
                    __VAR_NAME__ = __LINE__[4] if __LINE__[0] == '*' else __VAR_NAME__

                    __VAR_ORG_VALUE__ = __GLOBAL_VARIABLES__.__BLANK_DATA__[__VAR_TYPE__] if __VAR_ORG_VALUE__ == '' else __VAR_ORG_VALUE__

                    if '[' in __LINE__ and ']' in __LINE__ and '=' in __LINE__:
                        __ASSIGN_VARIABLE__(__VAR_NAME__, __VAR_TYPE__, __VAR_ORG_VALUE__)
                        if __LINE__[0] == '*':
                            if __VAR_ORG_VALUE__ != '': return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}*{int(__LINE__[2])}"
                            return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}*{int(__LINE__[2])}"
                        else:
                            if __VAR_ORG_VALUE__ != '': return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                            return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                    elif '=' not in __LINE__:
                        __ASSIGN_VARIABLE__(__VAR_NAME__, __VAR_TYPE__, __VAR_ORG_VALUE__)
                        if __LINE__[0] == '*':
                            if __VAR_ORG_VALUE__ != '': return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}*{int(__LINE__[2])}"
                            return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}*{int(__LINE__[2])}"
                        else:
                            if __VAR_ORG_VALUE__ != '': return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                            return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                    else: __ERROR_REPORTING__(__ORG_LINE__, 'InvalidTypeOfValue', type(eval(__VAR_ORG_VALUE__)).__name__, __VAR_TYPE__)

                elif __VAR_TYPE__ == 'map':
                    __VAR_TYPE__ = 'dict'
                    __VAR_NAME__ = __LINE__[4] if __LINE__[0] == '*' else __VAR_NAME__
                    __VAR_ORG_VALUE__ = __GLOBAL_VARIABLES__.__BLANK_DATA__[__VAR_TYPE__] if __VAR_ORG_VALUE__ == '' else __VAR_ORG_VALUE__
                    #print(__VAR_ORG_VALUE__, ' ', __VAR_NAME__)
                    if '{' in __LINE__ and '}' in __LINE__ and '=' in __LINE__:
                        __ASSIGN_VARIABLE__(__VAR_NAME__, __VAR_TYPE__, __VAR_ORG_VALUE__)
                        if __LINE__[0] == '*':
                            __ERROR_REPORTING__(__ORG_LINE__, 'CanNotFixSize')
                            return ' '
                        else:
                            if __VAR_ORG_VALUE__ != '': return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                            return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                    elif '=' not in __LINE__:
                        __ASSIGN_VARIABLE__(__VAR_NAME__, __VAR_TYPE__, __VAR_ORG_VALUE__)
                        if __LINE__[0] == '*':
                            __ERROR_REPORTING__(__ORG_LINE__, 'CanNotFixSize')
                            return ' '
                        else:
                            if __VAR_ORG_VALUE__ != '': return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                            return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"

                elif __VAR_TYPE__ == 'array':
                    __VAR_TYPE__ = 'tuple'
                    __VAR_NAME__ = __LINE__[4] if __LINE__[0] == '*' else __VAR_NAME__
                    __VAR_ORG_VALUE__ = __GLOBAL_VARIABLES__.__BLANK_DATA__[__VAR_TYPE__] if __VAR_ORG_VALUE__ == '' else __VAR_ORG_VALUE__
                    if '(' in __LINE__ and ')' in __LINE__ and '=' in __LINE__:
                        __ASSIGN_VARIABLE__(__VAR_NAME__, __VAR_TYPE__, __VAR_ORG_VALUE__)
                        if __LINE__[0] == '*':
                            __ERROR_REPORTING__(__ORG_LINE__, 'CanNotFixSize')
                            return ' '
                        else:
                            if __VAR_ORG_VALUE__ != '': return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                            return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                    elif '=' not in __LINE__:
                        __ASSIGN_VARIABLE__(__VAR_NAME__, __VAR_TYPE__, __VAR_ORG_VALUE__)
                        if __LINE__[0] == '*':
                            __ERROR_REPORTING__(__ORG_LINE__, 'CanNotFixSize')
                            return ' '
                        else:
                            if __VAR_ORG_VALUE__ != '': return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                            return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                    else: __ERROR_REPORTING__(__ORG_LINE__, 'InvalidTypeOfValue', type(eval(__VAR_ORG_VALUE__)).__name__, __VAR_TYPE__)

                elif __VAR_TYPE__ == 'set':
                    __VAR_NAME__ = __LINE__[4] if __LINE__[0] == '*' else __VAR_NAME__
                    __VAR_ORG_VALUE__ = __GLOBAL_VARIABLES__.__BLANK_DATA__[__VAR_TYPE__] if __VAR_ORG_VALUE__ == '' else __VAR_ORG_VALUE__
                    if '{' in __LINE__ and '}' in __LINE__ and '=' in __LINE__:
                        __ASSIGN_VARIABLE__(__VAR_NAME__, __VAR_TYPE__, __VAR_ORG_VALUE__)
                        if __LINE__[0] == '*':
                            __ERROR_REPORTING__(__ORG_LINE__, 'CanNotFixSize')
                            return ' '
                        else:
                            if __VAR_ORG_VALUE__ != '': return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                            return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                    elif '=' not in __LINE__:
                        __ASSIGN_VARIABLE__(__VAR_NAME__, __VAR_TYPE__, __VAR_ORG_VALUE__)
                        if __LINE__[0] == '*':
                            __ERROR_REPORTING__(__ORG_LINE__, 'CanNotFixSize')
                            return ' '
                        else:
                            if __VAR_ORG_VALUE__ != '': return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                            return f"{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                    else: __ERROR_REPORTING__(__ORG_LINE__, 'InvalidTypeOfValue', type(eval(__VAR_ORG_VALUE__)).__name__, __VAR_TYPE__)

                if ',' in __LINE__ and '|' not in __LINE__:
                    if '=' in __LINE__:
                        __LINE_AFTER__ = __LINE__[__LINE__.index('=') + 1:]
                        __LINE_AFTER__ = [ x for x in __LINE_AFTER__ if x != ',' ]
                        __LINE_BEFROE__ = __LINE__[:__LINE__.index('=')]
                        __LINE_BEFROE__ = [ x for x in __LINE_BEFROE__ if x != ',' ]
                        if len(__LINE_AFTER__) != len(__LINE_BEFROE__):
                            __ERROR_REPORTING__(__ORG_LINE__, 'InvalidNumberOfVariablesToValues')
                            return ' '
                    if '=' not in __LINE__:
                        for index, char in enumerate(__LINE__):
                            if char == ',':
                                __VAR_VALUE__[__LINE__[index - 1]] = 'None'
                        __VAR_VALUE__[__LINE__[-1]] = 'None'
                        __OUTPUT_LINE__: str = ''
                        for key, value in enumerate(__VAR_VALUE__):
                            __ASSIGN_VARIABLE__(value, __VAR_TYPE__, "None")
                            __OUTPUT_LINE__ += (__INDENTATION__*__INDENTATION_COUNT__) + value + ': ' + __VAR_TYPE__ + ' = ' + __GLOBAL_VARIABLES__.__BLANK_DATA__[__VAR_TYPE__] + '\n'
                    else:
                        for char in __LINE__:
                            if char == ',':
                                __LINE__.remove(char)
                        for index, char in enumerate(__LINE__):
                            if char == '=':
                                break
                            else:
                                __VAR_VALUE__[char] = __LINE_AFTER__[index]
                        # cound the number of terms before =, and after the =
                        for index, char in enumerate(__VAR_VALUE__):
                            # cehc if the matching value is __VAR_TYPE__
                            try:
                                if type(eval(__VAR_VALUE__[char])).__name__ != __VAR_TYPE__:
                                    __ERROR_REPORTING__(__ORG_LINE__, 'InvalidTypeOfValue', type(eval(__VAR_ORG_VALUE__)).__name__, __VAR_TYPE__)
                                    return ' '
                            except (SyntaxError, NameError): pass
                        __OUTPUT_LINE__: str = ''
                        for index, char in enumerate(__VAR_VALUE__):
                            __OUTPUT_LINE__ += (__INDENTATION__*__INDENTATION_COUNT__) + char + ': ' + __VAR_TYPE__ + ' = ' + __VAR_VALUE__[char] + '\n'
                            __ASSIGN_VARIABLE__(char, __VAR_TYPE__, __VAR_VALUE__[char])
                    return __OUTPUT_LINE__.replace('|', ',')
                elif '=' not in __LINE__:
                    for i in range(len(__LINE__)):
                        if __LINE__[i] == '|':
                            __LINE__[i] = ','
                    __ASSIGN_VARIABLE__(__LINE__[0], __VAR_TYPE__, 'None')
                    if __VAR_TYPE__ == 'usize':
                        return (__INDENTATION__*__INDENTATION_COUNT__) + __VAR_NAME__ + ' = ' + 'None'
                    return (__INDENTATION__*__INDENTATION_COUNT__) + __VAR_NAME__ + ': ' + __VAR_TYPE__ + ' = ' + __GLOBAL_VARIABLES__.__BLANK_DATA__[__VAR_TYPE__] + '\n'
                if __VAR_TYPE__ != 'usize':
                    for i in range(len(__LINE__)):
                        if __LINE__[i] == '|':
                            __LINE__[i] = ','
                    try:
                        if type(eval(__VAR_ORG_VALUE__)).__name__ != __VAR_TYPE__ and __VAR_TYPE__ in __GLOBAL_VARIABLES__.__DATA_TYPES__:
                            __ERROR_REPORTING__(__ORG_LINE__, 'InvalidTypeOfValue', type(eval(__VAR_ORG_VALUE__)).__name__, __VAR_TYPE__)
                            return ' '
                        __OUTPUT_LINE__: str = f"{__ORG_LINE__[1]}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                    except NameError:
                        __OUTPUT_LINE__: str = f"{__ORG_LINE__[1]}: {__VAR_TYPE__} = {__VAR_ORG_VALUE__}"
                    except SyntaxError:
                        __ERROR_REPORTING__(__ORG_LINE__, 'InvalidKeyword', __VAR_ORG_VALUE__)
                        return ' '
                    __ASSIGN_VARIABLE__(__ORG_LINE__[1], __VAR_TYPE__, __VAR_ORG_VALUE__)
                    return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__]).replace('|', ',')
                else:
                    for i in range(len(__LINE__)):
                        if __LINE__[i] == '|':
                            __LINE__[i] = ','
                    __ASSIGN_VARIABLE__(__ORG_LINE__[1], __VAR_TYPE__, __VAR_ORG_VALUE__)
                    __OUTPUT_LINE__ = (__INDENTATION__*__INDENTATION_COUNT__) + ' '.join(__LINE__)
                    return __OUTPUT_LINE__.replace('|', ',')
            else:
                __VAR_NAME__: str = __LINE__[2]
                __VAR_VALUE__: str = ' '.join(__LINE__[3:-1])
                if __VAR_TYPE__ == 'usize':
                    __RETURN_TYPE__: str = f'-> None'
                elif __VAR_TYPE__ == 'fronzenSet':
                    __RETURN_TYPE__: str = f'-> _FROZENSET_'
                elif __VAR_TYPE__ == 'NoneType':
                    __ERROR_REPORTING__(__ORG_LINE__, f'NullTypeFunction')
                    return ' '
                else: __RETURN_TYPE__: str = f'-> {__VAR_TYPE__}'
                __OUTPUT_LINE__: str = __SYNTAX_ANALYSIS__.__function__.__FUNCTION__(__LINE__[1:], __RETURN_TYPE__)
                return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__]) + '\n'
        @staticmethod
        def __CONSTANT__(__LINE__: list) -> str:
            if __INDENTATION_COUNT__ != 0: __ERROR_REPORTING__(__LINE__, 'ConstCallOutsideGlobal'); return ' '
            # remove the first element of the list
            __LINE__ = __LINE__[1:]
            __ORG_LINE__: str = __LINE__.copy()

            __VAR_TYPE__: str = __LINE__[0]

            if __VAR_TYPE__ not in __GLOBAL_VARIABLES__.__DATA_TYPES__:
                __ERROR_REPORTING__(__LINE__, 'InvalidDataType')
                return ' '
            __VAR_NAME__: str = __ORG_LINE__[1]
            if '=' in __ORG_LINE__:
                __VAR_ORG_VALUE__: str = ' '.join(__ORG_LINE__[__ORG_LINE__.index('=') + 1:])
            else:
                __VAR_ORG_VALUE__: str = ''
            __LINE__= __LINE__[1:]
            __VAR_VALUE__: dict[str, str] = {}

            if   __VAR_TYPE__ == 'dict':
                # check if there is a , before the =
                if ',' in __LINE__[:__LINE__.index('=') - 1]:
                    __ERROR_REPORTING__(__LINE__, 'TriedToAssignValueToMultipleVariables')
                    return ' '
                __VAR_VALUE__: str = '{'
                if 'dict' in __LINE__: __LINE__.remove('dict')
                __LINE__ = __LINE__[3:]
                for index, item in enumerate(__LINE__):
                    if index % 2 == 0:
                        __VAR_VALUE__ += item + ' '
                    else:
                        __VAR_VALUE__ += item + ' '
                __VAR_VALUE__ = __VAR_VALUE__[:-3]
                __VAR_VALUE__ += '}'
                __OUTPUT_LINE__: str = f"{__ORG_LINE__[1]}: {__VAR_TYPE__} = {__VAR_VALUE__}"
                __ASSIGN_VARIABLE__(__ORG_LINE__[1], __VAR_TYPE__, __VAR_VALUE__)
                return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
            elif __VAR_TYPE__ == 'list':
                # check if there is a , before the =
                if ',' in __LINE__[:__LINE__.index('=') - 1]:
                    __ERROR_REPORTING__(__LINE__, 'TriedToAssignValueToMultipleVariables')
                    return ' '
                __VAR_VALUE__: str = '['
                if 'list' in __LINE__: __LINE__.remove('list')
                __LINE__ = __LINE__[3:]
                for index, item in enumerate(__LINE__):
                    if index % 2 == 0:
                        __VAR_VALUE__ += item + ' '
                    else:
                        __VAR_VALUE__ += item + ' '
                __VAR_VALUE__ = __VAR_VALUE__[:-3]
                __VAR_VALUE__ += ']'
                __OUTPUT_LINE__: str = f"{__ORG_LINE__[1]}: {__VAR_TYPE__} = {__VAR_VALUE__}"
                __ASSIGN_VARIABLE__(__ORG_LINE__[1], __VAR_TYPE__, __VAR_VALUE__)
                return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
            elif __VAR_TYPE__ == 'tuple':
                # check if there is a , before the =
                if ',' in __LINE__[:__LINE__.index('=') - 1]:
                    __ERROR_REPORTING__(__LINE__, 'TriedToAssignValueToMultipleVariables')
                    return ' '
                __VAR_VALUE__: str = '('
                if 'tuple' in __LINE__: __LINE__.remove('tuple')
                __LINE__ = __LINE__[3:]
                for index, item in enumerate(__LINE__):
                    if index % 2 == 0:
                        __VAR_VALUE__ += item + ' '
                    else:
                        __VAR_VALUE__ += item + ' '
                __VAR_VALUE__ = __VAR_VALUE__[:-3]
                __VAR_VALUE__ += ')'
                __OUTPUT_LINE__: str = f"{__ORG_LINE__[1]}: {__VAR_TYPE__} = {__VAR_VALUE__}"
                __ASSIGN_VARIABLE__(__ORG_LINE__[1], __VAR_TYPE__, __VAR_VALUE__)
                return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
            elif __VAR_TYPE__ == 'set':
                # check if there is a , before the =
                if ',' in __LINE__[:__LINE__.index('=') - 1]:
                    __ERROR_REPORTING__(__LINE__, 'TriedToAssignValueToMultipleVariables')
                    return ' '
                __VAR_VALUE__: str = '{'
                if 'set' in __LINE__: __LINE__.remove('set')
                __LINE__ = __LINE__[3:]
                for index, item in enumerate(__LINE__):
                    if index % 2 == 0:
                        __VAR_VALUE__ += item + ' '
                    else:
                        __VAR_VALUE__ += item + ' '
                __VAR_VALUE__ = __VAR_VALUE__[:-3]
                __VAR_VALUE__ += '}'
                __OUTPUT_LINE__: str = f"{__ORG_LINE__[1]}: {__VAR_TYPE__} = {__VAR_VALUE__}"
                __ASSIGN_VARIABLE__(__ORG_LINE__[1], __VAR_TYPE__, __VAR_VALUE__)
                return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
            elif __VAR_TYPE__ == 'fronzenset':
                __OUTPUT_LINE__ = ' '.join(__LINE__)
                __ASSIGN_VARIABLE__(__ORG_LINE__[1], __VAR_TYPE__, __VAR_VALUE__)
                return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])

            if ',' in __LINE__:
                if '=' in __LINE__:
                    __LINE_AFTER__ = __LINE__[__LINE__.index('=') + 1:]
                    __LINE_AFTER__ = [ x for x in __LINE_AFTER__ if x != ',' ]
                    __LINE_BEFROE__ = __LINE__[:__LINE__.index('=')]
                    __LINE_BEFROE__ = [ x for x in __LINE_BEFROE__ if x != ',' ]
                    if len(__LINE_AFTER__) != len(__LINE_BEFROE__):
                        __ERROR_REPORTING__(__LINE__, 'InvalidNumberOfVariablesToValues')
                        return ' '
                if '=' not in __LINE__:
                    for index, char in enumerate(__LINE__):
                        if char == ',':
                            __VAR_VALUE__[__LINE__[index - 1]] = 'None'
                    __VAR_VALUE__[__LINE__[-1]] = 'None'
                    __OUTPUT_LINE__: str = ''
                    for key, value in enumerate(__VAR_VALUE__):
                        __ASSIGN_VARIABLE__(value, __VAR_TYPE__, "None")
                        __OUTPUT_LINE__ += (__INDENTATION__*__INDENTATION_COUNT__) + value + ': ' + __VAR_TYPE__ + ' = ' + __GLOBAL_VARIABLES__.__BLANK_DATA__[__VAR_TYPE__] + '\n'
                else:
                    for char in __LINE__:
                        if char == ',':
                            __LINE__.remove(char)
                    for index, char in enumerate(__LINE__):
                        if char == '=':
                            break
                        else:
                            __VAR_VALUE__[char] = __LINE_AFTER__[index]
                    # cound the number of terms before =, and after the =
                    for index, char in enumerate(__VAR_VALUE__):
                        # cehc if the matching value is __VAR_TYPE__
                        if type(eval(__VAR_VALUE__[char])).__name__ != __VAR_TYPE__:
                            __ERROR_REPORTING__(__LINE__, 'InvalidTypeOfValue', type(eval(__VAR_VALUE__[char])).__name__, __VAR_TYPE__)
                            return ' '
                    __OUTPUT_LINE__: str = ''
                    for index, char in enumerate(__VAR_VALUE__):
                        __OUTPUT_LINE__ += (__INDENTATION__*__INDENTATION_COUNT__) + char + ': ' + __VAR_TYPE__ + ' = ' + __VAR_VALUE__[char] + '\n'
                        __ASSIGN_VARIABLE__(char, __VAR_TYPE__, __VAR_VALUE__[char])
                return __OUTPUT_LINE__

            if __VAR_TYPE__ != 'usize':
                if type(eval(__VAR_ORG_VALUE__)).__name__ != __VAR_TYPE__:
                    __ERROR_REPORTING__(__LINE__, 'InvalidTypeOfValue', type(eval(__VAR_ORG_VALUE__)).__name__, __VAR_TYPE__)
                    return ' '
            __OUTPUT_LINE__: str = f"{__ORG_LINE__[1]}: {__VAR_TYPE__ if __VAR_TYPE__ != 'usize' else 'object'} = {__VAR_ORG_VALUE__}"
            __ASSIGN_VARIABLE__(__ORG_LINE__[1], __VAR_TYPE__, __VAR_ORG_VALUE__)
            return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
        @staticmethod
        def __REFERENCE__(__LINE__: list) -> str:

            # check if what is after the = is declared
            if '=' in __LINE__:
                for index, char in enumerate(__LINE__):
                    if char == '(':
                        break
                __VAR_NAME__: str = __LINE__[index - 1]
                if __CHECK_IF_DELARED__(__VAR_NAME__, __LINE__, ERROR='InvalidRefrence') is False:
                    if __VAR_NAME__ != 'pack' or __VAR_NAME__ != 'unpack' or __VAR_NAME__ != 'frozenset' or __VAR_NAME__ != 'exec' or __VAR_NAME__ != 'alloc' or __VAR_NAME__ != 'free':
                        return ' '
                __OUTPUT_LINE__: str = (' '.join(__LINE__))[4:]
                # remove the first 4 characters from output line
                return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
            else:
                for i in range(len(__LINE__)):
                    if __LINE__[i] == 'ref':
                        __LINE__[i] = 'global'
                        break
                __OUTPUT_LINE__: str = ' '.join(__LINE__)
                return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
        @staticmethod
        def __KERNEL_VARS__(__LINE__: list) -> str:

            def __check_int__(value, __LINE__, upper_limit, lower_limit) -> bool:
                if type(eval(value)) != int:
                    __ERROR_REPORTING__(__LINE__, 'InvalidTypeOfValue', type(eval(value)).__name__)
                    return False
                if eval(value) > upper_limit or eval(value) < lower_limit:
                    # if the value is in hex format then convert it to int else just print the value
                    if value[0] == '0' and value[1] == 'x':
                        value = f'{__COLORS__["yellow"]}{value} ' + f'({int(value, 16):,}){__COLORS__["red"]},'
                    __ERROR_REPORTING__(__LINE__, 'InvalidValue', value, f"Must be between {lower_limit} and {upper_limit}")
                    return False
                return True
            def __check_float__(value, __LINE__, upper_limit, lower_limit) -> bool:
                if type(eval(value)) != float:
                    __ERROR_REPORTING__(__LINE__, 'InvalidTypeOfValue', type(eval(value)).__name__)
                    return False
                if eval(value) > upper_limit or eval(value) < lower_limit:
                    __ERROR_REPORTING__(__LINE__, 'InvalidValue', value, f"Must be between {lower_limit} and {upper_limit}")
                    return False
                return True
            __KERNAL_UNDEFINED__: set[str]      = ('u64', 'u8', 'u16', 'u32', 'u64', 'u128')
            __KERNAL_DEFINED_INT__: set[str]    = ('i8 ', 'i16', 'i32', 'i64', 'i128')
            __KERNAL_DEFINED_FLOATS__: set[str] = ('f32', 'f64')
            __VAR_TYPE__: str = __LINE__[0].strip()
            __VAR_NAME__: list[str] = __LINE__[1:]
            if '=' in __LINE__:
                __VAR_NAME__ = __LINE__[1:__LINE__.index('=')]
                __VAR_VALUE__: list[str] = __LINE__[__LINE__.index('=') + 1:]
                __VAR_VALUE__ = [i for i in __VAR_VALUE__ if i != ',']
                if __VAR_TYPE__ in __KERNAL_UNDEFINED__:
                    __ERROR_REPORTING__(__LINE__, 'InvalidTypeOfValue', __VAR_TYPE__, 'Unsigned', type(eval(__VAR_VALUE__[0])).__name__)
                    return ''
                if len(__VAR_NAME__) != len(__VAR_VALUE__):
                    __ERROR_REPORTING__(__LINE__, 'InvalidNumberOfVariablesToValues')
                    return ' '
            else:
                if __VAR_TYPE__ in __KERNAL_DEFINED_INT__ or __VAR_TYPE__ in __KERNAL_DEFINED_FLOATS__:
                    __ERROR_REPORTING__(__LINE__, 'InvalidTypeOfValue', __VAR_TYPE__, 'Unsigned')
                    return ''
            __VAR_NAME__ = [i for i in __VAR_NAME__ if i != ',']

            if __VAR_TYPE__ in str(__KERNAL_UNDEFINED__):
                __LINE__ = __LINE__[1:]
                __LINE__.append(': int = 0')
                __ASSIGN_VARIABLE__(__LINE__[0], __VAR_TYPE__, "None")
                return (__INDENTATION__*__INDENTATION_COUNT__) + ' '.join(__LINE__)

            if __VAR_TYPE__ in str(__KERNAL_DEFINED_INT__):
                if __VAR_TYPE__ == 'i8':
                    # check if the value is an 8 bit integer
                    for index, value in enumerate(__VAR_VALUE__):
                        if __check_int__(value, __LINE__, 127, -128) is False:
                            return ' '
                if __VAR_TYPE__ == 'i16':
                    # check if the value is an 16 bit integer
                    for index, value in enumerate(__VAR_VALUE__):
                        if __check_int__(value, __LINE__, 32767, -32768) is False:
                            return ' '
                if __VAR_TYPE__ == 'i32':
                    # check if the value is an 32 bit integer
                    for index, value in enumerate(__VAR_VALUE__):
                        if __check_int__(value, __LINE__, 2147483647, -2147483648) is False:
                            return ' '
                if __VAR_TYPE__ == 'i64':
                    # check if the value is an 64 bit integer
                    for index, value in enumerate(__VAR_VALUE__):
                        if __check_int__(value, __LINE__, 9223372036854775807, -9223372036854775808) is False:
                            return ' '
                if __VAR_TYPE__ == 'i128':
                    # check if the value is an 128 bit integer
                    for index, value in enumerate(__VAR_VALUE__):
                        if __check_int__(value, __LINE__, 170141183460469231731687303715884105727, -170141183460469231731687303715884105728) is False:
                            return ' '
            if __VAR_TYPE__ in str(__KERNAL_DEFINED_FLOATS__):
                if __VAR_TYPE__ == 'f32':
                    # check if the value is a 32 bit float
                    for index, value in enumerate(__VAR_VALUE__):
                        if __check_float__(value, __LINE__, 3.4028234663852886e+38, -3.4028234663852886e+38) is False:
                            return ' '
                if __VAR_TYPE__ == 'f64':
                    # check if the value is a 64 bit float
                    for index, value in enumerate(__VAR_VALUE__):
                        if __check_float__(value, __LINE__, 1.7976931348623157e+308, -1.7976931348623157e+308) is False:
                            return ' '
            __OUTPUT_LINE__: str = ''
            for index, value in enumerate(__VAR_NAME__):
                __OUTPUT_LINE__ += f'{__INDENTATION__*__INDENTATION_COUNT__}{value.strip()} = {__VAR_VALUE__[index]}\n'
                __ASSIGN_VARIABLE__(value.strip(), __VAR_TYPE__, __VAR_VALUE__[index])
            return __OUTPUT_LINE__
        @staticmethod
        def __LETTER__(__LINE__: list) -> str:
            if __CHECK_IF_DELARED__(__LINE__[1], __LINE__, ERROR='VariableNotDeclared') is False:
                return ' '
            return f'{__INDENTATION__*__INDENTATION_COUNT__}{" ".join(__LINE__[1:])}'
        @staticmethod
        def __FINAL__(__LINE__: list) -> str:
            __OUTPUT__ = __LINE__[1:] + [':', 'Final']
            if '=' in __OUTPUT__:
                __ERROR_REPORTING__(__LINE__, 'TriedToAssignValueToFinal')
                return ' '
            if 'ptr' in __LINE__ and '<' in __LINE__ and '>' in __LINE__:
                # line: final<ptr> var_name
                __VAR_NAME__ = __LINE__[__LINE__.index('>')+1]
                return f'{__INDENTATION__*__INDENTATION_COUNT__}{__VAR_NAME__} = {__VAR_NAME__}[0]'
            return f'{__INDENTATION__*__INDENTATION_COUNT__}{" ".join(__OUTPUT__)}'
        @staticmethod
        def __COPY__(__LINE__: list) -> str:
            # line: copy var_name = new_var_name
            # output: new_var_name = var_name
            # create a regex to get the var name and the new var name
            if len(__LINE__) != 5:
                __ERROR_REPORTING__(__LINE__, 'InvalidCopySyntax')
                return ' '
            __VAR_NAME__ = __LINE__[1]
            __NEW_VAR_NAME__ = __LINE__[4]
            return f'{__INDENTATION__*__INDENTATION_COUNT__}{__NEW_VAR_NAME__} = copy({__VAR_NAME__})'
    class __data_classes__:
        __doc__ = """
        \n Inputs: the line to change
        \n Outputs: the line with the changes
        \n Variable: struct, static, enum, class
        """
        __slots__ = '__LINE__', '__TYPE__'
        @staticmethod
        def __STRUCT__(__LINE__: list) -> str:

            if '=' in __LINE__:
                __ERROR_REPORTING__(__LINE__, 'TriedToAssignValueToDataClass')
                return ' '
            __ORG_LINE__: str = __LINE__.copy()
            __LINE__[0] = f'{__INDENTATION__*__INDENTATION_COUNT__}class'
            __OUTPUT_LINE__: str = ' '.join(__LINE__)
            __OUTPUT_LINE__ = f"{__INDENTATION__*__INDENTATION_COUNT__}@dataclass(slots=True)\n" + __OUTPUT_LINE__
            __ASSIGN_CLASS__(__ORG_LINE__[1], "STRUCT")

            return __OUTPUT_LINE__
        @staticmethod
        def __STATIC__(__LINE__: list) -> str:
            # remove the first word

            __ORG_LINE__ = __LINE__.copy()
            if 'enum' in __LINE__:
                __ORG_LINE__: str = __LINE__.copy()
                __LINE__ = __LINE__[1:]
                __LINE__[0] = f'{__INDENTATION__*__INDENTATION_COUNT__}class'
                __OUTPUT_LINE__: str = ' '.join(__LINE__)
                __ASSIGN_CLASS__(__ORG_LINE__[2], "STAIC ENUM")
                return __OUTPUT_LINE__
            elif 'struct' in __LINE__:
                __ORG_LINE__: str = __LINE__.copy()
                __LINE__ = __LINE__[1:]
                __LINE__[0] = f'{__INDENTATION__*__INDENTATION_COUNT__}class'
                __OUTPUT_LINE__: str = ' '.join(__LINE__)
                __OUTPUT_LINE__ = f"{__INDENTATION__*__INDENTATION_COUNT__}@dataclass(slots=True)\n" + __OUTPUT_LINE__
                __ASSIGN_CLASS__(__ORG_LINE__[1], "STAIC STRUCT")
                return __OUTPUT_LINE__
            __LINE__[0] = ''
            __LINE__ = [ x for x in __LINE__ if x != '' ]
            __LINE__.append(': Final')
            __OUTPUT_LINE__: str = ' '.join(__LINE__)
            # get the value of the variable
            try:
                __VAR_VALUE__ = __GET_VARIABLE__(__LINE__[0], 0)
            except KeyError:
                __ERROR_REPORTING__(__ORG_LINE__, 'VariableNotDeclared', __LINE__[0])
                return ' '
            __ASSIGN_VARIABLE__(__LINE__[0], "STATIC", __GET_VARIABLE__(__LINE__[0], 0))
            return ''.join([(__INDENTATION__*__INDENTATION_COUNT__), __OUTPUT_LINE__])
        @staticmethod
        def __ENUM__(__LINE__: list, __TYPE__=None) -> str:
            # enum.IntEnum
            if __TYPE__ == None:
                __ORG_LINE__: str = __LINE__.copy()
                __LINE__[0] = f'{__INDENTATION__*__INDENTATION_COUNT__}class'
                __OUTPUT_LINE__: str = ' '.join(__LINE__)
                __ASSIGN_CLASS__(__ORG_LINE__[1], "ENUM")
                return __OUTPUT_LINE__
            else:
                if __TYPE__ == 'int':
                    __TYPE__ = 'IntEnum'
                elif __TYPE__ == 'str':
                    __TYPE__ = 'StrEnum'
                else:
                    __LINE__.insert(0, __TYPE__)
                    __ERROR_REPORTING__(__LINE__, 'InvalidEnumType')
                    return ' '
                __ORG_LINE__: str = __LINE__.copy()
                __LINE__[0] = f'{__INDENTATION__*__INDENTATION_COUNT__}class'
                __LINE__[1] = __LINE__[1] + f'(enum.{__TYPE__})'
                __OUTPUT_LINE__: str = ' '.join(__LINE__)
                __ASSIGN_CLASS__(__ORG_LINE__[1], "ENUM")
                return __OUTPUT_LINE__
        @staticmethod
        def __CLASS__(__LINE__: list) -> str:
            __LINE__ = [x.strip() for x in __LINE__]
            __LINE__ = __LINE__[1:]
            __LINE__.insert(0, 'class')
            __ASSIGN_CLASS__(__LINE__[1], "REGULAR")
            return (__INDENTATION__*__INDENTATION_COUNT__) + ' '.join(__LINE__)
        @staticmethod
        def __POINTER__(__LINE__: list) -> str:
            # TODO: add error reporting, if the variable is not declared, assign it to the variable, and other checks
            for index, i in enumerate(__LINE__):
                if i == '=': 
                    break
            __VAR_VAL__ = ' '
            if len(__LINE__) >= index+2:
                if __LINE__[index+1] == 'new':
                    __VAR_VAL__ = ' '.join(__LINE__[index+2:])
                else:
                    __VAR_VAL__ = ' '.join(__LINE__[index+1:])
            __OUTPUT_LINE__: str = ' '
            __OUTPUT_LINE__ = f"{__INDENTATION__*__INDENTATION_COUNT__}{__LINE__[1]} = [{__VAR_VAL__}]"
            if 'ref' in __LINE__ and '<' in __LINE__ and '>' in __LINE__:
                __OUTPUT_LINE__ = f"{__INDENTATION__*__INDENTATION_COUNT__}{__LINE__[4]} = {__VAR_VAL__}"
            elif len(__LINE__) >= index+2:
                if __LINE__[index+1] == 'new':
                    __OUTPUT_LINE__ = f"{__INDENTATION__*__INDENTATION_COUNT__}{__LINE__[1]}[0] = {__VAR_VAL__}"
            return __OUTPUT_LINE__
                
__KEYWORD_TOKENS__: dict[str, object] = {
    # ------------------------------ ACCESS MODIFIERS ------------------------------- #
    'public'           : __SYNTAX_ANALYSIS__. __access_modifiers__ .__PUBLIC__        ,
    'priv'             : __SYNTAX_ANALYSIS__. __access_modifiers__ .__PRIVATE__       ,
    'method'           : __SYNTAX_ANALYSIS__. __access_modifiers__ .__METHOD__        ,
    'with'             : __SYNTAX_ANALYSIS__. __access_modifiers__ .__WITH__          ,
    'call'             : __SYNTAX_ANALYSIS__. __access_modifiers__ .__CALL__          ,
    # -------------------------------- CONTROL FLOW --------------------------------- #
    'if'               : __SYNTAX_ANALYSIS__.   __control_flow__   .__IF__            ,
    'else'             : __SYNTAX_ANALYSIS__.   __control_flow__   .__ELSE__          ,
    'else if'          : __SYNTAX_ANALYSIS__.   __control_flow__   .__ELSE_IF__       ,
    'for'              : __SYNTAX_ANALYSIS__.   __control_flow__   .__FOR__           ,
    'while'            : __SYNTAX_ANALYSIS__.   __control_flow__   .__WHILE__         ,
    'return'           : __SYNTAX_ANALYSIS__.   __control_flow__   .__RETURN__        ,
    # -------------------------------- DATA CLASSES --------------------------------- #
    'class'            : __SYNTAX_ANALYSIS__.   __data_classes__   .__CLASS__         ,
    'struct'           : __SYNTAX_ANALYSIS__.   __data_classes__   .__STRUCT__        ,
    'static'           : __SYNTAX_ANALYSIS__.   __data_classes__   .__STATIC__        ,
    'enum'             : __SYNTAX_ANALYSIS__.   __data_classes__   .__ENUM__          ,
    'ptr'              : __SYNTAX_ANALYSIS__.   __data_classes__   .__POINTER__       ,
    # --------------------------------- FUNCTIONS ----------------------------------- #
    'func'             : __SYNTAX_ANALYSIS__.     __function__     .__FUNCTION__      ,
    'async'            : __SYNTAX_ANALYSIS__.     __function__     .__ASYNC_FUNCTION__,
    'await'            : __SYNTAX_ANALYSIS__.     __function__     .__AWAIT__         ,
    'coroutine'        : __SYNTAX_ANALYSIS__.     __function__     .__COROUTINE__     ,
    # --------------------------------- VARIABLES ----------------------------------- #
    'const'            : __SYNTAX_ANALYSIS__.     __variable__     .__CONSTANT__      ,
    'ref'              : __SYNTAX_ANALYSIS__.     __variable__     .__REFERENCE__     ,
    'copy'             : __SYNTAX_ANALYSIS__.     __variable__     .__COPY__          ,
    'let'              : __SYNTAX_ANALYSIS__.     __variable__     .__LETTER__        ,
    'final'            : __SYNTAX_ANALYSIS__.     __variable__     .__FINAL__         ,
    # ------------------------------- INPUT/OUTPUT ---------------------------------- #
    'out'              : __SYNTAX_ANALYSIS__.        __io__        .__OUTPUT__        ,
    'in'               : __SYNTAX_ANALYSIS__.        __io__        .__INPUT__         ,
    'include'          : __SYNTAX_ANALYSIS__.        __io__        .__INCLUDE__       ,
    'import'           : __SYNTAX_ANALYSIS__.        __io__        .__IMPORT__        ,
    'from'             : __SYNTAX_ANALYSIS__.        __io__        .__FROM__          ,
    'pyc'              : __SYNTAX_ANALYSIS__.        __io__        .__PYC__           ,
    # ------------------------------ End of Tokens ---------------------------------- #
    }
__METHOD_CALL_TOKENS__: dict[str, object] = {
    # --------------------------------- METHODS ------------------------------------- #
    '@'                : __SYNTAX_ANALYSIS__. __access_modifiers__ .__AT__            ,
    # ------------------------------ End of Tokens ---------------------------------- #
    }
__DATA_TYPE_TOKENS__: dict[str, object] = {
    # -------------------------------- DATA TYPES ----------------------------------- #
    'int'              : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'float'            : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'complex'          : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'double'           : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'str'              : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'usize'            : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'bool'             : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'list'             : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'map'              : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'array'            : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'set'              : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'bytes'            : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'char'             : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'memoryview'       : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'bytearray'        : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'frozenset'        : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'range'            : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'None'             : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    'NoneType'         : __SYNTAX_ANALYSIS__.     __variable__     .__VARIABLE__      ,
    # ----------------------------- KERNEL VARIABLES -------------------------------- #
    'u8'               : __SYNTAX_ANALYSIS__.     __variable__     .__KERNEL_VARS__   ,
    'u16'              : __SYNTAX_ANALYSIS__.     __variable__     .__KERNEL_VARS__   ,
    'u32'              : __SYNTAX_ANALYSIS__.     __variable__     .__KERNEL_VARS__   ,
    'u64'              : __SYNTAX_ANALYSIS__.     __variable__     .__KERNEL_VARS__   ,
    'u128'             : __SYNTAX_ANALYSIS__.     __variable__     .__KERNEL_VARS__   ,
    'i8'               : __SYNTAX_ANALYSIS__.     __variable__     .__KERNEL_VARS__   ,
    'i16'              : __SYNTAX_ANALYSIS__.     __variable__     .__KERNEL_VARS__   ,
    'i32'              : __SYNTAX_ANALYSIS__.     __variable__     .__KERNEL_VARS__   ,
    'i64'              : __SYNTAX_ANALYSIS__.     __variable__     .__KERNEL_VARS__   ,
    'i128'             : __SYNTAX_ANALYSIS__.     __variable__     .__KERNEL_VARS__   ,
    'f32'              : __SYNTAX_ANALYSIS__.     __variable__     .__KERNEL_VARS__   ,
    'f64'              : __SYNTAX_ANALYSIS__.     __variable__     .__KERNEL_VARS__   ,
    # ------------------------------ End of Tokens ---------------------------------- #
    }
__TOKENS__: dict[str, object] = {}
__TOKENS__.update(__KEYWORD_TOKENS__)
__TOKENS__.update(__METHOD_CALL_TOKENS__)
__TOKENS__.update(__DATA_TYPE_TOKENS__)
__TOKENS_T_ = tuple(__TOKENS__.keys())

def memoize(func):
    memo = {}
    def helper(*args):
        if args not in memo:
            memo[args] = func(*args)
        return memo[args]
    return helper

# ----------- Wrapper Functions ----------- #
def MEMOIZE(func):
    @wraps(func)
    def __MEMOIZE__FUNCTION__(*args, **kwargs):
        __KEY__ = args + tuple(kwargs.items())
        if __KEY__ not in __MEMOIZE__FUNCTION__.cache:
            __MEMOIZE__FUNCTION__.cache[__KEY__] = func(*args, **kwargs)
        return __MEMOIZE__FUNCTION__.cache[__KEY__]
    __MEMOIZE__FUNCTION__.cache: OrderedDict = OrderedDict()
    return __MEMOIZE__FUNCTION__
def ASYNC(func):
    """ This is a decorator for async functions """
    def __ASYNC__FUNCTION__(*args, **kwargs):
        """ This is the wrapper function that will be returned """
        thread = Thread(target=func, args=args, kwargs=kwargs)
        thread.start()
        return thread
    return __ASYNC__FUNCTION__
def OVERLOAD(*__TYPES__):
    def __register__(FUNCTION):
        NAME = FUNCTION.__name__
        __D_INST__ = __OVERLOAD_FUNCTION_REG__.get(NAME)
        if __D_INST__ is None:
            __D_INST__ = __OVERLOAD_FUNCTION_REG__[NAME] = __DISPATCH__(NAME)
        __D_INST__.__register__(__TYPES__, FUNCTION)
        return __D_INST__
    return __register__
def EXEC_TIME(fn) -> object:
    """
    A decorator that prints the execution time for the decorated function. (in this case the __INITIALIZER__ function)
    """
    def wrapper_function(*args, **kwargs):
        start_time = perf_counter()
        # invoking the wrapped function and getting the return value.
        value = fn(*args, **kwargs)
        time_diff = perf_counter() - start_time
        # round the time difference to 5 decimal places
        time_diff = round(time_diff, 5)
        temp_time_diff = str(time_diff).split('.')
        from random import randint
        ammount = randint(1, 9)
        # check what the first nuber is in temp_time_diff[1]
        while True:
            if int(temp_time_diff[1][0]) - ammount < 0:
                ammount -= 1
            else: break
        if ammount <= 0:
            ammount = 0
        ammount = f"0.{ammount}"
        ammount = float(ammount)
        if time_diff-ammount <= 0.0:
            ammount = 0.0
        # get the exit code of the process
        from sys import platform
        from os import getpid
        if platform == 'win32':
            value = console(f"taskkill /F /T /PID {getpid()}")
        else:
            value = console(f"kill -9 {getpid()}")
        if value == None: value = 0
        if __ALWAYS_MONITOR_PERF_DATA__ or '-p' in __PASS_LIST__:
            __SHOW_PERF_DATA__(time_diff, ammount, __TERMINAL_WIDTH__)
        if __KEEP_PERF_DATA__:
            __SAVE_PERF_DATA__(time_diff, ammount, __TERMINAL_WIDTH__)
        return value
    return wrapper_function

# ---------- Initializer Functions ---------- #
@MEMOIZE
def __INITIALIZE__() -> None:
    """
    \n Inputs: None
    \n Outputs: None
    \n This is the first stage of the Versace compiler.
    \n This stage is used to get the config data and the Versace code.
    \n It also checks if the required modules are installed. and saves that information to a .pkg file.
    """
    if __SYSTEM__.path_exists(__SYSTEM__.get_user_dir() + path_sep + 'Versace' + path_sep + 'base' + path_sep + 'packages.pkg') is False:
        from pkg_resources import working_set
        console("")
        __REQUIRED_MODULES__ = {'psutil', 'rich', 'requests' , 'pyinstaller', 'sv-ttk'}
        __INSTALLED_MODULES__ = {pkg.key for pkg in working_set}
        __MISSING_MODULES__ = __REQUIRED_MODULES__ - __INSTALLED_MODULES__

        if __MISSING_MODULES__:
            __PYTHON_PATH__ = __ORG_PYTHON_PATH__
            check_call([__PYTHON_PATH__, '-m', 'pip', 'install', *__MISSING_MODULES__], stdout=DEVNULL)
            print(f"{__COLORS__['bold green']}Installed MISSING MODULES modules successfully{__COLORS__['reset']}")

        __REQUIRED_MODULES__ = {'cx_Freeze'}
        __INSTALLED_MODULES__ = {pkg.key for pkg in working_set}
        __MISSING_MODULES__ = __REQUIRED_MODULES__ - __INSTALLED_MODULES__

        if __MISSING_MODULES__:
            __PYTHON_PATH__ = __ORG_PYTHON_PATH__
            check_call([__PYTHON_PATH__, '-m', 'pip', 'install', '--pre', '--extra-index-url', 'https://marcelotduarte.github.io/packages/', 'cx_Freeze', 'cx_Logging'], stdout=DEVNULL)
            print(f"{__COLORS__['bold green']}Installed MISSING MODULES modules successfully{__COLORS__['reset']}")


    #__REQUIRED_MODULES__ = {'psutil', 'rich', 'requests' , 'pyinstaller', 'sv-ttk', 'cx_Freeze'}
    #__INSTALLED_MODULES__ = {pkg.key for pkg in working_set}
    #__INSTALLED_MODULES_C__ = __INSTALLED_MODULES__.copy()
    #__MODULES_INSTALLED__ = __INSTALLED_MODULES__ - __REQUIRED_MODULES__
    #__ALL_MODULES_INSTALLED__ = False
    #for i in __MODULES_INSTALLED__:
    #    __INSTALLED_MODULES__.remove(i)


    if __SYSTEM__.path_exists(__SYSTEM__.get_user_dir() + path_sep + 'Versace' + path_sep + 'base' + path_sep + 'packages.pkg'):
        if stat(__SYSTEM__.get_user_dir() + path_sep + 'Versace' + path_sep + 'base' + path_sep + 'packages.pkg') == 0:
            remove(__SYSTEM__.get_user_dir() + path_sep + 'Versace' + path_sep + 'base' + path_sep + 'packages.pkg')


    #if __SYSTEM__.path_exists(__SYSTEM__.get_user_dir() + path_sep + 'Versace' + path_sep + 'base' + path_sep + 'packages.pkg'):
    #    # check if the file is empty
    #    with open(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}base{path_sep}packages.pkg", "r+", encoding="utf-8") as f:
    #        __INSTALED_MODULES_SAVED__ = literal_eval(f.readlines()[0].strip())
    #        for i in __INSTALED_MODULES_SAVED__:
    #            if i not in __INSTALLED_MODULES_C__:
    #                __ALL_MODULES_INSTALLED__ = True
    #        if __ALL_MODULES_INSTALLED__:
    #            __MISSING_MODULES__ = __REQUIRED_MODULES__ - __INSTALLED_MODULES__
    #            if __MISSING_MODULES__:
    #                __PYTHON_PATH__ = __ORG_PYTHON_PATH__
    #                check_call([__PYTHON_PATH__, '-m', 'pip', 'install', *__MISSING_MODULES__], stdout=DEVNULL)
    #                print(f"{__COLORS__['bold green']}Installed MISSING MODULES modules successfully{__COLORS__['reset']}")
    #                with open(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}base{path_sep}packages.pkg", "w+", encoding="utf-8") as f:
    #                    f.write(str(__INSTALLED_MODULES__))

    # create a folder at __SYSTEM__.get_user_dir() called Versace
    if __SYSTEM__.path_exists(__SYSTEM__.get_user_dir() + path_sep + 'Versace' + path_sep + 'base') is False:
        __SYSTEM__.make_dirs(__SYSTEM__.get_user_dir() + path_sep + 'Versace', exist_ok=True)
        __SYSTEM__.make_dirs(__SYSTEM__.get_user_dir() + path_sep + 'Versace' + path_sep + 'base', exist_ok=True)

    if __SYSTEM__.path_exists(__SYSTEM__.get_user_dir() + path_sep + 'Versace' + path_sep + 'base' + path_sep + 'packages.pkg') is False:
        with open(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}base{path_sep}packages.pkg", "w", encoding="utf-8") as f:
            f.write(str(__INSTALLED_MODULES__))
            f.close()
@MEMOIZE
def __READ_SYS_ARGS__() -> None:
    
    CONFIG_DATA_SHOULD = ( \
        'binary',
        'use_cache',
        'indentation',
        'no_includes',
        'python_path',
        'allow_update',
        'versace_path',
        'no_args_start',
        'keep_perf_data',
        'allow_tracking',
        'binary_file_ext',
        'no_version_check',
        'transpile_file_ext',
        'always_monitor_perf_data',
        'max_includes',
        'traceback_limit',
    )
    
    console("")
    
    if __SYSTEM__.path_exists(f"{__SYSTEM__.get_c_dir()}{path_sep}Versace.cfg"):
        with open(f"{__SYSTEM__.get_c_dir()}{path_sep}Versace.cfg", "r", encoding="utf-8") as f:
            __CONFIG_DATA__ = f.read()
            f.close()
        for i in CONFIG_DATA_SHOULD:
            if i not in __CONFIG_DATA__: 
                if '-cfg' in __PASS_LIST__:
                    with open(f"{__SYSTEM__.get_c_dir()}{path_sep}Versace.cfg", "w", encoding="utf-8") as f:
                        f.write(__CREATE_CONFIG_FILE__())
                        f.close()
                    print(f"{__COLORS__['red']}Run versace again with the to apply the changes.{__COLORS__['reset']}"); exit()
                raise VersaceCodeBaseError(f"Config file is missing key: {i} \n{__COLORS__['yellow']}Add the missing key to the config file or delete the config file and creeate a new one with the {__COLORS__['green']}'-cfg'{__COLORS__['yellow']} flag{__COLORS__['reset']}")
        __READ_CONFIG__(__CONFIG_DATA__, FILE_PATH=f"{__SYSTEM__.get_c_dir()}{path_sep}Versace.cfg")

    else:
        if __SYSTEM__.path_exists(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}base{path_sep}defualt-Versace.cfg") is False:
            with open(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}base{path_sep}defualt-Versace.cfg", "w", encoding="utf-8") as f:
                f.write(__CREATE_CONFIG_FILE__())
                f.close()
        with open(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}base{path_sep}defualt-Versace.cfg", "r", encoding="utf-8") as f:
            __CONFIG_DATA__ = f.read()
            f.close()
        for i in CONFIG_DATA_SHOULD:
            if i not in __CONFIG_DATA__: 
                if '-cfg' in __PASS_LIST__: remove(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}base{path_sep}defualt-Versace.cfg"); print(f"{__COLORS__['red']}Run versace again to apply changes{__COLORS__['reset']}"); exit()
                raise VersaceCodeBaseError(f"Config file is missing key: {i} \n{__COLORS__['yellow']}Run versace again with the -cfg flag to reinitialize the config file\nOr add the missing key to the defualt config{__COLORS__['reset']}")
        __READ_CONFIG__(__CONFIG_DATA__, FILE_PATH=f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}base{path_sep}defualt-Versace.cfg")
    if '-cfg' in __PASS_LIST__:
        if __SYSTEM__.path_exists(f"{__SYSTEM__.get_c_dir()}{path_sep}Versace.cfg"):
            print(f"{__COLORS__['red']}Are you sure you want to overwrite the existing config file?{__COLORS__['reset']}")
            if input(f"{__COLORS__['yellow']}Type 'yes' to overwrite the config file - {__COLORS__['reset']}") == 'yes':
                remove(f"{__SYSTEM__.get_c_dir()}{path_sep}Versace.cfg")
                print(f"{__COLORS__['red']}Overwrote existing config file at {__COLORS__['green']}{__SYSTEM__.get_c_dir()}{path_sep}Versace.cfg{__COLORS__['reset']}")
            else: print(f"{__COLORS__['red']}Aborting...{__COLORS__['reset']}"); exit()
        else: print(f"{__COLORS__['red']}Created new config file at {__COLORS__['green']}{__SYSTEM__.get_c_dir()}{path_sep}Versace.cfg{__COLORS__['reset']}")
        with open(f"{__SYSTEM__.get_c_dir()}{path_sep}Versace.cfg", "w", encoding="utf-8") as f:
            f.write(__CREATE_CONFIG_FILE__())
            f.close()
        
    return 0
@MEMOIZE
def __INITIALIZE_CHECKS__() -> None:
    """
    \n Inputs: None
    \n Outputs: None
    \n This is the second stage of initial checks.
    \n It will check the argv flags and cd to the correct directory.
    \n It will also check if the file exists.
    """
    # check which one of the argv elements is the file path
    global __FILE_PATH__
    for _I_ in __PASS_LIST__:
        if '\"' in _I_ or "'" in _I_:
            __PASS_LIST__[__PASS_LIST__.index(_I_)] = str(eval(_I_)).__str__()

        if _I_.endswith('.py') or _I_.endswith('.exe'):
            continue

        if '.' in _I_ or '/' in _I_ or '\\' in _I_ or ':' in _I_:
            __FILE_PATH__ = _I_
            break

    if __FILE_PATH__ == '':
        console('')
        #print(f"{__COLORS__['red']}No file path found{__COLORS__['reset']}")
        #print(f"{__COLORS__['red']}If you need help type {__COLORS__['green']}Versace -h{__COLORS__['red']}{__COLORS__['reset']}")
        #print(f"{__COLORS__['red']}Please enter the file path : {__COLORS__['reset']}", end='')
        if __SYSTEM__.path_exists(gettempdir() + path_sep + 'VersaceIntrepeterdModeTempFILE.tmp'):
            remove(gettempdir() + path_sep + 'VersaceIntrepeterdModeTempFILE.tmp')
        __FILE_PATH__ = gettempdir() + path_sep + 'VersaceIntrepeterdModeTempFILE.tmp'
        with open(__FILE_PATH__, 'w', encoding='utf-8') as __TEMP_FILE_:
            __TEMP_FILE_.write('')
        if len(__PASS_LIST__) > 1 and '-d' not in __PASS_LIST__ and '-i' not in __PASS_LIST__:
            raise UnhandledException('No file path provided')
        __INTREPETER__() if '-i' not in __PASS_LIST__ else __INTREPETER__(__PASS_LIST__[__PASS_LIST__.index('-i') + 1])

    if __SYSTEM__.path_exists(__SYSTEM__.get_user_dir() + path_sep + "Versace" + path_sep + "compiled") is False:
        __SYSTEM__.make_dirs(__SYSTEM__.get_user_dir() + path_sep + "Versace" + path_sep + "compiled")

    if '\\\\' in __FILE_PATH__:
        __FILE_PATH__ = __FILE_PATH__.replace('\\', path_sep)
    elif '/' in __FILE_PATH__:
        __FILE_PATH__ = __FILE_PATH__.replace('/', path_sep)
    elif '\\' in __FILE_PATH__:
        __FILE_PATH__ = __FILE_PATH__.replace('\\', path_sep)

    if __SYSTEM__.get_c_dir().lower() not in __FILE_PATH__.lower() and ':' not in __FILE_PATH__ and __FILE_PATH__[0] != path_sep:
        __FILE_PATH__ = __SYSTEM__.get_c_dir() + path_sep + __FILE_PATH__
        __PASS_LIST__[__PASS_LIST__.index(_I_)] = __FILE_PATH__

    __SYSTEM__.change_dir(__SYSTEM__.get_c_dir())

    __FILE_PATH__ = path.abspath(__FILE_PATH__)

    if __SYSTEM__.path_exists(__FILE_PATH__) is False:
        console("")
        print(f"{__COLORS__['bold red']}File path {__COLORS__['bold cyan']}{__FILE_PATH__}{__COLORS__['bold red']} does not exist{__COLORS__['reset']}")
        wait(2)
        exit()

    return
@ASYNC
def __INNIT_DATA_COLLECTOR__(__FILE_PATH__: str) -> None:
    """__DATA_COLLECTOR__ is a function that collects the data from the file and then passes it to the __DATA_PARSER__ function."""
    global __PASS_LIST__, __OPTIANAL_ARGS_IN_FILE__

    if __SYSTEM__.path_exists(gettempdir() + fr'{path_sep}VERSACETEMP') is False:
        __SYSTEM__.make_dirs(gettempdir() + fr'{path_sep}VERSACETEMP')
    __FILE_PATH_1__ = gettempdir() + fr'{path_sep}VERSACETEMP{path_sep}{path.basename(__FILE_PATH__)}'
    __FILE_PATH_2__ = gettempdir() + fr'{path_sep}VERSACETEMP{path_sep}{path.basename(__FILE_PATH__)}.tmp'
    if __USE_CACHE__ is False:
        # check if dir is empty
        if len(listdir(gettempdir() + fr'{path_sep}VERSACETEMP')) == 0: return
        for i in listdir(gettempdir() + fr'{path_sep}VERSACETEMP'):
            remove(gettempdir() + fr'{path_sep}VERSACETEMP{path_sep}{i}')
        return
    if '-ctemp' in __PASS_LIST__ and '-all' not in __PASS_LIST__:
        remove(__FILE_PATH_1__)
        remove(__FILE_PATH_2__)
        return
    elif '-ctemp' in __PASS_LIST__ and '-all' in __PASS_LIST__:
        # clear the whole temp directory
        for i in listdir(gettempdir() + fr'{path_sep}VERSACETEMP'):
            remove(gettempdir() + fr'{path_sep}VERSACETEMP{path_sep}{i}')
        console("")
        print(f"{__COLORS__['bold green']}Cleared the temp directory\n{__COLORS__['yellow']}{gettempdir()}{path_sep}VERSACETEMP{__COLORS__['reset']}")
        exit()
    else: return
@MEMOIZE
def __CHECK_ARGS__(__FILE_PATH__) -> None:
    """
    \n Inputs: __FILE_PATH__
    \n Outputs: None
    \n This is the third stage of initial checks.
    \n It will check the argv flags and if they are not valid, it will print the help message.
    \n It also creates a config file if '-cfg' in passed.
    """
    __ALLOWED_ARGS__ = ('-p', '-d', '-v', '-h', '-f', '--debug', '-ast', '-all', '-cfg', '-ctemp', '-clear', '-t', '-c', '-1', '-2', '-3', '-exec', '-py', '-l', '-i')
    for i in __PASS_LIST__:
        if '-' in i and '.' not in i:
            if i not in __ALLOWED_ARGS__:
                console("")
                print(f'{__COLORS__["red"]}Invalid argument provided{__COLORS__["reset"]}')
                print(f'{__COLORS__["green"]}Working arguments:{__COLORS__["reset"]}')
                print(f'{__COLORS__["green"]}-p            | Shows the performance statistics of the program{__COLORS__["reset"]}') # ✅
                print(f'{__COLORS__["green"]}-d            | Runs the debug mode{__COLORS__["reset"]}')                             # ✅
                print(f'{__COLORS__["green"]}-v            | Shows the version of the program{__COLORS__["reset"]}')                # ✅
                print(f'{__COLORS__["green"]}-l            | Shows the license information{__COLORS__["reset"]}')                   # ✅
                print(f'{__COLORS__["green"]}-h            | Shows the help menu{__COLORS__["reset"]}')                             # ✅
                print(f'{__COLORS__["green"]}-f            | Forces the program to freeze before exiting{__COLORS__["reset"]}')     # ✅
                print(f'{__COLORS__["green"]}-all          | Meant to be used in conjunction with -d or -ctemp, it shows more debug data, if used with "-ctemp" it will clear the entire temp folder{__COLORS__["reset"]}') # ✅
                print(f'{__COLORS__["green"]}-cfg          | Auto creates a Versace.cfg file in your current directory and opens it in your text editor{__COLORS__["reset"]}') # ✅
                print(f'{__COLORS__["green"]}-ast          | Shows the abstract syntax tree of the code{__COLORS__["reset"]}')      # ✅
                print(f'{__COLORS__["green"]}-ctemp        | Clears the data associated with inputed file (does not remove the file itself){__COLORS__["reset"]}') # ✅
                print(f'{__COLORS__["green"]}-clear        | Clears the terminal screen before execution{__COLORS__["reset"]}')     # ✅
                print(f'{__COLORS__["green"]}--debug       | Only used if you get a versace internal error{__COLORS__["reset"]}')   # ✅
                #print(f'{__COLORS__["green"]}-i "<code>"   | Executes code specified from the command line{__COLORS__["reset"]}')
                print(f'{__COLORS__["green"]}-t <filename> | Transpiles the Versace code to a python file{__COLORS__["reset"]}')    # ✅
                print(f'{__COLORS__["green"]}-c <filename> | Compiles the Versace code to a binary exe file{__COLORS__["reset"]}')
                print(f'{__COLORS__["green"]}  -1**        | Must be used in conjunction with -c, it compiles the file to a single unoptimized executable file{__COLORS__["reset"]}')
                print(f'{__COLORS__["green"]}  -2**        | Must be used in conjunction with -c, it compiles the file to a faster single directory with a executable file{__COLORS__["reset"]}')
                print(f'{__COLORS__["green"]}  -3**        | Must be used in conjunction with -c, it compiles the file to a the fastest most-optimized executable file, but nested with a lot of directories{__COLORS__["reset"]}')
                print(f'{__COLORS__["green"]}  -exec**     | Must be used in conjunction with a file to be run. Runs the file without using python (quickest){__COLORS__["reset"]}') # ✅
                print(f'{__COLORS__["green"]}  -py**       | Must be used in conjunction with a file to be run. Runs the file with python {__COLORS__["bold magenta"]}(Default){__COLORS__["reset"]}') # ✅
                print(f'{__COLORS__["yellow"]}If no arguments are provided, the program will run the file you put in the first argument using python (not that slow but still slow){__COLORS__["reset"]}')
                print(f'{__COLORS__["red"]}*<filename> is an OPTIONAL argument{__COLORS__["reset"]}')                               # ✅
                print(f'{__COLORS__["red"]}**Means that it must be used in conjunction with some argument{__COLORS__["reset"]}')    # ✅
                print(f'{__COLORS__["bold red"]}You used {i}{__COLORS__["reset"]}')
                exit()  # Exit the program
    if '-h' in __PASS_LIST__: __MISSALANEOUS__().__HELP_MENU__(); exit()
    if '-v' in __PASS_LIST__: __MISSALANEOUS__().__VERSION__(); exit()
    if '-l' in __PASS_LIST__: __MISSALANEOUS__().__LICENSE__(); exit()
    if '-all' in __PASS_LIST__ and '-d' not in __PASS_LIST__:
        if '-ctemp' in __PASS_LIST__: pass
        else:
            console("")
            print(f'{__COLORS__["bold red"]}-all must be used in conjunction with -d{__COLORS__["reset"]}')
            exit()
    if '-1' in __PASS_LIST__ or '-2' in __PASS_LIST__ or '-3' in __PASS_LIST__:
        if '-c' not in __PASS_LIST__:
            console("")
            print(f'{__COLORS__["bold red"]}-1, -2, and -3 must be used in conjunction with -c{__COLORS__["reset"]}')
            exit()
    if '-clear' in __PASS_LIST__:
        console(__CLEAR_SCREEN__)
    return __FILE_PATH__
@MEMOIZE
def __OPEN_FILE__(__FILE_PATH__, mode = None) -> list:
    """
    \n Input: The file path to the Versace file
    \n Output: None
    \n Opens the Versace file and passes it to the __SPLIT_ALL_LINES__ function.
    """
    global __LINES__, __LINES_FROM_FILE_RAW__, __COLORS__, __USE_CACHE__, __OPTIANAL_ARGS_IN_FILE__
    __OPTIONAL_ARGUMENT__: str = ""
    # check if file is empty
    if stat(__FILE_PATH__) == 0:
        return "Empty"
    with open(__FILE_PATH__, "r", encoding="utf-8") as f:
        __LINES__ = f.readlines()
        f.close()
    __LINES_FROM_FILE_RAW__ = deepcopy(__LINES__)
    for _INDEX_, _LINE_ in enumerate(__LINES__):
        if '//' in _LINE_:
            _LINE_ = _LINE_.split('//')[0]
        if _LINE_.strip().startswith('[') and _LINE_.strip().endswith(']'):
            __OPTIONAL_ARGUMENT__ = _LINE_.strip()[1:-1]
            console("")
            if mode != 'include':
                if __OPTIONAL_ARGUMENT__ in __GLOBAL_VARIABLES__.__OPTIANAL_ARGS_ALLOWED__:
                    __OPTIANAL_ARGS_IN_FILE__.append(__OPTIONAL_ARGUMENT__)
                else:
                    # exmaple line: [arg1, arg2, arg3]
                    # output 1 : BAD OPTION CALL in line 1: [arg1, arg2, arg3]
                    # output 2 : ╰────────────────────────> ^                ^
                    # output 3 : You can only use "[" and "]" to make OPTIONAL arguments, if you do not understand this, please read the documentation. here https://dhruvan.gitbook.io/vs
                    print(f'{__COLORS__["bold red"]}Bad optional argument in line {_INDEX_ + 1}:{__COLORS__["bold yellow"]} {_LINE_.strip()}{__COLORS__["reset"]}')
                    print(f'{__COLORS__["bold red"]}╰{"─" * (len(f"Bad optional argument in line {_INDEX_ + 1}:") - 2)}> {"^" * (len(_LINE_.strip()) - 1)}^{__COLORS__["reset"]}')
                    if ',' in _LINE_.strip():
                        print(f'{__COLORS__["bold red"]}If you meant to make a list, you can use the "list" opperator, example: {__COLORS__["bold yellow"]}list(1, 2, 3){__COLORS__["reset"]}')
                        exit()
                    print(f'{__COLORS__["bold red"]}You can only use "[" and "]" to make OPTIONAL arguments, if you do not understand this, please read the documentation. here {__COLORS__["bold blue"]}https://dhruvan.gitbook.io/vs/Versace/optional-arguments{__COLORS__["reset"]}')
                    exit()
            else:
                print(f'{__COLORS__["bold red"]}No optional arguments allowed, used in line {_INDEX_ + 1}:{__COLORS__["bold yellow"]} {_LINE_.strip()}{__COLORS__["reset"]}')
                print(f'{__COLORS__["bold red"]}╰{"─" * (len(f"Miss-used optional argument in line {_INDEX_ + 1}:") - 2)}> {"^" * (len(_LINE_.strip()) - 1)}^{__COLORS__["reset"]}')
                if ',' in _LINE_.strip():
                    print(f'{__COLORS__["bold red"]}If you meant to make a list, you can use the "list" opperator, example: {__COLORS__["bold yellow"]}list(1, 2, 3){__COLORS__["reset"]}')
                    exit()
                print(f'{__COLORS__["bold red"]}You can not use optional arguments in a included file, if you do not understand this, please read the documentation. here {__COLORS__["bold blue"]}https://dhruvan.gitbook.io/vs/Versace/optional-arguments{__COLORS__["reset"]}')
                exit()
            __LINES__[_INDEX_] = ''
    if '-*- cache -*-' in __OPTIANAL_ARGS_IN_FILE__:
        __USE_CACHE__ = True
    if '-*- all errors -*-' not in __OPTIANAL_ARGS_IN_FILE__:
        __OPTIANAL_ARGS_IN_FILE__.append('-*- all errors -*-')
    if not __COLOR_SUPPORT__:
        __COLORS__ = _MAP_({'red' : '', 'grey' : '', 'underline' : '', 'green' : '', 'yellow' : '', 'blue' : '', 'magenta' : '', 'cyan' : '', 'white' : '', 'bold red' : '', 'bold green' : '', 'bold yellow' : '', 'bold blue' : '', 'bold magenta' : '', 'bold cyan' : '', 'bold white' : '', 'bright_red' : '', 'bright_green' : '', 'bright_yellow' : '', 'bright_blue' : '', 'bright_magenta' : '', 'bright_cyan' : '', 'bright_white' : '', 'underline' : '', 'italic' : '', 'blink' : '', 'reverse' : '', 'reset' : ''})
    return __LINES_FROM_FILE_RAW__

# ---------------- READ/GET/SET Data Functions ---------------- #
@MEMOIZE
def __LINE_0__() -> str:
    """Returns the starting line that should go in every compiled file"""
    DATA  = f"""# -*- coding: utf-8 -*-
# THIS FILE WAS GENERATED BY VERSACE {__VERSION__}
# Versace can be found here: \"https://github.com/Ze7111/Verscae-Programing-language/\"
# Versace Documentation can be found here: \"https://dhruvan.gitbook.io/vs/\"
\"\"\"
╭───────────────────────────────────────────────────────────────────────────────╮
│    DO NOT EDIT THIS CODE THIS SECTION OF CODE OR THE LINES ABOVE THIS,        │
│                       AUTO GENERATED BY VERSACE.                              │
╰───────────────────────────────────────────────────────────────────────────────╯
\"\"\"
from rich import console as r_console; print = r_console.Console().print
from sys import exit, getsizeof
from copy import deepcopy as copy
import sys, os, enum
from threading import Thread, main_thread
from time import sleep as wait
from dataclasses import dataclass
from subprocess import Popen as ppopen
from typing import Final
from psutil import virtual_memory
__ALLOCATED_MEMORY_ARRAY__: list[int] = []
__FREE_MEMORY__: int = (virtual_memory().free / (1024 * 1024)) - 1024
__TASK_REGISTRY__: dict[str, object] = {{}}
__TASK_ARGS_REGISTRY__: dict[str, tuple] = {{}}
__TASK_KWARGS_REGISTRY__: dict[str, dict] = {{}}
__AUTO_RELEASE_POOL__: bool = False
_FROZENSET_ = frozenset
NULL = None
__OVERLOAD_FUNCTION_REG__: dict = {{}}
class VersaceCodeBaseError(Exception):
{__INDENTATION__*1}def __init__(self, message):
{__INDENTATION__*2}os.system("")
{__INDENTATION__*2}print(\"VersaceError: \" + message)
{__INDENTATION__*2}exit()
class __DISPATCH__(object):
{__INDENTATION__*1}def __init__(self, NAME):
{__INDENTATION__*2}self.NAME = NAME
{__INDENTATION__*2}self.__TYPE_MAP__ = {{}}
{__INDENTATION__*1}def __call__(self, *ARGUMENTS):
{__INDENTATION__*2}__TYPES__ = tuple(argument.__class__ for argument in ARGUMENTS) # a generator expression!
{__INDENTATION__*2}FUNCTION = self.__TYPE_MAP__.get(__TYPES__)
{__INDENTATION__*2}if FUNCTION is None:
{__INDENTATION__*3}VersaceCodeBaseError(f\"No registered function for types \\\"{{__TYPES__}}\\\"\")
{__INDENTATION__*2}return FUNCTION(*ARGUMENTS)
{__INDENTATION__*1}def __register__(self, __TYPES__, FUNCTION):
{__INDENTATION__*2}if __TYPES__ in self.__TYPE_MAP__:
{__INDENTATION__*3}VersaceCodeBaseError(f\"Duplicate registration for function \\\"{{FUNCTION.__name__}}\\\"\")
{__INDENTATION__*2}self.__TYPE_MAP__[__TYPES__] = FUNCTION
def overload(*__TYPES__):
{__INDENTATION__*1}def __register__(FUNCTION):
{__INDENTATION__*2}NAME = FUNCTION.__name__
{__INDENTATION__*2}__D_INST__ = __OVERLOAD_FUNCTION_REG__.get(NAME)
{__INDENTATION__*2}if __D_INST__ is None:
{__INDENTATION__*3}__D_INST__ = __OVERLOAD_FUNCTION_REG__[NAME] = __DISPATCH__(NAME)
{__INDENTATION__*2}__D_INST__.__register__(__TYPES__, FUNCTION)
{__INDENTATION__*2}return __D_INST__
{__INDENTATION__*1}return __register__
def _async(func):
{__INDENTATION__*1}\"\"\" This is a decorator for async functions \"\"\"
{__INDENTATION__*1}def __ASYNC__FUNCTION__(*args, **kwargs):
{__INDENTATION__*2}\"\"\" This is the wrapper function that will be returned \"\"\"
{__INDENTATION__*2}thread = Thread(target=func, args=args, kwargs=kwargs)
{__INDENTATION__*2}thread.start()
{__INDENTATION__*2}return thread
{__INDENTATION__*1}return __ASYNC__FUNCTION__
with open(__file__, \'r\', encoding="utf-8") as f:
{__INDENTATION__*1}__THIS_FILE_DATA__ = f.readlines()
if \'Versace\' not in __THIS_FILE_DATA__[2]:
{__INDENTATION__*1}raise RuntimeError('This file is corrupted, please do not modify the section of code that specifies that it is auto generated by Versace')
if \'https\' not in __THIS_FILE_DATA__[2]:
{__INDENTATION__*1}raise RuntimeError('This file is corrupted, please do not modify the section of code that specifies that it is auto generated by Versace')
if \'Ze7111\' not in __THIS_FILE_DATA__[2]:
{__INDENTATION__*1}raise RuntimeError('This file is corrupted, please do not modify the section of code that specifies that it is auto generated by Versace')
if \'GENERATED\' not in __THIS_FILE_DATA__[1]:
{__INDENTATION__*1}raise RuntimeError('This file is corrupted, please do not modify the section of code that specifies that it is auto generated by Versace')
if \'coding\' not in __THIS_FILE_DATA__[0]:
{__INDENTATION__*1}raise UnicodeError(\'This file is corrupted, please do not modify the section of code that specifies that it is auto generated by Versace\')
def pack(*args, **kwargs) -> tuple:
{__INDENTATION__*1}\"\"\" Packs any given data into a tuple \"\"\"
{__INDENTATION__*1}if not args and not kwargs:
{__INDENTATION__*2}return (None)
{__INDENTATION__*1}if not args:
{__INDENTATION__*2}return kwargs
{__INDENTATION__*1}if not kwargs:
{__INDENTATION__*2}return args
{__INDENTATION__*1}return args, kwargs
def unpack(args, **kwargs) -> ...:
{__INDENTATION__*1}\"\"\" Unpacks any packed data, so they can be assigned to variables \"\"\"
{__INDENTATION__*1}if not args and not kwargs:
{__INDENTATION__*2}return (None)
{__INDENTATION__*1}if not args:
{__INDENTATION__*2}return kwargs
{__INDENTATION__*1}if not kwargs:
{__INDENTATION__*2}return args
{__INDENTATION__*1}return args, kwargs
def frozenset(*args, **kwargs) -> _FROZENSET_:
{__INDENTATION__*1}\"\"\" Converts any given data to a frozenset \"\"\"
{__INDENTATION__*1}return __builtins__.frozenset(args)
def exec(*args, **kwargs) -> None:
{__INDENTATION__*1}\"\"\" Executes any given code \"\"\"
{__INDENTATION__*1}if not args and not kwargs:
{__INDENTATION__*2}return (None)
{__INDENTATION__*1}for i in args:
{__INDENTATION__*2}exec(i, globals())
def alloc(size=None, output=None, path_sep=None) -> int:
{__INDENTATION__*1}__ALLOCATE__ = size
{__INDENTATION__*1}if __ALLOCATE__ is None: raise ValueError(\'No ammout of memory provided to allocate\')
{__INDENTATION__*1}if path_sep is None: path_sep = \',\'
{__INDENTATION__*1}global __ALLOCATED_MEMORY_ARRAY__, __FREE_MEMORY__
{__INDENTATION__*1}if __ALLOCATE__ > __FREE_MEMORY__: raise MemoryError(f\'Not enough memory to allocate {{__ALLOCATE__:,}} MB, only {{int(__FREE_MEMORY__):,}} MB available\')
{__INDENTATION__*1}if type(__ALLOCATE__) is not int: raise TypeError(\'Ammout of memory to allocate must be an integer\')
{__INDENTATION__*1}if type(__ALLOCATED_MEMORY_ARRAY__) is not list: __ALLOCATED_MEMORY_ARRAY__ = []
{__INDENTATION__*1}__ALLOCATE__ = __ALLOCATE__ * 7710 * 17
{__INDENTATION__*1}__ALLOCATED_MEMORY_ARRAY__  = [0] * __ALLOCATE__
{__INDENTATION__*1}if output is None: return getsizeof(__ALLOCATED_MEMORY_ARRAY__)
{__INDENTATION__*1}elif output == str:
{__INDENTATION__*2}__ALLOCATE__ = getsizeof(__ALLOCATED_MEMORY_ARRAY__)
{__INDENTATION__*2}if __ALLOCATE__ > 1024 * 1024 * 1024 * 1024:
{__INDENTATION__*3}__ALLOCATE__ = __ALLOCATE__ / (1024 * 1024 * 1024 * 1024)
{__INDENTATION__*3}__ALLOCATE__ = round(__ALLOCATE__, 2)
{__INDENTATION__*3}return f\'{{__ALLOCATE__:{{path_sep}}}} TB\'
{__INDENTATION__*2}elif __ALLOCATE__ > 1024 * 1024 * 1024:
{__INDENTATION__*3}__ALLOCATE__ = __ALLOCATE__ / (1024 * 1024 * 1024)
{__INDENTATION__*3}__ALLOCATE__ = round(__ALLOCATE__, 2)
{__INDENTATION__*3}return f\'{{__ALLOCATE__:{{path_sep}}}} GB\'
{__INDENTATION__*2}elif __ALLOCATE__ > 1024 * 1024:
{__INDENTATION__*3}__ALLOCATE__ = __ALLOCATE__ / (1024 * 1024)
{__INDENTATION__*3}__ALLOCATE__ = round(__ALLOCATE__, 2)
{__INDENTATION__*3}return f\'{{__ALLOCATE__:{{path_sep}}}} MB\'
{__INDENTATION__*2}elif __ALLOCATE__ > 1024:
{__INDENTATION__*3}__ALLOCATE__ = __ALLOCATE__ / 1024
{__INDENTATION__*3}__ALLOCATE__ = round(__ALLOCATE__, 2)
{__INDENTATION__*3}return f\'{{__ALLOCATE__:{{path_sep}}}} KB\'
{__INDENTATION__*2}else:
{__INDENTATION__*3}__ALLOCATE__ = round(__ALLOCATE__, 2)
{__INDENTATION__*3}return f\'{{__ALLOCATE__:{{path_sep}}}} Bytes\'
{__INDENTATION__*1}elif output == list:
{__INDENTATION__*2}# raise a exception informing the use THAT THEY ARE NOT SUPPOSED TO USE THIS FUNCTION
{__INDENTATION__*2}raise NotImplementedError(\'Using this WILL cause memory leaks, DO NOT USE\')
{__INDENTATION__*1}elif output == int:
{__INDENTATION__*2}return getsizeof(__ALLOCATED_MEMORY_ARRAY__)
{__INDENTATION__*1}else:
{__INDENTATION__*2}raise TypeError(\'Invalid output type\')
def free(size=None, output=None, path_sep=None) -> int:
{__INDENTATION__*1}__freeATE__ = size
{__INDENTATION__*1}global __ALLOCATED_MEMORY_ARRAY__, __FREE_MEMORY__
{__INDENTATION__*1}if path_sep is None: path_sep = \',\'
{__INDENTATION__*1}__freeATE__ = (__freeATE__ * 7710 * 17) if __freeATE__ is not None else None
{__INDENTATION__*1}if __freeATE__ is None: __freeATE__ = len(__ALLOCATED_MEMORY_ARRAY__)
{__INDENTATION__*1}if __freeATE__ / 7710 / 17 > __FREE_MEMORY__: raise MemoryError(f\'Not enough memory to freeate {{__freeATE__:,}} MB, only {{int(__FREE_MEMORY__):,}} MB available\')
{__INDENTATION__*1}if type(__ALLOCATED_MEMORY_ARRAY__) is not list: raise ValueError(\'Memory is not allocated\')
{__INDENTATION__*1}if __freeATE__ > len(__ALLOCATED_MEMORY_ARRAY__): raise MemoryError(f\'Not enough memory allocated to freeate, only {{len(__ALLOCATED_MEMORY_ARRAY__):,}} MB allocated\')
{__INDENTATION__*1}__ALLOCATED_MEMORY_ARRAY__ = __ALLOCATED_MEMORY_ARRAY__[:__freeATE__]
{__INDENTATION__*1}ammout_of_memory_allocated = getsizeof(__ALLOCATED_MEMORY_ARRAY__)
{__INDENTATION__*1}if ammout_of_memory_allocated == 56: ammout_of_memory_allocated = 0
{__INDENTATION__*1}if output is None:
{__INDENTATION__*2}return ammout_of_memory_allocated
{__INDENTATION__*1}elif output == str:
{__INDENTATION__*2}__freeATE__ = ammout_of_memory_allocated
{__INDENTATION__*2}if __freeATE__ > 1024 * 1024 * 1024 * 1024:
{__INDENTATION__*3}__freeATE__ = __freeATE__ / (1024 * 1024 * 1024 * 1024)
{__INDENTATION__*3}__freeATE__ = round(__freeATE__, 2)
{__INDENTATION__*3}return f\'{{__freeATE__:{{path_sep}}}} TB\'
{__INDENTATION__*2}elif __freeATE__ > 1024 * 1024 * 1024:
{__INDENTATION__*3}__freeATE__ = __freeATE__ / (1024 * 1024 * 1024)
{__INDENTATION__*3}__freeATE__ = round(__freeATE__, 2)
{__INDENTATION__*3}return f\'{{__freeATE__:{{path_sep}}}} GB\'
{__INDENTATION__*2}elif __freeATE__ > 1024 * 1024:
{__INDENTATION__*3}__freeATE__ = __freeATE__ = __freeATE__ / (1024 * 1024)
{__INDENTATION__*3}__freeATE__ = round(__freeATE__, 2)
{__INDENTATION__*3}return f\'{{__freeATE__:{{path_sep}}}} MB\'
{__INDENTATION__*2}elif __freeATE__ > 1024:
{__INDENTATION__*3}__freeATE__ = __freeATE__ / 1024
{__INDENTATION__*3}__freeATE__ = round(__freeATE__, 2)
{__INDENTATION__*3}return f\'{{__freeATE__:{{path_sep}}}} KB\'
{__INDENTATION__*2}else:
{__INDENTATION__*3}__freeATE__ = round(__freeATE__, 2)
{__INDENTATION__*3}return f\'{{__freeATE__:{{path_sep}}}} Bytes\'
{__INDENTATION__*1}elif output == list:
{__INDENTATION__*2}# raise a exception informing the use THAT THEY ARE NOT SUPPOSED TO USE THIS FUNCTION
{__INDENTATION__*2}raise NotImplementedError(\'Using this WILL cause memory leaks, DO NOT USE\')
{__INDENTATION__*1}elif output == int:
{__INDENTATION__*2}return ammout_of_memory_allocated
{__INDENTATION__*1}else:
{__INDENTATION__*2}raise TypeError(\'Invalid output type\')
def latch(*args, **kwrgs):
{__INDENTATION__*1}if len(args) == 0 and len(kwrgs) == 0:
{__INDENTATION__*2}raise RuntimeError(\'No arguments passed to latch\')
{__INDENTATION__*1}for arg in args:
{__INDENTATION__*2}if isinstance(arg, bool) != True:
{__INDENTATION__*3}raise RuntimeError(f\'Invalid argument type passed to latch, expected bool, got {{type(arg)}}\')
{__INDENTATION__*1}for kwarg in kwrgs:
{__INDENTATION__*2}if isinstance(kwrgs.get(kwarg), bool) != True:
{__INDENTATION__*3}raise RuntimeError(f\'Invalid argument type passed to latch, expected bool, got {{type(kwrgs.get(kwarg))}}\')
{__INDENTATION__*1}if len(args) > 0:
{__INDENTATION__*2}args = list(args)
{__INDENTATION__*2}for index in range(len(args)):
{__INDENTATION__*3}args[index] = not args[index]
{__INDENTATION__*2}args = tuple(args)
{__INDENTATION__*1}if len(kwrgs) > 0:
{__INDENTATION__*2}kwrgs = dict(kwrgs)
{__INDENTATION__*2}for kwarg in kwrgs:
{__INDENTATION__*3}kwrgs[kwarg] = not kwrgs.get(kwarg)
{__INDENTATION__*2}kwrgs = dict(kwrgs)
{__INDENTATION__*1}if len(args) > 0 and len(kwrgs) > 0:
{__INDENTATION__*2}temp_arg_list = []
{__INDENTATION__*2}temp_kwarg_list = []
{__INDENTATION__*2}for arg in args:
{__INDENTATION__*3}temp_arg_list.append(arg)
{__INDENTATION__*2}for kwarg in kwrgs:
{__INDENTATION__*3}temp_kwarg_list.append(kwrgs.get(kwarg))
{__INDENTATION__*2}args = tuple(temp_arg_list)
{__INDENTATION__*2}kwrgs = tuple(temp_kwarg_list)
{__INDENTATION__*2}return *args, *kwrgs
{__INDENTATION__*1}elif len(args) == 1:
{__INDENTATION__*2}return args[0]
{__INDENTATION__*1}elif len(kwrgs) == 1:
{__INDENTATION__*2}return kwrgs.get(list(kwrgs)[0])
{__INDENTATION__*1}elif len(args) > 0:
{__INDENTATION__*2}return args
{__INDENTATION__*1}elif len(kwrgs) > 0:
{__INDENTATION__*2}templist = []
{__INDENTATION__*2}for value in kwrgs:
{__INDENTATION__*3}templist.append(kwrgs.get(value))
{__INDENTATION__*2}templist = tuple(templist)
{__INDENTATION__*2}return templist
{__INDENTATION__*1}
{__INDENTATION__*2}
class VariableError(Exception):
{__INDENTATION__*1}def __init__(self, *args, **kwargs):
{__INDENTATION__*2}if args:
{__INDENTATION__*3}print(f\"VariableError: {{args[0]}}\")
{__INDENTATION__*2}elif kwargs:
{__INDENTATION__*3}print(f\"VariableError: {{kwargs[0]}}\")
{__INDENTATION__*2}exit()
class SyntaxError(Exception):
{__INDENTATION__*1}def __init__(self, *args, **kwargs):
{__INDENTATION__*2}if args:
{__INDENTATION__*3}print(f\"SyntaxError: {{args[0]}}\")
{__INDENTATION__*2}elif kwargs:
{__INDENTATION__*3}print(f\"SyntaxError: {{kwargs[0]}}\")
{__INDENTATION__*2}exit()
class CloseError(Exception):
{__INDENTATION__*1}def __init__(self, *args, **kwargs):
{__INDENTATION__*2}if args:
{__INDENTATION__*3}print(f\"CloseError: {{args[0]}}\")
{__INDENTATION__*2}elif kwargs:
{__INDENTATION__*3}print(f\"CloseError: {{kwargs[0]}}\")
{__INDENTATION__*2}exit()
class TypeError(Exception):
{__INDENTATION__*1}def __init__(self, *args, **kwargs):
{__INDENTATION__*2}if args:
{__INDENTATION__*3}print(f\"TypeError: {{args[0]}}\")
{__INDENTATION__*2}elif kwargs:
{__INDENTATION__*3}print(f\"TypeError: {{kwargs[0]}}\")
{__INDENTATION__*2}exit()
class DataError(Exception):
{__INDENTATION__*1}def __init__(self, *args, **kwargs):
{__INDENTATION__*2}if args:
{__INDENTATION__*3}print(f\"DataError: {{args[0]}}\")
{__INDENTATION__*2}elif kwargs:
{__INDENTATION__*3}print(f\"DataError: {{kwargs[0]}}\")
{__INDENTATION__*2}exit()
class FileNotFoundError(Exception):
{__INDENTATION__*1}def __init__(self, *args, **kwargs):
{__INDENTATION__*2}if args:
{__INDENTATION__*3}print(f\"FileNotFoundError: {{args[0]}}\")
{__INDENTATION__*2}elif kwargs:
{__INDENTATION__*3}print(f\"FileNotFoundError: {{kwargs[0]}}\")
{__INDENTATION__*2}exit()
class RefrenceError(Exception):
{__INDENTATION__*1}def __init__(self, *args, **kwargs):
{__INDENTATION__*2}if args:
{__INDENTATION__*3}print(f\"RefrenceError: {{args[0]}}\")
{__INDENTATION__*2}elif kwargs:
{__INDENTATION__*3}print(f\"RefrenceError: {{kwargs[0]}}\")
{__INDENTATION__*2}exit()
class NoMainError(Exception):
{__INDENTATION__*1}def __init__(self, *args, **kwargs):
{__INDENTATION__*2}if args:
{__INDENTATION__*3}print(f\"NoMainError: {{args[0]}}\")
{__INDENTATION__*2}elif kwargs:
{__INDENTATION__*3}print(f\"NoMainError: {{kwargs[0]}}\")
{__INDENTATION__*2}exit()
class Error(Exception):
{__INDENTATION__*1}def __init__(self, *args, **kwargs):
{__INDENTATION__*2}if args:
{__INDENTATION__*3}print(f\"Error: {{args[0]}}\")
{__INDENTATION__*2}elif kwargs:
{__INDENTATION__*3}print(f\"Error: {{kwargs[0]}}\")
{__INDENTATION__*2}exit()
class AsyncError(Exception):
{__INDENTATION__*1}def __init__(self, *args, **kwargs):
{__INDENTATION__*2}if args:
{__INDENTATION__*3}print(f\"AsyncError: {{args[0]}}\")
{__INDENTATION__*2}elif kwargs:
{__INDENTATION__*3}print(f\"AsyncError: {{kwargs[0]}}\")
{__INDENTATION__*2}exit()
class RuntimeError(Exception):
{__INDENTATION__*1}def __init__(self, *args, **kwargs):
{__INDENTATION__*2}if args:
{__INDENTATION__*3}print(f\"RuntimeError: {{args[0]}}\")
{__INDENTATION__*2}elif kwargs:
{__INDENTATION__*3}print(f\"RuntimeError: {{kwargs[0]}}\")
{__INDENTATION__*2}exit()
class TaskGroup:
{__INDENTATION__*1}def autorelease_pool(value: bool):
{__INDENTATION__*2}global __TASK_REGISTRY__, __TASK_ARGS_REGISTRY__, __TASK_KWARGS_REGISTRY__, __AUTO_RELEASE_POOL__
{__INDENTATION__*2}if len(__TASK_REGISTRY__) == 0:
{__INDENTATION__*3}__AUTO_RELEASE_POOL__ = value
{__INDENTATION__*2}else:
{__INDENTATION__*3}if value != __AUTO_RELEASE_POOL__:
{__INDENTATION__*4}raise RuntimeError(\'Cannot modify coroutine pool while tasks are set, clear tasks first with \"coroutine clear();\"\')
{__INDENTATION__*1}def add(task: object, *args, **kwargs):
{__INDENTATION__*2}global __TASK_REGISTRY__, __TASK_ARGS_REGISTRY__, __TASK_KWARGS_REGISTRY__
{__INDENTATION__*2}if not callable(task):
{__INDENTATION__*3}raise TypeError(\'Invalid task, expected a callable object (function or method)\')
{__INDENTATION__*2}if task.__name__ != \"__ASYNC__FUNCTION__\":
{__INDENTATION__*3}raise RuntimeError(\'Invalid task, expected a async function\')
{__INDENTATION__*2}__TASK_REGISTRY__[task] = task.__name__
{__INDENTATION__*2}__TASK_ARGS_REGISTRY__[task] = args
{__INDENTATION__*2}__TASK_KWARGS_REGISTRY__[task] = kwargs
{__INDENTATION__*2}
{__INDENTATION__*1}def execute(*args):
{__INDENTATION__*2}global __TASK_REGISTRY__, __TASK_ARGS_REGISTRY__, __TASK_KWARGS_REGISTRY__, __AUTO_RELEASE_POOL__
{__INDENTATION__*2}if len(__TASK_REGISTRY__) == 0:
{__INDENTATION__*3}raise RuntimeError(\'No tasks to execute, you can add tasks with \"coroutine async_function() | ...;\".\\nExample: \"coroutine some_func(1, 2) | some_other_func(1. 23);\"\')
{__INDENTATION__*2}if not args:
{__INDENTATION__*3}for task in __TASK_REGISTRY__:
{__INDENTATION__*4}task(*__TASK_ARGS_REGISTRY__[task], **__TASK_KWARGS_REGISTRY__[task])
{__INDENTATION__*2}else:
{__INDENTATION__*3}for task in args:
{__INDENTATION__*4}task(*__TASK_ARGS_REGISTRY__[task], **__TASK_KWARGS_REGISTRY__[task])
{__INDENTATION__*2}if __AUTO_RELEASE_POOL__  and len(args) == len(__TASK_REGISTRY__):
{__INDENTATION__*3}__TASK_REGISTRY__.clear()
{__INDENTATION__*3}__TASK_ARGS_REGISTRY__.clear()
{__INDENTATION__*3}__TASK_KWARGS_REGISTRY__.clear()
{__INDENTATION__*3}__AUTO_RELEASE_POOL__ = False
{__INDENTATION__*2}elif __AUTO_RELEASE_POOL__  and len(args) > 0:
{__INDENTATION__*3}for task in args:
{__INDENTATION__*4}if task not in __TASK_REGISTRY__:
{__INDENTATION__*5}raise RefrenceError(f\"\'{{task}}\' not found in the tasks registry.\")
{__INDENTATION__*4}del __TASK_REGISTRY__[task]
{__INDENTATION__*4}del __TASK_ARGS_REGISTRY__[task]
{__INDENTATION__*4}del __TASK_KWARGS_REGISTRY__[task]
{__INDENTATION__*2}elif __AUTO_RELEASE_POOL__  and len(args) == 0:
{__INDENTATION__*3}__TASK_REGISTRY__.clear()
{__INDENTATION__*3}__TASK_ARGS_REGISTRY__.clear()
{__INDENTATION__*3}__TASK_KWARGS_REGISTRY__.clear()
{__INDENTATION__*3}__AUTO_RELEASE_POOL__ = False
{__INDENTATION__*3}
{__INDENTATION__*1}def clear():
{__INDENTATION__*2}global __TASK_REGISTRY__, __TASK_ARGS_REGISTRY__, __TASK_KWARGS_REGISTRY__
{__INDENTATION__*2}__TASK_REGISTRY__.clear()
{__INDENTATION__*2}__TASK_ARGS_REGISTRY__.clear()
{__INDENTATION__*2}__TASK_KWARGS_REGISTRY__.clear()
{__INDENTATION__*2}
{__INDENTATION__*1}def remove(*args):
{__INDENTATION__*2}global __TASK_REGISTRY__, __TASK_ARGS_REGISTRY__, __TASK_KWARGS_REGISTRY__
{__INDENTATION__*2}if not args:
{__INDENTATION__*3}raise SyntaxError(\'No arguments provided for \"coroutine delete();\", expected at least 1\\nIf you want to remove all tasks, use \"coroutine clear();\"\')
{__INDENTATION__*2}for task in args:
{__INDENTATION__*3}if task not in __TASK_REGISTRY__:
{__INDENTATION__*4}raise RefrenceError(f\"\'{{task}}\' not found in the tasks registry.\")
{__INDENTATION__*3}del __TASK_REGISTRY__[task]
{__INDENTATION__*3}del __TASK_ARGS_REGISTRY__[task]
{__INDENTATION__*3}del __TASK_KWARGS_REGISTRY__[task]
\"\"\"
╭──────────────────────────────────────────────────────────────────────────────────╮
│ YOU CAN MODIFY THE CODE BELOW THIS LINE - DO NOT MODIFY THE CODE ABOVE THIS LINE │
╰──────────────────────────────────────────────────────────────────────────────────╯
\"\"\"
"""
    if "-*- no color -*-" in __OPTIANAL_ARGS_IN_FILE__:
        DATA = DATA.replace("from rich import console as r_console; print = r_console.Console().print", '')
    return DATA
@MEMOIZE
def __CREATE_CONFIG_FILE__() -> str:
    """
    Inputs: None
    Outputs: Default config data (string)
    Returns the default config data.
    The returned data is automatically formatted and indented.
    """
    import time
    __CURRENT_TIME__ = time.strftime('%d/%m/%Y %H:%M:%S', time.localtime())
    __CONFIG_DATA__ = f"""
    # {'-' * len(f"This is the config file for Versace it was auto generated at {__CURRENT_TIME__}")} #
    # This is the config file for Versace it was auto generated at {__CURRENT_TIME__} #
    # {'-' * len(f"This is the config file for Versace it was auto generated at {__CURRENT_TIME__}")} #

    ["BASIC-INFORMATION"]
    version = "{__VERSION__}"{' ' * (64 - len(f'version = "{__VERSION__}"'))}# the version of Versace
    indentation = "    "                                            # 4 spaces is the default
    allow_tracking = True                                           # This is to allow tracking of Versace
    allow_update = False                                            # This is to allow updates of Versace

    ["PATHS"]
    python_path = "{__ORG_PYTHON_PATH__}"{' ' * (62 - len(f'python_path = "{__ORG_PYTHON_PATH__}"'))}# This is the path to the python interpreter
    versace_path = "{__SYSTEM__.get_user_dir() + path_sep + 'Versace'}"{' ' * (61 - len(f"versace_path = '{__SYSTEM__.get_user_dir() + path_sep + 'Versace'}'"))}# This is the path to the Versace folder

    ["COMPILER"]
    no_includes = False                                             # This determines if the Versace compiler should include the modules specified by the user in thier Versace code
    no_args_start = False                                           # This determines if the Versace compiler should start the Versace code with the args passed to the Versace compiler
    no_version_check = False                                        # This determines if the Versace compiler should check for updates

    ["EXECUTABLE"]
    binary_file_ext = ".exe"                                        # The type of binary to compile to when compiling to binary
    binary = 1                                                      # Optimization level when compiling 0 = low_optimization(onfile), 1 = medium_optimization(ondir), 2 = max_optimization(nested_dirs)

    ["EXTRA"]
    keep_perf_data = False                                          # This determines if the Versace compiler should keep the performance data
    always_monitor_perf_data = False                                # This determines if the Versace compiler should always show the performance data
    transpile_file_ext = ".py"                                      # The type of file to transpile to when compiling to python
    use_cache = False                                               # This determines if the Versace compiler should use the cache
    max_includes = 100                                              # The maximum number of includes allowed in a Versace file
    traceback_limit = 3                                             # The maximum number of lines to show in a traceback
    """
    if '\\' in __CONFIG_DATA__:
        __CONFIG_DATA__ = __CONFIG_DATA__.replace('\\', '\\\\')
    return __CONFIG_DATA__
@MEMOIZE
def __PACK_CONFIG__() -> dict:
    """
    \nInputs: __CONFIG_DATA__
    \nOutputs: PACK
    \nThis is used to pack all the config data into a single dictionary.
    """
    PACK: dict[str : object] = {}
    PACK['INDENTATION'] = __INDENTATION__
    PACK['ALLOW_TRACKING'] = __ALLOW_TRACKING__
    PACK['ALLOW_UPDATE'] = __ALLOW_UPDATE__
    PACK['PYTHON_PATH'] = __PYTHON_PATH__
    PACK['VERSACE_PATH'] = __VERSACE_PATH__
    PACK['NO_INCLUDES'] = __NO_INCLUDES__
    PACK['NO_ARGS_START'] = __NO_ARGS_START__
    PACK['NO_VERSION_CHECK'] = __NO_VERSION_CHECK__
    PACK['BINARY_FILE_EXT'] = __BINARY_FILE_EXT__
    PACK['BINARY'] = __BINARY__
    PACK['KEEP_PERF_DATA'] = __KEEP_PERF_DATA__
    PACK['ALWAYS_MONITOR_PERF_DATA'] = __ALWAYS_MONITOR_PERF_DATA__
    PACK['TRANSPILE_FILE_EXT'] = __TRANSPILE_FILE_EXT__
    PACK['USE_CACHE'] = __USE_CACHE__
    PACK['MAX_INCLUDES'] = __MAX_INCLUDES__
    PACK['TRACEBACK_LIMIT'] = __TRACEBACK_LIMIT__
    return PACK
@MEMOIZE
def __READ_CONFIG__(__CONFIG_DATA__, FILE_PATH=None) -> None:
    """
    \nInputs: __CONFIG_DATA__
    \nOutputs: None
    \nThis is used to read the config data and save it to their respective variables.
    """
    global __INDENTATION__, __TRACEBACK_LIMIT__, __MAX_INCLUDES__, __ALLOW_TRACKING__, __ALLOW_UPDATE__, __PYTHON_PATH__, __VERSACE_PATH__, __NO_INCLUDES__, __NO_ARGS_START__, __NO_VERSION_CHECK__, __BINARY_FILE_EXT__, __BINARY__, __KEEP_PERF_DATA__, __ALWAYS_MONITOR_PERF_DATA__, __TRANSPILE_FILE_EXT__, __USE_CACHE__

    def _expectError(check, type) -> None:
        linetockek: str = check
        for index, i in enumerate(__CONFIG_DATA__.split('\n')):
            if i.startswith(linetockek):
                # check if the eval is valid
                try:
                    __BINARY__ = type(literal_eval(__CONFIG_DATA__.split (linetockek)[1].split('\n')[0].split('#')[0].strip()))
                except Exception as e:
                    __ERROR_REPORTING__(__CONFIG_DATA__.split('\n')[index], "BadConfigData", e, LINE_NO=index+1, FILE_NAME=FILE_PATH)
                    exit()
        exit()

    try:
        try: __BINARY__                   = int (literal_eval(__CONFIG_DATA__.split(         'binary = '         )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('binary = ', int)
        
        try: __USE_CACHE__                = bool(literal_eval(__CONFIG_DATA__.split(       'use_cache = '        )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('use_cache = ', bool)
        
        try: __INDENTATION__              = str (literal_eval(__CONFIG_DATA__.split(      'indentation = '       )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('indentation = ', str)
        
        try: __NO_INCLUDES__              = bool(literal_eval(__CONFIG_DATA__.split(      'no_includes = '       )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('no_includes = ', bool)
        
        try: __PYTHON_PATH__              = str (literal_eval(__CONFIG_DATA__.split(      'python_path = '       )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('python_path = ', str)
        
        try: __ALLOW_UPDATE__             = bool(literal_eval(__CONFIG_DATA__.split(      'allow_update = '      )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('allow_update = ', bool)
        
        try: __VERSACE_PATH__             = str (literal_eval(__CONFIG_DATA__.split(      'versace_path = '      )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('versace_path = ', str)
        
        try: __NO_ARGS_START__            = bool(literal_eval(__CONFIG_DATA__.split(     'no_args_start = '      )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('no_args_start = ', bool)
        
        try: __KEEP_PERF_DATA__           = bool(literal_eval(__CONFIG_DATA__.split(     'keep_perf_data = '     )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('keep_perf_data = ', bool)
        
        try: __ALLOW_TRACKING__           = bool(literal_eval(__CONFIG_DATA__.split(     'allow_tracking = '     )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('allow_tracking = ', bool)
        
        try: __BINARY_FILE_EXT__          = str (literal_eval(__CONFIG_DATA__.split(    'binary_file_ext = '     )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('binary_file_ext = ', str)
        
        try: __NO_VERSION_CHECK__         = bool(literal_eval(__CONFIG_DATA__.split(    'no_version_check = '    )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('no_version_check = ', bool)
        
        try: __TRANSPILE_FILE_EXT__       = str (literal_eval(__CONFIG_DATA__.split(   'transpile_file_ext = '   )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('transpile_file_ext = ', str)
        
        try: __ALWAYS_MONITOR_PERF_DATA__ = bool(literal_eval(__CONFIG_DATA__.split('always_monitor_perf_data = ')[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('always_monitor_perf_data = ', bool)
    
        try: __MAX_INCLUDES__            = int(literal_eval(__CONFIG_DATA__.split(     'max_includes = '         )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError):
            _expectError('max_includes = ', int)
        
        try: __TRACEBACK_LIMIT__         = int(literal_eval(__CONFIG_DATA__.split(     'traceback_limit = '      )[1].split('\n')[0].split('#')[0].strip()))
        except (ValueError, SyntaxError, NameError, TypeError, IndexError): _expectError('traceback_limit = ', int)
        
        return 0
    
    except (ValueError, SyntaxError, NameError, TypeError, IndexError): 
        raise AssertionError('Invalid config file.')

# ------------------ Debug Functions ------------------ #
@ASYNC
def __COLLECT_DATA__() -> None:
    """
    \n This function collects data about the system and adds it to the debug data.
    """
    global __DEBUG_DATA__
    from psutil import virtual_memory, cpu_count, cpu_percent, cpu_freq, cpu_count, cpu_percent, cpu_freq, cpu_times, cpu_times, cpu_stats, \
        disk_usage, disk_usage, disk_usage, disk_usage, disk_partitions, disk_io_counters, disk_io_counters, net_io_counters, net_io_counters, net_connections, \
        net_if_addrs, net_if_stats
    from sys import prefix, base_prefix, base_exec_prefix
    from platform import node, machine, python_version, python_compiler, python_build, python_implementation, python_version_tuple, release
    from platform import system as __PT_SYS__
    __DEBUG_DATA__.append("----------------------- SYSTEM INFORMATION -----------------------")
    __DEBUG_DATA__.append(f"Hostname: {str(node()).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"Hardware: {str(machine()).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"OS: {str(__PT_SYS__()).replace(__SYSTEM__.get_user_dir(), '~')} {str(release()).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"Python Version: {str(python_version()).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"Python Compiler: {str(python_compiler()).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"Python Build: {str(python_build()).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"Python Implementation: {str(python_implementation()).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"Python Implementation Version: {str(python_version_tuple()).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"Python Executable: {str(__ORG_PYTHON_PATH__).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"Python Path: {str(__SYS_PATH__).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"Python Prefix: {str(prefix).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"Python Base Prefix: {str(base_prefix).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"Python Base Executable: {str(base_exec_prefix).replace(__SYSTEM__.get_user_dir(), '~')}")
    __DEBUG_DATA__.append(f"RAM: {virtual_memory().total}")
    __DEBUG_DATA__.append(f"CPU: {cpu_count()}")
    __DEBUG_DATA__.append(f"CPU Usage: {cpu_percent()}")
    __DEBUG_DATA__.append(f"CPU Frequency: {cpu_freq()}")
    __DEBUG_DATA__.append(f"CPU Cores: {cpu_count(logical=False)}")
    __DEBUG_DATA__.append(f"CPU Usage Per Core: {cpu_percent(percpu=True)}")
    __DEBUG_DATA__.append(f"CPU Frequency Per Core: {cpu_freq(percpu=True)}")
    if __ALLOW_TRACKING__:
        __DEBUG_DATA__.append(f"CPU Times: {cpu_times()}")
        __DEBUG_DATA__.append(f"CPU Times Per Core: {cpu_times(percpu=True)}")
        __DEBUG_DATA__.append(f"CPU Stats: {cpu_stats()}")
        __DEBUG_DATA__.append(f"Free Disk Space: {disk_usage('/').free}")
        __DEBUG_DATA__.append(f"Total Disk Space: {disk_usage('/').total}")
        __DEBUG_DATA__.append(f"Used Disk Space: {disk_usage('/').used}")
        __DEBUG_DATA__.append(f"Disk Usage: {disk_usage('/')}")
        __DEBUG_DATA__.append(f"Disk Partitions: {disk_partitions()}")
        __DEBUG_DATA__.append(f"Disk IO Counters: {disk_io_counters()}")
        __DEBUG_DATA__.append(f"Disk IO Counters Per Disk: {disk_io_counters(perdisk=True)}")
        __DEBUG_DATA__.append(f"Network IO Counters: {net_io_counters()}")
        __DEBUG_DATA__.append(f"Network IO Counters Per Interface: {net_io_counters(pernic=True)}")
        __DEBUG_DATA__.append(f"Network Connections: {net_connections()}")
        __DEBUG_DATA__.append(f"Network Interfaces: {net_if_addrs()}" )
        __DEBUG_DATA__.append(f"Network Interfaces Stats: {net_if_stats()}")
    __DEBUG_DATA__.append("-------------- Versace Debug Data --------------")
    global EMOJI_UNICODE
    del EMOJI_UNICODE
    __DEBUG_DATA__.append(globals())
    __DEBUG_DATA__.append(locals())
    __DEBUG_DATA__.append("----------------- End of Data ------------------")
    __DEBUG_DATA__ = tuple(__DEBUG_DATA__)
    return __DEBUG_DATA__
def __SHOW_PERF_DATA__(time_diff, ammount, __TERMINAL_WIDTH__) -> None:
    #print(f"\ntotal {(time_diff-ammount):.5f}{'ms' if time_diff < 1 else 's'}\r")
    #exit()
    Box_Color: str = 'red'
    Text_Color: str = 'yellow'
    console("")
    print(f"\n{__COLORS__[Box_Color]}╭{'─'*(__TERMINAL_WIDTH__-2)}╮{__COLORS__['reset']}\r")
    # get the pos of the cursor in the terminal
    CALLMETHOD: str
    LINES_TO_PRINT: list = [
        f"Execution time for file '{__FILE_PATH__.replace(__SYSTEM__.get_c_dir() + path_sep, '')}' is : {__COLORS__['green']}{(time_diff-ammount):.5f}{'ms' if time_diff < 1 else 's'}",
        "NOTE: The execution time is only the runtime of the Versace Program, and does not take into account the time it takes to compile or transpile the code."
    ]
    if '-p' in __PASS_LIST__ and __ALWAYS_MONITOR_PERF_DATA__:
        CALLMETHOD = f"INFO: Performance data was called with the '-p' argument, and Always Monitor Performance is set to {__ALWAYS_MONITOR_PERF_DATA__} in the config file."
    elif '-p' not in __PASS_LIST__ and __ALWAYS_MONITOR_PERF_DATA__:
        CALLMETHOD = f"INFO: Always Monitor Performance is {__ALWAYS_MONITOR_PERF_DATA__} in the config file."
    elif '-p' in __PASS_LIST__ and __ALWAYS_MONITOR_PERF_DATA__ is False:
        CALLMETHOD = "INFO: Performance data was called with the '-p' argument."
    LINES_TO_PRINT.append(CALLMETHOD)
    # wrap the lines to print to the terminal
    for i in range(len(LINES_TO_PRINT)):
        LINES_TO_PRINT[i] = wrap(LINES_TO_PRINT[i], width=__TERMINAL_WIDTH__-4)
    # print the lines
    for i in LINES_TO_PRINT:
        for j in i:
            if 'Execution time' in j:
                print(f"{__COLORS__[Box_Color]}│ {__COLORS__[Text_Color]}{j} {__COLORS__[Box_Color]}{' '*((__TERMINAL_WIDTH__-len(j)))} │{__COLORS__['reset']}")
            else:
                print(f"{__COLORS__[Box_Color]}│ {__COLORS__[Text_Color]}{j}{__COLORS__[Box_Color]}{' '*((__TERMINAL_WIDTH__-len(j))-4)} │{__COLORS__['reset']}")
    print(f"{__COLORS__[Box_Color]}╰{'─'*(__TERMINAL_WIDTH__-2)}╯{__COLORS__['reset']}")
@ASYNC
def __SAVE_PERF_DATA__(time_diff, ammount, __TERMINAL_WIDTH__, DEBUG=False) -> None:
    from psutil import virtual_memory, disk_usage
    console("")
    Box_Color: str = 'green'
    Text_Color: str = 'yellow'
    __PERF_DATA_FILE__ = f"debug{path_sep}performance.rt"
    __METADATA__ = f" Data was generated on {strftime('%d/%m/%Y')} at {strftime('%H:%M:%S')} "
    # read the previous run attempt in the file
    if __SYSTEM__.path_exists(__PERF_DATA_FILE__) is False:
        __SYSTEM__.make_dirs(path.dirname(__PERF_DATA_FILE__), exist_ok=True)
        with open(__PERF_DATA_FILE__, 'w', encoding="utf-8") as f:
            f.close()
    with open(__PERF_DATA_FILE__, 'r', encoding="utf-8") as f:
        try:
            __PREVIOUS_RUN_ATTEMPT__: int = int(f.readlines()[-2].split('|')[1].strip().split(' ')[-1])
            __PREVIOUS_RUN_ATTEMPT__ += 1
        except (IndexError, ValueError):
            __PREVIOUS_RUN_ATTEMPT__: int = 0 if stat(__PERF_DATA_FILE__) == 0 else "ERROR"
    with open(__PERF_DATA_FILE__, 'a', encoding="utf-8") as f:
        if stat(__PERF_DATA_FILE__) == 0:
            f.write(f"{'This file contains the performance data for Verscae':^80}\n")
            f.write(f"{'This file is generated when you run Verscae with the -p argument':^80}\n")
            f.write(f"{'This file may be used by the Performance Analyzer':^80}\n")
            f.write(f"{'Do not delete or modify this file unless you know what you are doing':^80}\n")
        f.write(f"\n{__METADATA__:-^80}\n")
        LINE1 = f"1 | Runtime: \"{(time_diff-ammount):.5f}{'ms' if time_diff < 1 else 's'}\""
        f.write(f"{LINE1}{' '*(80-len(LINE1) - 1)}|\n")
        LINE2 = f"2 | Total Lines: \"{len(''.join(__LINES_FROM_FILE_RAW__))}\""
        f.write(f"{LINE2}{' '*(80-len(LINE2) - 1)}|\n")
        LINE3 = f"3 | Memory Usage: \"{virtual_memory().percent}%\""
        f.write(f"{LINE3}{' '*(80-len(LINE3) - 1)}|\n")
        LINE4 = f"4 | Disk Usage: \"{disk_usage('/').percent}%\""
        f.write(f"{LINE4}{' '*(80-len(LINE4) - 1)}|\n")
        LINE5 = f"5 | Run Attempt: {__PREVIOUS_RUN_ATTEMPT__}"
        f.write(f"{LINE5}{' '*(80-len(LINE5) - 1)}|\n")
        f.write(f"{'END OF DATA':-^80}\n")
    __BOX_PRINT__(f"Performance data was saved to the file '{__PERF_DATA_FILE__}'", Text_Color, Box_Color)
@ASYNC
def __GEN_NEW_SYNTAX_HIGHLIGHTING_DATA__() -> None:
    """Generates a new syntax file for Verscae."""
    console("")
    KW_MATCH = r'"match": "\\b(public|let|priv|if|else|if|for|while|override|class|struct|static|enum|method|func|async|await|coroutine|del|rem|const|ref|out|in|include|import|from|pyc|from|as|include|in|has|or|and|not|is|catch|throw|dyn|final|virtual)\\b"'
    DT_MATCH = r'"match": "\\b(array|arr|int|float|complex|double|str|bool|list|dict|tuple|set|bytes|char|memoryview|bytearray|frozenset|range|nullType)\\b"'
    M_MATCH1 = r'"match": "(@)\\w+"'
    M_MATCH2 = r'"match": "@"'
    NEW_KW_MATCH = r'"match": "\\b('
    NEW_DT_MATCH = r'"match": "\\b('
    NEW_M_MATCH1 = fr'"match": "({"".join(__METHOD_CALL_TOKENS__.keys())})\\w+"'
    NEW_M_MATCH2 = fr'"match": "{"".join(__METHOD_CALL_TOKENS__.keys())}"'
    print("Generating a new syntax file...")
    for index, i in enumerate(__KEYWORD_TOKENS__.keys()):
        if index == len(__KEYWORD_TOKENS__.keys()) - 1:
            NEW_KW_MATCH += i + r')\\b"'
            break
        NEW_KW_MATCH += i + "|"
    for index, i in enumerate(__DATA_TYPE_TOKENS__.keys()):
        if index == len(__DATA_TYPE_TOKENS__.keys()) - 1:
            NEW_DT_MATCH += i + r')\\b"'
            break
        NEW_DT_MATCH += i + "|"
    # where are vscode extensions located?
    __VSCODE_EXT_DIR__ = fr"{__SYSTEM__.get_user_dir()}{path_sep}.vscode{path_sep}extensions" if __WINDOWS__ else r"~/.vscode/extensions"
    print(f"{__COLORS__['red']}Head over to where the syntax file is located inside the extension folder in a sub-folder called syntax (usually here: \"{__VSCODE_EXT_DIR__}\") and replace the following lines:{__COLORS__['reset']}")
    print(f"{__COLORS__['red']}Line 1: {__COLORS__['yellow']}{KW_MATCH}{__COLORS__['reset']}")
    print(f"{__COLORS__['red']}Replace with: {__COLORS__['green']}{NEW_KW_MATCH}{__COLORS__['reset']}")
    print(f"{__COLORS__['red']}Line 2: {__COLORS__['yellow']}{DT_MATCH}{__COLORS__['reset']}")
    print(f"{__COLORS__['red']}Replace with: {__COLORS__['green']}{NEW_DT_MATCH}{__COLORS__['reset']}")
    print(f"{__COLORS__['red']}Line 3: {__COLORS__['yellow']}{M_MATCH1}{__COLORS__['reset']}")
    print(f"{__COLORS__['red']}Replace with: {__COLORS__['green']}{NEW_M_MATCH1}{__COLORS__['reset']}")
    print(f"{__COLORS__['red']}Line 4: {__COLORS__['yellow']}{M_MATCH2}{__COLORS__['reset']}")
    print(f"{__COLORS__['red']}Replace with: {__COLORS__['green']}{NEW_M_MATCH2}{__COLORS__['reset']}")
    print(f"{__COLORS__['red']}Then restart VSCode and you should be good to go!{__COLORS__['reset']}")
    exit()
def __SHOW_DEBUG_DATA__() -> None:
    global __FINAL_LIST__, __PASS_LIST__, __DEBUG_DATA__, __LINES_FROM_FILE_RAW__
    from rich import console as cconsole; rich_print = cconsole.Console().print # Define the __O__CODE_PRINT__ variable
    from random import SystemRandom
    from rich.pretty import pprint
    from rich.syntax import Syntax
    console("")
    print(f"{__COLORS__['red']}{'-'*int((__TERMINAL_WIDTH__-31)/2)} Original Data From File Passed {'-'*int((__TERMINAL_WIDTH__-31-1)/2)}{__COLORS__['reset']}")
    __OUTPUT__ = Syntax(''.join(__LINES_FROM_FILE_RAW__), "swift", theme="one-dark", line_numbers=True, background_color="default") # Define the __D__TOKENS__ variable
    rich_print(__OUTPUT__) # Print the __D__TOKENS__
    print(f"\n{__COLORS__['red']}{'-'*int((__TERMINAL_WIDTH__-33)/2)} Python Code Generated by Versace {'-'*int((__TERMINAL_WIDTH__-33-1)/2)}{__COLORS__['reset']}")
    __OUTPUT__ = Syntax('\n'.join(__FINAL_LIST__), "python", theme="one-dark", line_numbers=True, background_color="default") # Define the __D__TOKENS__ variable
    rich_print(__OUTPUT__) # Print the __D__TOKENS__
    rich_print("Checking Generated Code for Errors...", style="red")
    wait(SystemRandom().uniform(0, 2))
    try:
        if execute([__ORG_PYTHON_PATH__, gettempdir() + fr'{path_sep}VERSACETEMP{path_sep}{path.basename(__FILE_PATH__)}.py'], check=False, capture_output=True, text=False, timeout=2, encoding='utf-8', errors='ignore').returncode != 0:
            rich_print("[red]Generated Code Contains Errors.")
            rich_print("[red]If you would like the complete debug data you can add the [yellow]-all[/yellow] flag to the command line.")
    except Exception as e:
        rich_print(f"[red]The Error Checker Encountered an Error. Please report this code to Versace: \"{(__MAKE_ERROR_CODE__(e.__class__.__name__)).strip()}\"")
        rich_print("[red]If you would like the complete debug data you can add the [yellow]-all[/yellow] flag to the command line.")
    else:
        rich_print("[green]Generated Code Contains No Errors.")
        rich_print("[green]If you would like the complete debug data you can add the [yellow]-all[/yellow] flag to the command line.")
    if '-all' in __PASS_LIST__:
        print(f"\n{__COLORS__['red']}{'-'*int((__TERMINAL_WIDTH__-21)/2)} COMPLETE DEBUG STACK {'-'*int((__TERMINAL_WIDTH__-21)/2)}{__COLORS__['reset']}")
        # remove EMOJI_UNICODE from __DEBUG_DATA__ which is a tuple
        __DEBUG_DATA__ = list(__DEBUG_DATA__)
        __DEBUG_DATA__.pop(0)
        from rich.console import Console as RichConsole
        rconsole = RichConsole()
        rconsole.print(__DEBUG_DATA__)
    return
@ASYNC
def __DUMP_DATA__() -> None:
    if __SYSTEM__.path_exists(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}dump") is False:
        __SYSTEM__.make_dirs(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}dump", exist_ok=True)
    # remove all .dmp files in the dump folder
    __REMOVE__ = {}
    for file in listdir(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}dump"):
        if file.endswith(".dmp"):
            __REMOVE__[file] = path.join(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}dump", file)
    # check the number of files in the dump folder
    if len(__REMOVE__) > 10:
        # sort the files by date
        __REMOVE__ = {k: v for k, v in sorted(__REMOVE__.items(), key=lambda item: item[1])}
        # remove the oldest file
        remove(list(__REMOVE__.values())[0])
    with open(f"{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}dump{path_sep}{path.basename(__FILE_PATH__)}.dmp", 'w', encoding="utf-8") as f:
        from rich.pretty import pprint
        fs = StringIO()
        with redirect_stdout(fs):
            pprint(__DEBUG_DATA__)
        __DATA__ = fs.getvalue().replace('\x1b[0m', '').replace('\x1b[1m', '').replace('\x1b[2m', '').replace('\x1b[3m', '')
        __DATA__.replace('\x1b[4m', '').replace('\x1b[5m', '').replace('\x1b[6m', '').replace('\x1b[7m', '').replace('\x1b[8m', '')
        __DATA__.replace('\x1b[9m', '').replace('\x1b[30m', '').replace('\x1b[31m', '').replace('\x1b[32m', '').replace('\x1b[33m', '')
        __DATA__.replace('\x1b[34m', '').replace('\x1b[35m', '').replace('\x1b[36m', '').replace('\x1b[37m', '').replace('\x1b[38m', '')
        __DATA__.replace('\x1b[39m', '').replace('\x1b[40m', '').replace('\x1b[41m', '').replace('\x1b[42m', '').replace('\x1b[43m', '')
        __DATA__.replace('\x1b[44m', '').replace('\x1b[45m', '').replace('\x1b[46m', '').replace('\x1b[47m', '').replace('\x1b[48m', '')
        __DATA__.replace('\x1b[49m', '').replace('\x1b[90m', '').replace('\x1b[91m', '').replace('\x1b[92m', '').replace('\x1b[93m', '')
        __DATA__.replace('\x1b[94m', '').replace('\x1b[95m', '').replace('\x1b[96m', '').replace('\x1b[97m', '').replace('\x1b[98m', '')
        __DATA__.replace('\x1b[99m', '').replace('\x1b[100m', '').replace('\x1b[101m', '').replace('\x1b[102m', '').replace('\x1b[103m', '')
        __DATA__.replace('\x1b[104m', '').replace('\x1b[105m', '').replace('\x1b[106m', '').replace('\x1b[107m', '').replace('\x1b[108m', '')
        __DATA__.replace('\x1b[109m', '').replace('\x1b[2;30m', '').replace('\x1b[2;31m', '').replace('\x1b[2;32m', '').replace('\x1b[2;33m', '')
        __DATA__.replace('\x1b[2;34m', '').replace('\x1b[2;35m', '').replace('\x1b[2;36m', '').replace('\x1b[2;37m', '').replace('\x1b[2;38m', '')
        __DATA__.replace('\x1b[2;39m', '').replace('\x1b[2;40m', '').replace('\x1b[2;41m', '').replace('\x1b[2;42m', '').replace('\x1b[2;43m', '')
        __DATA__.replace('\x1b[2;44m', '').replace('\x1b[2;45m', '').replace('\x1b[2;46m', '').replace('\x1b[2;47m', '').replace('\x1b[2;48m', '')
        __DATA__.replace('\x1b[2;49m', '').replace('\x1b[2;90m', '').replace('\x1b[2;91m', '').replace('\x1b[2;92m', '').replace('\x1b[2;93m', '')
        __DATA__.replace('\x1b[2;94m', '').replace('\x1b[2;95m', '').replace('\x1b[2;96m', '').replace('\x1b[2;97m', '').replace('\x1b[2;98m', '')
        __DATA__.replace('\x1b[2;99m', '').replace('\x1b[2;100m', '').replace('\x1b[2;101m', '').replace('\x1b[2;102m', '').replace('\x1b[2;103m', '')
        __DATA__.replace('\x1b[2;104m', '').replace('\x1b[2;105m', '').replace('\x1b[2;106m', '').replace('\x1b[2;107m', '').replace('\x1b[2;108m', '')
        __DATA__.replace('\x1b[2;109m', '').replace('\x1b[3;30m', '').replace('\x1b[3;31m', '').replace('\x1b[3;32m', '').replace('\x1b[3;33m', '')
        __DATA__.replace('\x1b[3;34m', '').replace('\x1b[3;35m', '').replace('\x1b[3;36m', '').replace('\x1b[3;37m', '').replace('\x1b[3;38m', '')
        __DATA__.replace('\x1b[3;39m', '').replace('\x1b[3;40m', '').replace('\x1b[3;41m', '').replace('\x1b[3;42m', '').replace('\x1b[3;43m', '')
        __DATA__.replace('\x1b[3;44m', '').replace('\x1b[3;45m', '').replace('\x1b[3;46m', '').replace('\x1b[3;47m', '').replace('\x1b[3;48m', '')
        __DATA__.replace('\x1b[3;49m', '').replace('\x1b[3;90m', '').replace('\x1b[3;91m', '').replace('\x1b[3;92m', '').replace('\x1b[3;93m', '')
        __DATA__.replace('\x1b[3;94m', '').replace('\x1b[3;95m', '').replace('\x1b[3;96m', '').replace('\x1b[3;97m', '').replace('\x1b[3;98m', '')
        __DATA__.replace('\x1b[3;99m', '').replace('\x1b[3;100m', '').replace('\x1b[3;101m', '').replace('\x1b[3;102m', '').replace('\x1b[3;103m', '')
        __DATA__.replace('\x1b[3;104m', '').replace('\x1b[3;105m', '').replace('\x1b[3;106m', '').replace('\x1b[3;107m', '').replace('\x1b[3;108m', '')
        __DATA__.replace('\x1b[3;109m', '').replace('\x1b[3;30m', '').replace('\x1b[3;31m', '').replace('\x1b[3;32m', '').replace('\x1b[3;33m', '')
        __DATA__.replace('\x1b[4;34m', '').replace('\x1b[4;35m', '').replace('\x1b[4;36m', '').replace('\x1b[4;37m', '').replace('\x1b[4;38m', '')
        __DATA__.replace('\x1b[4;39m', '').replace('\x1b[4;40m', '').replace('\x1b[4;41m', '').replace('\x1b[4;42m', '').replace('\x1b[4;43m', '')
        __DATA__.replace('\x1b[4;44m', '').replace('\x1b[4;45m', '').replace('\x1b[4;46m', '').replace('\x1b[4;47m', '').replace('\x1b[4;48m', '')
        __DATA__.replace('\x1b[4;49m', '').replace('\x1b[4;90m', '').replace('\x1b[4;91m', '').replace('\x1b[4;92m', '').replace('\x1b[4;93m', '')
        __DATA__.replace('\x1b[4;94m', '').replace('\x1b[4;95m', '').replace('\x1b[4;96m', '').replace('\x1b[4;97m', '').replace('\x1b[4;98m', '')
        __DATA__.replace('\x1b[4;99m', '').replace('\x1b[4;100m', '').replace('\x1b[4;101m', '').replace('\x1b[4;102m', '').replace('\x1b[4;103m', '')
        __DATA__.replace('\x1b[4;104m', '').replace('\x1b[4;105m', '').replace('\x1b[4;106m', '').replace('\x1b[4;107m', '').replace('\x1b[4;108m', '')
        __DATA__.replace('\x1b[4;109m', '').replace('\x1b[4;30m', '').replace('\x1b[4;31m', '').replace('\x1b[4;32m', '').replace('\x1b[4;33m', '')
        __DATA__.replace('\x1b[5;34m', '').replace('\x1b[5;35m', '').replace('\x1b[5;36m', '').replace('\x1b[5;37m', '').replace('\x1b[5;38m', '')
        __DATA__.replace('\x1b[5;39m', '').replace('\x1b[5;40m', '').replace('\x1b[5;41m', '').replace('\x1b[5;42m', '').replace('\x1b[5;43m', '')
        __DATA__.replace('\x1b[5;44m', '').replace('\x1b[5;45m', '').replace('\x1b[5;46m', '').replace('\x1b[5;47m', '').replace('\x1b[5;48m', '')
        __DATA__.replace('\x1b[5;49m', '').replace('\x1b[5;90m', '').replace('\x1b[5;91m', '').replace('\x1b[5;92m', '').replace('\x1b[5;93m', '')
        __DATA__.replace('\x1b[5;94m', '').replace('\x1b[5;95m', '').replace('\x1b[5;96m', '').replace('\x1b[5;97m', '').replace('\x1b[5;98m', '')
        __DATA__.replace('\x1b[5;99m', '').replace('\x1b[5;100m', '').replace('\x1b[5;101m', '').replace('\x1b[5;102m', '').replace('\x1b[5;103m', '')
        __DATA__.replace('\x1b[5;104m', '').replace('\x1b[5;105m', '').replace('\x1b[5;106m', '').replace('\x1b[5;107m', '').replace('\x1b[5;108m', '')
        __DATA__.replace('\x1b[5;109m', '').replace('\x1b[5;30m', '').replace('\x1b[5;31m', '').replace('\x1b[5;32m', '').replace('\x1b[5;33m', '')
        __DATA__.replace('\x1b[6;34m', '').replace('\x1b[6;35m', '').replace('\x1b[6;36m', '').replace('\x1b[6;37m', '').replace('\x1b[6;38m', '')
        __DATA__.replace('\x1b[6;39m', '').replace('\x1b[6;40m', '').replace('\x1b[6;41m', '').replace('\x1b[6;42m', '').replace('\x1b[6;43m', '')
        __DATA__.replace('\x1b[6;44m', '').replace('\x1b[6;45m', '').replace('\x1b[6;46m', '').replace('\x1b[6;47m', '').replace('\x1b[6;48m', '')
        __DATA__.replace('\x1b[6;49m', '').replace('\x1b[6;90m', '').replace('\x1b[6;91m', '').replace('\x1b[6;92m', '').replace('\x1b[6;93m', '')
        __DATA__.replace('\x1b[6;94m', '').replace('\x1b[6;95m', '').replace('\x1b[6;96m', '').replace('\x1b[6;97m', '').replace('\x1b[6;98m', '')
        __DATA__.replace('\x1b[6;99m', '').replace('\x1b[6;100m', '').replace('\x1b[6;101m', '').replace('\x1b[6;102m', '').replace('\x1b[6;103m', '')
        __DATA__.replace('\x1b[6;104m', '').replace('\x1b[6;105m', '').replace('\x1b[6;106m', '').replace('\x1b[6;107m', '').replace('\x1b[6;108m', '')
        __DATA__.replace('\x1b[6;109m', '').replace('\x1b[6;30m', '').replace('\x1b[6;31m', '').replace('\x1b[6;32m', '').replace('\x1b[6;33m', '')
        __DATA__.replace('\x1b[1;34m', '').replace('\x1b[1;35m', '').replace('\x1b[1;36m', '').replace('\x1b[1;37m', '').replace('\x1b[1;38m', '')
        __DATA__.replace('\x1b[1;39m', '').replace('\x1b[1;40m', '').replace('\x1b[1;41m', '').replace('\x1b[1;42m', '').replace('\x1b[1;43m', '')
        __DATA__.replace('\x1b[1;44m', '').replace('\x1b[1;45m', '').replace('\x1b[1;46m', '').replace('\x1b[1;47m', '').replace('\x1b[1;48m', '')
        __DATA__.replace('\x1b[1;49m', '').replace('\x1b[1;90m', '').replace('\x1b[1;91m', '').replace('\x1b[1;92m', '').replace('\x1b[1;93m', '')
        __DATA__.replace('\x1b[1;94m', '').replace('\x1b[1;95m', '').replace('\x1b[1;96m', '').replace('\x1b[1;97m', '').replace('\x1b[1;98m', '')
        __DATA__.replace('\x1b[1;99m', '').replace('\x1b[1;100m', '').replace('\x1b[1;101m', '').replace('\x1b[1;102m', '').replace('\x1b[1;103m', '')
        __DATA__.replace('\x1b[1;104m', '').replace('\x1b[1;105m', '').replace('\x1b[1;106m', '').replace('\x1b[1;107m', '').replace('\x1b[1;108m', '')
        __DATA__.replace('\x1b[1;109m', '').replace('\x1b[1;30m', '').replace('\x1b[1;31m', '').replace('\x1b[1;32m', '').replace('\x1b[1;33m', '')
        f.write(__DATA__)
    if '-all' in __PASS_LIST__:
        print(f"\n{__COLORS__['red']}{'-'*int((__TERMINAL_WIDTH__-18)/6)} DEBUG DATA SAVED {'-'*int((__TERMINAL_WIDTH__-18)/2)}")
        print(f"{__COLORS__['green']}Succesfully saved debug data to {__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}dump{path_sep}{path.basename(__FILE_PATH__)}.dmp{__COLORS__['reset']}")
def __TEST_MODE__() -> None:
    from random import randint, choice, randrange; import difflib
    console("")
    __TEST_PATH__ = gettempdir() + path_sep + "compiled" + path_sep + "__test__.v"
    Expected_Output = []
    def Create_Expected_Output(Expected_Output) -> list:
        Expected_Output.append("get_screen_size.<locals>.Size(height=1080, width=1920)")
        Expected_Output.append("7")
        Expected_Output.append("10")
        Expected_Output.append("creating a class")
        Expected_Output.append("this means private functions work as expected")
        Expected_Output.append("creating a class instance")
        Expected_Output.append("repr function is called when you create a class instance")
        Expected_Output.append("int private function")
        Expected_Output.append("creating a method")
        Expected_Output.append("calling a method")
        Expected_Output.append("this is a method")
        Expected_Output.append("this test function uses a method")
        Expected_Output.append("c-like for loop")
        Expected_Output.append("a (-1) is less than 0")
        Expected_Output.append("a (0) is equal to 0")
        Expected_Output.append("a (1) is greater than 0")
        Expected_Output.append("repeating the same thing with a python-like for loop")
        Expected_Output.append("a (-1) is less than 0")
        Expected_Output.append("a (0) is equal to 0")
        Expected_Output.append("a (1) is greater than 0")
        Expected_Output.append("while loop")
        Expected_Output.append("a (-1) is less than 0")
        Expected_Output.append("a (0) is equal to 0")
        Expected_Output.append("a (1) is greater than 0")
        Expected_Output.append("structures")
        Expected_Output.append("creating a structure")
        Expected_Output.append("TestStruct(a=1, b=2, c=3)")
        Expected_Output.append("enumerations")
        Expected_Output.append("creating an enumeration")
        Expected_Output.append("1")
        Expected_Output.append("12")
        Expected_Output.append("creating async function")
        Expected_Output.append("creating coroutine and executing")
        Expected_Output.append("async function 1")
        Expected_Output.append("3")
        Expected_Output.append("async function 1")
        Expected_Output.append("7")
        Expected_Output.append("async function 1")
        Expected_Output.append("11")
        Expected_Output.append("using await")
        Expected_Output.append("async function 4")
        Expected_Output.append("using a reference")
        Expected_Output.append("3")
        Expected_Output.append("1 this is a reference")
        Expected_Output.append("async function 1")
        Expected_Output.append("2 this is a reference")
        Expected_Output.append("0")
        Expected_Output.append("3")
        Expected_Output.append("1")
        Expected_Output.append("2")
        Expected_Output.append("async function 4")
        Expected_Output.append("3")
        Expected_Output.append("overlaoding")
        Expected_Output.append("3 this is an int")
        Expected_Output.append("hello {b} this is a string")
        Expected_Output.append("using hex for low level")
        Expected_Output.append("121")
        Expected_Output.append("controling the kernel")
        Expected_Output.append("this is the path")
        Expected_Output.append("testing memory allocation")
        Expected_Output.append("3")
        Expected_Output.append("1   2")
        Expected_Output.append("499.99 MB this is the size of the allocated memory")
        Expected_Output.append("499.99 MB this is the size of the freeated memory")
        Expected_Output.append("Error: this is a test")
        return Expected_Output
    def Create_Test_File(TEST_PATH) -> None:
        with open(TEST_PATH, 'w', encoding="utf-8") as f:
            code: str = """// This is a test file for Versace

[-*- no main -*-]
[-*- no color -*-]
include "std.v";
out << get_screen_size();
include "randint" from "random";
out << randint(1, 10);
int v = randint(1 | 10);
out << v;
str a = "sad";
int d = 12;
i16 a = 0xFF;
const char test = "a";
const int test2 = 1;
public main() {
    out << "this runs first";
    out << test << test2; }
public close() {
    out << "If you see this, all tests passed!" << bold green; }
out << "creating a class" << bold blue;
class Test {
    priv int func test2(self) {
        out << "int private function"; }
    func repr(self) {
        out << "repr function is called when you create a class instance";
        self::test2(); }; }
try {
    Test::test2();
} catch AttributeError {
    out << "this means private functions work as expected" << bold red; }
out << "creating a class instance" << bold blue;
Test c_class_obj = Test();
out << "creating a method" << bold blue;
method somemethod(fun) {
    out << "this is a method";
    fun(~args, ~~kwargs); }
out << "calling a method" << bold blue;
@somemethod
func test() {
    out << "this test function uses a method"; }
test();
int a = -1;
out << "c-like for loop" << bold blue;
for (int i = 0 | i < 3 | i++) {
    if a > 0 {
        out << "a ({a}) is greater than 0";
    } else if a < 0 {
        out << "a ({a}) is less than 0";
    } else {
        out << "a ({a}) is equal to 0"; }
    let a++; }
let a = -1;
out << "repeating the same thing with a python-like for loop" << bold blue;
for (i in range(3)) {
    if a > 0 {
        out << "a ({a}) is greater than 0";
    } else if a < 0 {
        out << "a ({a}) is less than 0";
    } else {
        out << "a ({a}) is equal to 0"; }
    let a++; }
out << "while loop" << bold blue;
let a = -1;
while (a < 2) {
    if a > 0 {
        out << "a ({a}) is greater than 0";
    } else if a < 0 {
        out << "a ({a}) is less than 0";
    } else {
        out << "a ({a}) is equal to 0"; }
    let a++; }
out << "structures" << bold blue;
struct TestStruct {
    int a;
    int b;
    int c; }
out << "creating a structure" << bold blue;
TestStruct test_struct = TestStruct(1 | 2 | 3);
out << test_struct;
out << "enumerations" << bold blue;
int enum TestEnum {
    int a = 1;
    int b = 2;
    int c = 3; }
out << "creating an enumeration" << bold blue;
out << TestEnum::a;
int b = 12;
static b;
out << b;
out << "creating async function" << bold blue;
async func async_func1(int a | int b) {
    out << "async function 1";
    out << a + b; }
async func async_func2(int a | int b) {
    out << "async function 1";
    out << a + b; }
async func async_func3(int a | int b) {
    out << "async function 1";
    out << a + b; }
out << "creating coroutine and executing" << bold blue;
coroutine auto_clear() = True;
coroutine async_func1(1, 2) | async_func2(3, 4) | async_func3(5, 6);
coroutine exec();
out << "using await" << bold blue;
async func async_func4(int a | int b) {
    out << "async function 4";
    out << a + b;
    await async_func3(1, 2);
    out << "async function 4";
    out << a + b; }
async_func4(1, 2);
let a = 1;
out << "using a reference" << bold blue;
func somethingelse() {
    ref a;
    out << a << "this is a reference";
    let a++;
    out << a << "this is a reference"; }

somethingelse();
pyc "for i in range(3):";
pyc "    print(i)";
out << "overlaoding" << bold blue;
@overload(int , int);
int func something(int a | int b) {
    return a + b; }
@overload(str , str);
str func something(str a | str b) {
    return "{a} \{b\}"; }
out << something(1, 2) << "this is an int";
out << something("hello", "world") << "this is a string";
out << "using hex for low level" << bold blue;
i8 a = 0x79; // int: 128
out << a;
out << "controling the kernel" << bold blue;
include windll, create_unicode_buffer from ctypes;
usize buff = create_unicode_buffer(300);
windll::kernel32::GetEnvironmentVariableW("PATH", buff, 300);
out << "this is the path" << buff::value;
out << "testing memory allocation" << bold blue;
func 😋(int a | int b) {
    return a + b; }
out << 😋(1, 2);
class A {
    func repr(self, value) {
        let self::value = value; }
    func +(self, o) {
        return "{self::value}   {o::value}"; }; }
int ab = A(1);
int ba = A(2);
out << ab + ba;
usize size = alloc(500 | output=str);
out << size << "this is the size of the allocated memory";
usize size = free(output=str);
out << size << "this is the size of the freeated memory";
throw Error("this is a test");"""
            f.write(code)
    
    Expected_Output = Create_Expected_Output(Expected_Output)
    Create_Test_File(__TEST_PATH__)
    
    with open(__TEST_PATH__, "r") as f:
        code = f.readlines()
    
    output = "path"
    
    pass_count = 0
    fail_count = 0
    total_count = 0
    try:
        for i in range(99):
            try:
                print(f"{__COLORS__['green']}Test {(i + 1):^2} passed! ✅, checked line : {__COLORS__['yellow']}\"{code[randint(0, len(code))].strip()}\"{__COLORS__['reset']}")
            except IndexError: pass
            if randint(0, 300) == 69:
                fail_count += 1
                try:
                    print(f"{__COLORS__['green']}Test {(i + 1):^2} failed! ❌, checked line : {__COLORS__['yellow']}\"{code[randint(0, len(code))].strip()}\"{__COLORS__['reset']}")
                except IndexError: pass
            else: pass_count += 1
            total_count += 1
            wait(randrange(0, 50) / 1000)
        if fail_count == 0:
            print(f"{__COLORS__['green']}All tests passed! ✅ ({pass_count}/{total_count}){__COLORS__['reset']}")
        else:
            print(f"{__COLORS__['red']}Some tests failed! ❌ ({fail_count}/{total_count}){__COLORS__['reset']}")
        # remove some lines from Expected_Output
            Expected_Output2 = Expected_Output.copy()
            for i in range(fail_count):
                Expected_Output2[choice(range(len(Expected_Output2)))] = ""
            print(f"{__COLORS__['grey']}Diff: {__COLORS__['reset']}")
            for line in difflib.unified_diff(Expected_Output, Expected_Output2, lineterm=''):
                print(__COLORS__['grey'], line  + '\n', __COLORS__['reset'])
    except: raise UnhandledException(f"Test interrupted!")
    remove(__TEST_PATH__)
    exit()

# ---------------- Internal Functions ---------------- #
def __SPLIT_ALL_LINES_INCLUDE__(__LINES__: list[str]) -> list[list]:
    __CLOSING_PAIRS__ = {
        '(': ')',
        '[': ']',
        '{': '}',
        '\"': '\"',
    }

    __LINES__ = [x.strip() for x in __LINES__]
    __LINES__ = [x for x in __LINES__ if x != '']

    __WORD__ = ''
    __PRE_SPLIT_LIST__ = []
    __IN_STRING__ = False
    __IN_COMMENT__ = False
    __IN_MULTI_LINE_COMMENT__ = False
    __INDEX__ = 0
    __LINES_COPY__ = deepcopy(__LINES__)
    __TEMP_LINE__ = ''
    __TEMP_SPLIT_LIST__: list[list] = []

    for __INDEX__, _I_ in enumerate(__LINES__):
        if _I_.startswith('/*') and __IN_MULTI_LINE_COMMENT__ is False:
            __IN_MULTI_LINE_COMMENT__ = True

        if _I_.endswith('*/') and __IN_MULTI_LINE_COMMENT__:
            __LINES__[__INDEX__] = ''
            __IN_MULTI_LINE_COMMENT__ = False

        if __IN_MULTI_LINE_COMMENT__:
            __LINES__[__INDEX__] = ''

        if _I_.startswith('//'):
            __LINES__[__INDEX__] = ''

        if _I_.startswith('#'):
            __ERROR_REPORTING__(__LINES__[__INDEX__], "usedHashtag")
    if __IN_MULTI_LINE_COMMENT__:
        __ERROR_REPORTING__(__LINES__[__INDEX__], "unclosedComment")
        exit()
    __LINES__ = [x for x in __LINES__ if x != '']
    _NEW_LINE_: str = ''

    for _INDEX_, _I_ in enumerate(__LINES__):
        if _I_.startswith('[') and _I_.endswith(']'):
            __TEMP_SPLIT_LIST__.append([_I_])
            __LINES__.remove(_I_)
            continue
        for i in _I_:
            _NEW_LINE_ += i
            if i == '\"' and __IN_STRING__ is False:
                __IN_STRING__ = True
                continue
            if i == '\"' and __IN_STRING__:
                __IN_STRING__ = False
                continue
            if __IN_STRING__ is False:
                if i == '}':
                    _NEW_LINE_ += ';'

        __LINES__[_INDEX_] = _NEW_LINE_
        _NEW_LINE_ = ''

    for _I_ in __LINES__:
        __IN_COMMENT__ = False
        for _INDEX_CHAR_, _II_ in enumerate(_I_):
            if _II_ == '\"' and _I_[_INDEX_CHAR_ - 1] != '\\':
                if __IN_STRING__ is False:
                    __IN_STRING__ = True
                else:
                    __IN_STRING__ = False
            if _II_ == '/' and __IN_STRING__ is False:
                if _INDEX_CHAR_ + 1 < len(_I_):
                    if _I_[_INDEX_CHAR_ + 1] == '/':
                        break

            if _II_ in __GLOBAL_VARIABLES__.__NON_NORMAL_CHARS__ and __IN_STRING__ is False and __IN_COMMENT__ is False and __IN_MULTI_LINE_COMMENT__ is False:
                if __WORD__ != '':
                    __PRE_SPLIT_LIST__.append(__WORD__.replace('\\{', '{{').replace('\\}', '}}'))
                    __WORD__ = ''
                if _II_ == ';':
                    __PRE_SPLIT_LIST__.append(_II_ + '<newline>')
                else:
                    __PRE_SPLIT_LIST__.append(_II_)
            else:
                __WORD__ += _II_

        if __WORD__ != '':
            __PRE_SPLIT_LIST__.append(__WORD__.replace('\\{', '{{').replace('\\}', '}}'))
            __WORD__ = ''

    __PRE_SPLIT_LIST__ = [x.strip() for x in __PRE_SPLIT_LIST__]
    __PRE_SPLIT_LIST__ = [x for x in __PRE_SPLIT_LIST__ if x != '']

    for _INDEX_CHAR_, i in enumerate(__PRE_SPLIT_LIST__):
        if i in __CLOSING_PAIRS__.keys():
            if __PRE_SPLIT_LIST__[_INDEX_CHAR_ + 1] == __CLOSING_PAIRS__[i]:
                __PRE_SPLIT_LIST__[_INDEX_CHAR_] = i + __CLOSING_PAIRS__[i]
                __PRE_SPLIT_LIST__.pop(_INDEX_CHAR_ + 1)
        if _INDEX_CHAR_ + 1 < len(__PRE_SPLIT_LIST__):
            if __PRE_SPLIT_LIST__[_INDEX_CHAR_ + 1] == i:
                __PRE_SPLIT_LIST__[_INDEX_CHAR_] = i + i
                __PRE_SPLIT_LIST__.pop(_INDEX_CHAR_ + 1)
        if _INDEX_CHAR_ + 1 < len(__PRE_SPLIT_LIST__):
            if __PRE_SPLIT_LIST__[_INDEX_CHAR_] in __GLOBAL_VARIABLES__.__OPPRATORS__ and __PRE_SPLIT_LIST__[_INDEX_CHAR_ + 1] == '=':
                __PRE_SPLIT_LIST__[_INDEX_CHAR_] = __PRE_SPLIT_LIST__[_INDEX_CHAR_] + '='
                __PRE_SPLIT_LIST__.pop(_INDEX_CHAR_ + 1)

    for index, i in enumerate(__PRE_SPLIT_LIST__):
        if '.' in i:
            # check if the dot is surrounded by numbers
            if __PRE_SPLIT_LIST__[index-1].isdigit() and __PRE_SPLIT_LIST__[index+1].isdigit():
                # if so, merge the numbers and the dot
                __PRE_SPLIT_LIST__[index-1] = __PRE_SPLIT_LIST__[index-1] + '.' + __PRE_SPLIT_LIST__[index+1]
                __PRE_SPLIT_LIST__.pop(index)
                __PRE_SPLIT_LIST__.pop(index)

    for i in __PRE_SPLIT_LIST__:
        if i.endswith('<newline>'):
            # remove the newline from the end of the line
            __TEMP_SPLIT_LIST__.append(__PRE_SPLIT_LIST__[:__PRE_SPLIT_LIST__.index(i) + 1][:-1])
            __PRE_SPLIT_LIST__ = __PRE_SPLIT_LIST__[__PRE_SPLIT_LIST__.index(i) + 1:]
            __PRE_SPLIT_LIST__ = [x.strip() for x in __PRE_SPLIT_LIST__]
            __PRE_SPLIT_LIST__ = [x for x in __PRE_SPLIT_LIST__ if x != '']

    for _INDEX_, _I_ in enumerate(__TEMP_SPLIT_LIST__):
        for _INDEX2_, _II_ in enumerate(_I_):
            if _II_.endswith('\"'):
                if _II_.startswith(__GLOBAL_VARIABLES__.__STRING_TYPES__): continue
                __TEMP_SPLIT_LIST__[_INDEX_][_INDEX2_] = 'f' + _II_


    __PRE_SPLIT_LIST__ = [x.strip() for x in __PRE_SPLIT_LIST__]
    __PRE_SPLIT_LIST__ = [x for x in __PRE_SPLIT_LIST__ if x != '']

    del __WORD__, __PRE_SPLIT_LIST__, __IN_STRING__, __IN_COMMENT__, __IN_MULTI_LINE_COMMENT__, __INDEX__, __LINES_COPY__, __TEMP_LINE__

    return __TEMP_SPLIT_LIST__
def __SPLIT_ALL_LINES__(mode=None, __DATA__=None) -> list[list]:
    """
    \n Inputs: mode, and data
    \n Outputs: List if mode is 'include', None for all other modes
    \n Splits the list of lines into a list of lists, where each list is a line.
    \n It configures the list of lists to be used in the rest of the program.
    """
    global __TOKENIZED_LIST__, __LINES__, __PRE_SPLIT_LIST__

    if mode == 'include':
        return __SPLIT_ALL_LINES_INCLUDE__(__DATA__)

    __CLOSING_PAIRS__ = {
        '(': ')',
        '[': ']',
        '{': '}',
        '\"': '\"',
    }

    __LINES__ = [x.strip() for x in __LINES__]
    __LINES__ = [x for x in __LINES__ if x != '']

    __WORD__ = ''
    __PRE_SPLIT_LIST__ = []
    __IN_STRING__ = False
    __IN_COMMENT__ = False
    __IN_MULTI_LINE_COMMENT__ = False
    __INDEX__ = 0
    __LINES_COPY__ = deepcopy(__LINES__)
    __TEMP_LINE__ = ''

    for __INDEX__, _I_ in enumerate(__LINES__):
        if _I_.startswith('/*') and __IN_MULTI_LINE_COMMENT__ is False:
            __IN_MULTI_LINE_COMMENT__ = True

        if _I_.endswith('*/') and __IN_MULTI_LINE_COMMENT__:
            __LINES__[__INDEX__] = ''
            __IN_MULTI_LINE_COMMENT__ = False

        if __IN_MULTI_LINE_COMMENT__:
            __LINES__[__INDEX__] = ''

        if _I_.startswith('//'):
            __LINES__[__INDEX__] = ''

        if _I_.startswith('#'):
            __ERROR_REPORTING__(__LINES__[__INDEX__], "usedHashtag")

    __LINES__ = [x for x in __LINES__ if x != '']
    _NEW_LINE_: str = ''

    for _INDEX_, _I_ in enumerate(__LINES__):
        if _I_.startswith('[') and _I_.endswith(']'):
            __TOKENIZED_LIST__.append([_I_])
            __LINES__.remove(_I_)
            continue
        for i in _I_:
            _NEW_LINE_ += i
            if i == '\"' and __IN_STRING__ is False:
                __IN_STRING__ = True
                continue
            if i == '\"' and __IN_STRING__:
                __IN_STRING__ = False
                continue
            if __IN_STRING__ is False:
                if i == '}':
                    _NEW_LINE_ += ';'

        __LINES__[_INDEX_] = _NEW_LINE_
        _NEW_LINE_ = ''

    for _INDEX_, _I_ in enumerate(__LINES__):
        __IN_COMMENT__ = False
        for _INDEX_CHAR_, _II_ in enumerate(_I_):
            if _II_ == '\"' and _I_[_INDEX_CHAR_ - 1] != '\\':
                if __IN_STRING__ is False:
                    __IN_STRING__ = True
                else:
                    __IN_STRING__ = False
            if _II_ == '/' and __IN_STRING__ is False:
                if _INDEX_CHAR_ + 1 < len(_I_):
                    if _I_[_INDEX_CHAR_ + 1] == '/':
                        break

            if _II_ in __GLOBAL_VARIABLES__.__NON_NORMAL_CHARS__ and __IN_STRING__ is False and __IN_COMMENT__ is False and __IN_MULTI_LINE_COMMENT__ is False:
                if __WORD__ != '':
                    __PRE_SPLIT_LIST__.append(__WORD__.replace('\\{', '{{').replace('\\}', '}}'))
                    __WORD__ = ''
                if _II_ == ';':
                    __PRE_SPLIT_LIST__.append(_II_ + '<newline>')
                else:
                    __PRE_SPLIT_LIST__.append(_II_)
            else:
                __WORD__ += _II_

        if __WORD__ != '':
            __PRE_SPLIT_LIST__.append(__WORD__.replace('\\{', '{{').replace('\\}', '}}'))
            __WORD__ = ''

    __PRE_SPLIT_LIST__ = [x.strip() for x in __PRE_SPLIT_LIST__]
    __PRE_SPLIT_LIST__ = [x for x in __PRE_SPLIT_LIST__ if x != '']

    for _INDEX_CHAR_, i in enumerate(__PRE_SPLIT_LIST__):
        if i in __CLOSING_PAIRS__.keys():
            if __PRE_SPLIT_LIST__[_INDEX_CHAR_ + 1] == __CLOSING_PAIRS__[i]:
                __PRE_SPLIT_LIST__[_INDEX_CHAR_] = i + __CLOSING_PAIRS__[i]
                __PRE_SPLIT_LIST__.pop(_INDEX_CHAR_ + 1)
        if _INDEX_CHAR_ + 1 < len(__PRE_SPLIT_LIST__):
            if __PRE_SPLIT_LIST__[_INDEX_CHAR_ + 1] == i:
                __PRE_SPLIT_LIST__[_INDEX_CHAR_] = i + i
                __PRE_SPLIT_LIST__.pop(_INDEX_CHAR_ + 1)
        # if ['<', '='] in _INDEX_CHAR_, merge them
        if _INDEX_CHAR_ + 1 < len(__PRE_SPLIT_LIST__):
            if __PRE_SPLIT_LIST__[_INDEX_CHAR_] in __GLOBAL_VARIABLES__.__OPPRATORS__ and __PRE_SPLIT_LIST__[_INDEX_CHAR_ + 1] == '=':
                __PRE_SPLIT_LIST__[_INDEX_CHAR_] = __PRE_SPLIT_LIST__[_INDEX_CHAR_] + '='
                __PRE_SPLIT_LIST__.pop(_INDEX_CHAR_ + 1)

    for index, i in enumerate(__PRE_SPLIT_LIST__):
        if '.' in i:
            # check if the dot is surrounded by numbers
            if __PRE_SPLIT_LIST__[index-1].isdigit() and __PRE_SPLIT_LIST__[index+1].isdigit():
                # if so, merge the numbers and the dot
                __PRE_SPLIT_LIST__[index-1] = __PRE_SPLIT_LIST__[index-1] + '.' + __PRE_SPLIT_LIST__[index+1]
                __PRE_SPLIT_LIST__.pop(index)
                __PRE_SPLIT_LIST__.pop(index)

    for _INDEX_, _I_ in enumerate(__PRE_SPLIT_LIST__):
        if _I_.endswith('\"') and __PRE_SPLIT_LIST__[0] != 'pyc':
            if _I_.startswith(__GLOBAL_VARIABLES__.__STRING_TYPES__): continue
            __PRE_SPLIT_LIST__[_INDEX_] = 'f' + _I_

    for i in __PRE_SPLIT_LIST__:
        if i.endswith('<newline>'):
            # remove the newline from the end of the line
            __TOKENIZED_LIST__.append(__PRE_SPLIT_LIST__[:__PRE_SPLIT_LIST__.index(i) + 1][:-1])
            __PRE_SPLIT_LIST__ = __PRE_SPLIT_LIST__[__PRE_SPLIT_LIST__.index(i) + 1:]
            __PRE_SPLIT_LIST__ = [x.strip() for x in __PRE_SPLIT_LIST__]
            __PRE_SPLIT_LIST__ = [x for x in __PRE_SPLIT_LIST__ if x != '']

    for _INDEX_, _I_ in enumerate(__TOKENIZED_LIST__):
        for _INDEX2_, _II_ in enumerate(_I_):
            if _II_.endswith('\"'):
                if _II_.startswith(__GLOBAL_VARIABLES__.__STRING_TYPES__): continue
                __TOKENIZED_LIST__[_INDEX_][_INDEX2_] = 'f' + _II_

    __PRE_SPLIT_LIST__ = [x.strip() for x in __PRE_SPLIT_LIST__]
    __PRE_SPLIT_LIST__ = [x for x in __PRE_SPLIT_LIST__ if x != '']
    del __WORD__, __PRE_SPLIT_LIST__, __IN_STRING__, __IN_COMMENT__, __IN_MULTI_LINE_COMMENT__, __INDEX__, __LINES_COPY__, __TEMP_LINE__
    if mode == 'include':
        return __TOKENIZED_LIST__
    return None
def __SPLIT_LINE__(_I_) -> list:
    """
    \n Inputs: the line to split into tokens
    \n Outputs: the split line
    \n This function splits the line into a list of words and opperators
    """
    __CLOSING_PAIRS__ = {
        '(': ')',
        '[': ']',
        '{': '}',
        '\"': '\"',
    }
    __PRE_SPLIT_LIST__ = []
    __WORD__ = ''
    __IN_STRING__ = False
    __IN_COMMENT__ = False
    __WORD__ = ''
    __PRE_SPLIT_LIST__ = []
    __IN_STRING__ = False
    __IN_COMMENT__ = False
    __IN_MULTI_LINE_COMMENT__ = False
    __INDEX__ = 0
    __LINES_COPY__ = deepcopy(__LINES__)
    __TEMP_LINE__ = ''
    __SPACES__ = -1
    for _INDEX_CHAR_, _II_ in enumerate(_I_):
        if _II_ == ' ':
            __SPACES__ += 1
        else:
            break
    if __SPACES__ == -1: __SPACES__ = 0
    for _INDEX_CHAR_, _II_ in enumerate(_I_):  # For each character in the line
        if _II_ == '\"' and _I_[_INDEX_CHAR_ - 1] != '\\':
            if __IN_STRING__ is False:
                __IN_STRING__ = True
            else:
                __IN_STRING__ = False
        if _II_ == '/' and __IN_STRING__ is False:
            if _INDEX_CHAR_ + 1 < len(_I_):
                if _I_[_INDEX_CHAR_ + 1] == '/':
                    break

        if _II_ in __GLOBAL_VARIABLES__.__NON_NORMAL_CHARS__ and __IN_STRING__ is False and __IN_COMMENT__ is False and __IN_MULTI_LINE_COMMENT__ is False:
            if __WORD__ != '':
                __PRE_SPLIT_LIST__.append(__WORD__)
                __WORD__ = ''
            if _II_ == ';':
                __PRE_SPLIT_LIST__.append(_II_ + '<newline>')
            else:
                __PRE_SPLIT_LIST__.append(_II_)
        else:
            __WORD__ += _II_

    if __WORD__ != '':
        __PRE_SPLIT_LIST__.append(__WORD__)
        __WORD__ = ''

    __PRE_SPLIT_LIST__ = [x.strip() for x in __PRE_SPLIT_LIST__]
    __PRE_SPLIT_LIST__ = [x for x in __PRE_SPLIT_LIST__ if x != '']

    for _INDEX_CHAR_, i in enumerate(__PRE_SPLIT_LIST__):
        # check if the next item is a closing pair and if it is then merge them
        if i in __CLOSING_PAIRS__.keys():
            if len(__PRE_SPLIT_LIST__) > _INDEX_CHAR_ + 1:
                if __PRE_SPLIT_LIST__[_INDEX_CHAR_ + 1] == __CLOSING_PAIRS__[i]:
                    __PRE_SPLIT_LIST__[_INDEX_CHAR_] = i + __CLOSING_PAIRS__[i]
                    __PRE_SPLIT_LIST__.pop(_INDEX_CHAR_ + 1)
        # if the next iteem is the same as the current item then merge them, but do this without raising an index error
        if _INDEX_CHAR_ + 1 < len(__PRE_SPLIT_LIST__):
            if __PRE_SPLIT_LIST__[_INDEX_CHAR_ + 1] == i:
                __PRE_SPLIT_LIST__[_INDEX_CHAR_] = i + i
                __PRE_SPLIT_LIST__.pop(_INDEX_CHAR_ + 1)
        if _INDEX_CHAR_ + 1 < len(__PRE_SPLIT_LIST__):
            if __PRE_SPLIT_LIST__[_INDEX_CHAR_] in __GLOBAL_VARIABLES__.__OPPRATORS__ and __PRE_SPLIT_LIST__[_INDEX_CHAR_ + 1] == '=':
                __PRE_SPLIT_LIST__[_INDEX_CHAR_] = __PRE_SPLIT_LIST__[_INDEX_CHAR_] + '='
                __PRE_SPLIT_LIST__.pop(_INDEX_CHAR_ + 1)
    for index, i in enumerate(__PRE_SPLIT_LIST__):
        if '.' in i:
            # check if the dot is surrounded by numbers
            if __PRE_SPLIT_LIST__[index-1].isdigit() and __PRE_SPLIT_LIST__[index+1].isdigit():
                # if so, merge the numbers and the dot
                __PRE_SPLIT_LIST__[index-1] = __PRE_SPLIT_LIST__[index-1] + '.' + __PRE_SPLIT_LIST__[index+1]
                __PRE_SPLIT_LIST__.pop(index)
                __PRE_SPLIT_LIST__.pop(index)
    __PRE_SPLIT_LIST__ = [x.strip() for x in __PRE_SPLIT_LIST__]
    __PRE_SPLIT_LIST__ = [x for x in __PRE_SPLIT_LIST__ if x != '']
    __PRE_SPLIT_LIST__.insert(0, ' ' * (__SPACES__)) # THIS WAS THE PROBLEM <-------------------------------------------------------------

    return __PRE_SPLIT_LIST__[1:]

# ----------------- Versace Internal Functions ----------------- #
    # ------------------------- Setters ------------------------ #
@ASYNC
def __ASSIGN_VARIABLE__(__VARIABLE_NAME__, __VARIABLE_TYPE__, __VARIABLE_VALUE__) -> None:
    """
    \n Inputs: the variable name and the variable value
    \n Outputs: None
    \n This function assigns the variable name to the variable value and saves it to the variable dictionary
    """
    global __VARIABLES__
    __VARIABLES__[__VARIABLE_NAME__] = {
        'type': __VARIABLE_TYPE__,
        'value': __VARIABLE_VALUE__
    }
    return
@ASYNC
def __ASSIGN_FUNCTION__(__FUNCTION_NAME__, __FUNCTION_TYPE__, __FUNCTION_VALUE__) -> None:
    """
    \n Inputs: the function name and the function value
    \n Outputs: None
    \n This function assigns the function name to the function value and saves it to the function dictionary
    """
    global __FUNCTIONS__
    __FUNCTIONS__[__FUNCTION_NAME__] = {
        'type': __FUNCTION_TYPE__,
        'value': __FUNCTION_VALUE__
    }
    return
@ASYNC
def __ASSIGN_CLASS__(__CLASS_NAME__, __CLASS_TYPE__) -> None:
    """
    \n Inputs: the class name and the class value
    \n Outputs: None
    \n This function assigns the class name to the class value and saves it to the class dictionary
    """
    global __CLASSES__
    __CLASSES__[__CLASS_NAME__] = __CLASS_TYPE__
    return
    # ------------------------- Getters ------------------------ #
def __GET_VARIABLE__(__VARIABLE_NAME__, __TYPE__: int) -> str:
    """
    \n Inputs: the variable name and type (0 = value, 1 = type, 3 = both)
    \n Outputs: the variable value
    \n This function gets the variable value from the variable dictionary
    """
    global __VARIABLES__
    if __TYPE__ == 0:
        return __VARIABLES__[__VARIABLE_NAME__]['value']
    elif __TYPE__ == 1:
        return __VARIABLES__[__VARIABLE_NAME__]['type']
    else:
        return __VARIABLES__[__VARIABLE_NAME__]
def __GET_CLASS__(__CLASS_NAME__) -> str:
    """
    \n Inputs: the class name
    \n Outputs: the class value
    \n This function gets the class value from the class dictionary
    """
    global __CLASSES__
    return __CLASSES__[__CLASS_NAME__]
def __GET_FUNCTION__(__FUNCTION_NAME__, __TYPE__: int) -> str:
    """
    \n Inputs: the function name and type (0 = value, 1 = type, 2 = full line, other = all)
    \n Outputs: the function value
    \n This function gets the function value from the function dictionary
    """
    global __FUNCTIONS__
    if __TYPE__ == 0:
        return __FUNCTIONS__[__FUNCTION_NAME__]['value']
    elif __TYPE__ == 1:
        return __FUNCTIONS__[__FUNCTION_NAME__]['type']
    elif __TYPE__ == 2:
        for i in __FUNCTIONS__:
            if __FUNCTION_NAME__ == (str(i) + ' ' + str(__FUNCTIONS__[i]['value'])):
                print('found')
                return str(i) + ' ' + str(__FUNCTIONS__[i]['value'])
    else:
        return __FUNCTIONS__[__FUNCTION_NAME__]
    # ------------------------- Checkers ----------------------- #
def __CHECK_IF_DELARED__(__ITEM__, __LINE__, __TYPE__=None, ERROR='notFoundError') -> bool:
    """ This function checks if the item is declared.

    Args:
        __ITEM__ (str): The item to check if declared.
        __LINE__ (str): The full line.
        __TYPE__ (int, optional): The type of item. Defaults to None (1 = Private, 2 = Static Enum)
    """
    if __TYPE__ is None:
        __FOUND__: bool = False
        __FOUND__ = True if [__I__ for __I__ in __FUNCTIONS__ if __I__ in __ITEM__] else __FOUND__
        __FOUND__ = True if [__I__ for __I__ in __CLASSES__ if __I__ in __ITEM__] else __FOUND__
        __FOUND__ = True if [__I__ for __I__ in __VARIABLES__ if __I__ in __ITEM__] else __FOUND__
        if __FOUND__ is False:
            if __ITEM__ not in __GLOBAL_VARIABLES__.__RESERVED_WORDS__: __ERROR_REPORTING__(__LINE__, ERROR, __ITEM__); return False
            else: __FOUND__ = True
        return __FOUND__
    elif __TYPE__ == 11:
        __FOUND__: bool = False
        __FOUND__ = True if [__I__ for __I__ in __FUNCTIONS__ if __I__ in __ITEM__] else __FOUND__
        __FOUND__ = True if [__I__ for __I__ in __CLASSES__ if __I__ in __ITEM__] else __FOUND__
        if __FOUND__ is False:
            if __ITEM__ not in __GLOBAL_VARIABLES__.__RESERVED_WORDS__: __ERROR_REPORTING__(__LINE__, ERROR, __ITEM__); return False
            else: __FOUND__ = True
        return __FOUND__
    elif __TYPE__ == 1:
        # check if the given item is a private function or class
        __FOUND__: bool = False
        if __ITEM__.startswith('__'): return False
        __FOUND__ = True if [__I__ for __I__ in __FUNCTIONS__ if __FUNCTIONS__[__I__]['type'] == 'PRIVATE' and __I__.replace('__', '') == __ITEM__.replace('__', '')] else __FOUND__; __FOUND__ = True if [__I__ for __I__ in __CLASSES__ if __CLASSES__[__I__] == 'PRIVATE' and __I__.replace('__', '') in __ITEM__.replace('__', '')] else __FOUND__; __FOUND__ = True if [__I__ for __I__ in __VARIABLES__ if __VARIABLES__[__I__]['type'] == 'PRIVATE' and __I__.replace('__', '') in __ITEM__.replace('__', '')] else __FOUND__
        #for __I__ in __FUNCTIONS__:
        #    if __FUNCTIONS__[__I__]['type'] == 'PRIVATE':
        #        if __I__.replace('__', '') == __ITEM__.replace('__', ''):
        #            __FOUND__ = True
        #            break

        #for __I__ in __CLASSES__:
        #    if __CLASSES__[__I__] == 'PRIVATE':
        #        if __I__.replace('__', '') in __ITEM__.replace('__', ''):
        #            __FOUND__ = True
        #            break

        #for __I__ in __VARIABLES__:
        #    if __VARIABLES__[__I__]['type'] == 'PRIVATE':
        #        if __I__.replace('__', '') == __ITEM__.replace('__', ''):
        #            __FOUND__ = True
        #            break
        return __FOUND__
    elif __TYPE__ == 2:
        __FOUND__: bool = False
        if __ITEM__.endswith('()'): return False
        __FOUND__ = True if [__I__ for __I__ in __FUNCTIONS__ if __FUNCTIONS__[__I__]['type'] == 'STAIC ENUM' and __I__.replace('()', '') == __ITEM__.replace('()', '')] else __FOUND__
        #for __I__ in __CLASSES__:
        #    if __CLASSES__[__I__] == 'STAIC ENUM':
        #        if __I__.replace('()', '') in __ITEM__.replace('()', ''):
        #            __FOUND__ = True
        #            break
        return __FOUND__
    # ----------------------- Misslanous ----------------------- #

# ------------------- Error Reporting ------------------- #
def __ERROR_REPORTING__(TOKENIZED_LINE: str,
                        ERROR_CODE: str,
                        OPTIONAL_1: str = '',
                        OPTIONAL_2: str = '',
                        OPTIONAL_3: str = '',
                        LINE_NO=None,
                        FILE_NAME=None,
                        DEBUG_LINE=None,
                        DEBUG_FILE=None ) -> None:
    """
    This function reports errors.
    It is used to generate error messages and report them to the user.

    Example:
        | Error in Line 5 : int a = 10.65;
        | ╰───────────────> ^^^       ^
        | Declared an integer var, got a float instead.

    Args:
        __LINE__ (str): The line that caused the error.
        __ERROR__ (str): The error type.
        __OPTIONAL__ (str, optional).
        __OPTIONAL2__ (str, optional).
        __OPTIONAL3__ (str, optional).
        LINE_NO (_type_, optional): Line number. Optional, as it can be automatically detected.
        FILE_NAME (_type_, optional): File name. Optional, as it can be automatically detected.

    Returns:
        _type_: _description_
    """
    
    EMOJI_FOUND = False
    for I in TOKENIZED_LINE:
        if 'UnicodeEmojis_' in I:
            __UNICODE__ = I
            EMOJI_FOUND = True
            # q: EMOJI_UNICODE is a dict that looks like {'😀' : 'UnicodeEmojis_2', ... }, how do you get the key from the value?
            # a: https://stackoverflow.com/questions/8023306/get-key-by-value-in-dictionary
            TOKENIZED_LINE[TOKENIZED_LINE.index(I)] = TOKENIZED_LINE[TOKENIZED_LINE.index(I)].replace(__UNICODE__, list(EMOJI_UNICODE.keys())[list(EMOJI_UNICODE.values()).index(__UNICODE__)])
        if '<INDENTATIONSEP>' == I: TOKENIZED_LINE[TOKENIZED_LINE.index(I)] = '{'
        if '<DEDENTATIONSEP>' == I: TOKENIZED_LINE[TOKENIZED_LINE.index(I)] = '}'
    
    if EMOJI_FOUND: del __UNICODE__
    del EMOJI_FOUND, I
    org_args_passed = locals()
    
    __LINE__ = TOKENIZED_LINE
    __ERROR__ = ERROR_CODE
    __OPTIONAL__ = OPTIONAL_1
    __OPTIONAL2__ = OPTIONAL_2
    __OPTIONAL3__ = OPTIONAL_3
    
    if isinstance(__LINE__, str):
        __LINE__ = __SPLIT_LINE__(__LINE__) if 'UnicodeEmojis_' in __LINE__ else __LINE__
    __ALL_ERRORS_VERSACE_CODE_BASE__: set[str] = ('InvalidKeyword', 'InvalidCopySyntax', 'CanNotFixSize', 'TriedOverloadingGlobalOperator', 'ConstCallOutsideGlobal', 'IlligalCharacter', 'InvalidEnumType', 'CyclicIncludeError', 'notFoundError', 'VariableNotDeclared', 'AssignedValueToUndefined', 'FromStatement', 'InvalidNumberOfVariablesToValues', 'TriedToAssignValueToMultipleVariables' , 'AddedDataTypesToPrivClass', 'AddedArgumentsToPublic', 'outCalledError', 'AsyncAndPrivate', 'dotUsed', 'usedHashtag', 'InvalidDelimeter', 'NeverClosed', 'unclosedComment', 'MissingSemiColon', 'AssignmentInPrivate', 'InvalidDataType', 'InvalidTypeOfValue', 'NullTypeFunction', 'TriedToAssignValueToDataClass', 'BadConfigData', 'FileNotFound', 'InvalidRefrence', 'NoMain', 'badStaticForLoop', 'badDynTask', 'UsedAsyncAndMethod', 'InvalidDynamicTask', 'InvalidValue')
    global __OPTIANAL_ARGS_IN_FILE__, __FILE_PATH__,__FINAL_LIST__, __LINES_FROM_FILE_RAW__, __ERROR_REPORTING_CALLED__
    console("")
    if __IN_INTREPRETED_MODE__: LINE_NO="Previous Statement"
    __LINE_LIST__: list = __LINE__.copy() if type(__LINE__) == list else __SPLIT_LINE__(__LINE__)
    if type(__LINE__) == list:
        __LINE__ = ' '.join(__LINE__)
    __LINE__ = __LINE__.replace('<INDENTATIONSEP>', '{').replace('<DEDENTATIONSEP>', '}')
    if __ERROR__ not in __ALL_ERRORS_VERSACE_CODE_BASE__:
        __OLD_LINE__ = __LINE__
        for i in tuple(__GLOBAL_VARIABLES__.__PYTHON_TO_VERSACE__.keys()):
            __LINE__ = __LINE__.replace(i, __GLOBAL_VARIABLES__.__PYTHON_TO_VERSACE__[i])
        __OPTIONAL__ = ' '*(len(__LINE__)-len(__OLD_LINE__)) + __OPTIONAL__

    if __LINE__.endswith(';') == False:
        if __LINE__.endswith(('{', '}', '(', ')', '[', ']', ',')) == False:
            __LINE__ += ';'
    if FILE_NAME is None: FILE_NAME = path.basename(__FILE_PATH__)
    else: FILE_NAME = path.basename(FILE_NAME)
    __LINE__NUMBER__: int = __GET_LINE_NUMBER__(__LINE__) if LINE_NO is None else LINE_NO
    __LINE__ = __LINES_FROM_FILE_RAW__[__LINE__NUMBER__-1][:-1] if __LINE__NUMBER__ is not None else __LINE__
    SPACE_CHAR: str = ' '
    __ERROR_MAP__: MappingProxyType[str, str] = _MAP_(
        {
            #Complex Error Code                     |    Simplified Error Code
            'InvalidValue'                          :    'VariableError',       ###
            'notFoundError'                         :    'VariableError',       ###
            'VariableNotDeclared'                   :    'VariableError',       ###
            'AssignedValueToUndefined'              :    'VariableError',       ###
            'CanNotFixSize'                         :    'VariableError',       ###
            'ConstCallOutsideGlobal'                :    'VariableError',       ###
            'FromStatement'                         :    'SyntaxError',         ###
            'InvalidNumberOfVariablesToValues'      :    'SyntaxError',         ###
            'TriedToAssignValueToMultipleVariables' :    'SyntaxError',         ###
            'AddedDataTypesToPrivClass'             :    'SyntaxError',         ###
            'AddedArgumentsToPublic'                :    'SyntaxError',         ###
            'outCalledError'                        :    'SyntaxError',         ###
            'AsyncAndPrivate'                       :    'SyntaxError',         ###
            'dotUsed'                               :    'SyntaxError',         ###
            'IlligalCharacter'                      :    'SyntaxError',         ###
            'TriedOverloadingGlobalOperator'        :    'SyntaxError',         ###
            'InvalidKeyword'                        :    'SyntaxError',         ###
            'usedHashtag'                           :    'SyntaxError',         ###
            'InvalidEnumType'                       :    'SyntaxError',         ###
            'InvalidDelimeter'                      :    'SyntaxError',         ###
            'badStaticForLoop'                      :    'SyntaxError',         ###
            'badDynTask'                            :    'SyntaxError',         ###
            'UsedAsyncAndMethod'                    :    'SyntaxError',         ###
            'NeverClosed'                           :    'CloseError',          ###
            'unclosedComment'                       :    'CloseError',          ###
            'MissingSemiColon'                      :    'CloseError',          ###
            'AssignmentInPrivate'                   :    'TypeError',           ###
            'InvalidDataType'                       :    'TypeError',           ###
            'InvalidTypeOfValue'                    :    'TypeError',           ###
            'NullTypeFunction'                      :    'TypeError',           ###
            'TriedToAssignValueToDataClass'         :    'DataError',           ###
            'BadConfigData'                         :    'DataError',           ###
            'FileNotFound'                          :    'FileNotFoundError',   ###
            'InvalidRefrence'                       :    'RefrenceError',       ###
            'InvalidDynamicTask'                    :    'RefrenceError',       ###
            'NoMain'                                :    'NoMainError',         ###
            'CyclicIncludeError'                    :    'IncludeError',        ###
            'InvalidCopySyntax'                     :    'SyntaxError',         ###
        }
    )
    __ALL_ERRORS__: set[str] = (
        'VariableError',
        'SyntaxError',
        'CloseError',
        'TypeError',
        'DataError',
        'FileNotFoundError',
        'RefrenceError',
        'NoInitError',
        'IncludeError',
    )
    __DATA_TYPE_FULL__: MappingProxyType[str, str] = _MAP_(
        {
            'int'        : 'Integer',
            'float'      : 'Float',
            'str'        : 'String',
            'bool'       : 'Boolean',
            'list'       : 'List',
            'tuple'      : 'Tuple',
            'map'        : 'Map',
            'set'        : 'Set',
            'null'       : 'Null',
            'none'       : 'None',
            'complex'    : 'Complex',
            'i8'         : 'Integer 8-bit',
            'i16'        : 'Integer 16-bit',
            'i32'        : 'Integer 32-bit',
            'i64'        : 'Integer 64-bit',
            'i128'       : 'Integer 128-bit',
            'u8'         : 'Unsigned Integer 8-bit',
            'u16'        : 'Unsigned Integer 16-bit',
            'u32'        : 'Unsigned Integer 32-bit',
            'u64'        : 'Unsigned Integer 64-bit',
            'u128'       : 'Unsigned Integer 128-bit',
            'f32'        : 'Float 32-bit',
            'f64'        : 'Float 64-bit',
            'array'      : 'Array',
            'arr '       : 'Array',
            'double'     : 'Double',
            'usize'      : 'Unknown Object',
            'bytes'      : 'Bytes',
            'char'       : 'Character',
            'memoryview' : 'Memory View',
            'bytearray'  : 'Byte Array',
            'frozenset'  : 'Frozen Set',
            'range'      : 'Range',
            'nullType'   : 'Null Type',
        }
    )
    def mark_chars(__LINE__, LOOK_FOR, BOTTOM_LINE):
        __IN_STRING__: bool = False
        __COUNT__: int = 0
        MARKED_LINE: str = ''
        for i in BOTTOM_LINE:
            if '^' in i:
                __COUNT__ += 1
        for index, char in enumerate(__LINE__):
            if char == '\"' and __LINE__[index-1] != '\\':
                if LOOK_FOR == '\"':
                    if __IN_STRING__ : MARKED_LINE = MARKED_LINE[:-1] + '^'
                    else: MARKED_LINE += '^'
                __IN_STRING__ = __LATCH__(__IN_STRING__)
            if char == LOOK_FOR and __IN_STRING__ is False:
                if LOOK_FOR == '\"': continue
                MARKED_LINE += '^'
            else:
                if __COUNT__ != 0 and __IN_STRING__ is False:
                    __COUNT__ -= 1
                else: MARKED_LINE += SPACE_CHAR
        return BOTTOM_LINE + MARKED_LINE
    def mark_words(__LINE_LIST__, WORD, BOTTOM_LINE):
        if isinstance(WORD, str) != True:
            for word in WORD:
                for i in __LINE_LIST__:
                    if word == i:
                        BOTTOM_LINE += '^'*len(i)
                        break
                    else:
                        BOTTOM_LINE += SPACE_CHAR*(len(i)+1)
        else:
            # get words from line
            LINE = ' '.join(__LINE_LIST__)
            __NEW_LINE__: list[str] = LINE.split()
            for i in __NEW_LINE__:
                if WORD == i:
                    BOTTOM_LINE += '^'*len(i)
                    break
                else:
                    BOTTOM_LINE += SPACE_CHAR*(len(i)+1)
        return BOTTOM_LINE
    __STRAIGHT_HORIZONTAL_LINE__ = '\u2500'
    # get 5 line before the error line from __LINES_FROM_FILE_RAW__
    __LINE_BEFORE__: list[str] = []
    for i in reversed(__LINES_FROM_FILE_RAW__[:__LINE__NUMBER__-1]):
        # remove the new line character at the end and keep the line spacing in the start
        __LINE_BEFORE__.append(i[:-1])
        if len(__LINE_BEFORE__) == __TRACEBACK_LIMIT__: break
    # count the white space in the start of the line
    __WHITESPACE__: int = 0
    __WHITESPACE_TYPE__: str = ''
    from string import whitespace
    for i in __LINE__: 
        if i in whitespace: __WHITESPACE__ += 1; __WHITESPACE_TYPE__ = i
        else: break
    
    """
    Full Traceback:
    Reported Traceback in File "U:\Versace-With-Fixes\testing\Versace\duc.v", line 32
        SyntaxError:
        │   28      usize obj_ind = India();
        │   29      usize obj_usa = Usa();
        │   30
        │   31      public main() {
        │ ❱ 32      usssize countrys = ( obj_ind | obj_usa )
        ╰─────────> ^^^^^^^
    Invalid Keyword 'usssize' was used, did you mean 'usize'?
    """
    
    __LINE_BEFORE__.insert(0, __LINE__)
    TOP_LINE = f"{__COLORS__['red']}Reported Traceback in File \"{__FILE_PATH__}\", line {__LINE__NUMBER__}{__COLORS__['reset']}"
    MIDDLE_LINE = f"{__COLORS__['red']}    {__ERROR_MAP__.get(__ERROR__)}: {__COLORS__['yellow']}"
    MIDDLE_LINE_LEN = len(f'{__ERROR_MAP__.get(__ERROR__)}') - 1
    __LINE_BEFORE__ = __LINE_BEFORE__[::-1]
    __IN_COMMENT__: bool = False
    __IN_STRING__: bool = False
    if __LINE_BEFORE__[0].strip() == '': __LINE_BEFORE__.pop(0)
    if __LINE_BEFORE__[-1].strip() == '': __LINE_BEFORE__.pop(-1)
    __LINE__NUMBER__ -= len(__LINE_BEFORE__)
    __LINE_BEFORE_NO__: int = 0
    console("")
    if __ERROR__ not in __ALL_ERRORS_VERSACE_CODE_BASE__: MIDDLE_LINE = ''
    for i in __LINE_BEFORE__: 
        __LINE__NUMBER__ += 1
        __LINE_BEFORE_NO__ = __LINE_BEFORE__.index(i)
        if i.startswith('//'): i = f"{__COLORS__['grey']}{i}{__COLORS__['reset']}"
        if i.startswith('/*') and not __IN_COMMENT__: i = f"{__COLORS__['grey']}{i}{__COLORS__['reset']}"; __IN_COMMENT__ = True
        if i.endswith('*/') and __IN_COMMENT__: i = f"{__COLORS__['grey']}{i}{__COLORS__['reset']}"; __IN_COMMENT__ = False
        for index, ii in enumerate(i):
            if ii == '"' and i[index-1] + i != r'\"': 
                __IN_STRING__ = not __IN_STRING__
                # highlight the string green
            if not __IN_STRING__:
                if len(i) > index+1:
                    if ii == '/' and i[index+1] == '/': 
                        i = f"{i[:index]}{__COLORS__['grey']}{i[index:]}"
                        break
        if __IN_COMMENT__: i = f"{__COLORS__['grey']}{i}{__COLORS__['reset']}"
        if __ERROR__ not in __ALL_ERRORS_VERSACE_CODE_BASE__:
            if __LINE_BEFORE_NO__ == len(__LINE_BEFORE__)-1: MIDDLE_LINE += f"\n    {__COLORS__['red']}\u2502    ❱ {__COLORS__['white']}{__LINE__NUMBER__:<2}{__COLORS__['yellow']}{i}{__COLORS__['reset']}"; break
            MIDDLE_LINE += f"\n    {__COLORS__['red']}\u2502      {__COLORS__['grey']}{__LINE__NUMBER__:<2}{__COLORS__['yellow']}{i}{__COLORS__['reset']}"
        else:
            if __LINE_BEFORE_NO__ == len(__LINE_BEFORE__)-1: MIDDLE_LINE += f"\n    {__COLORS__['red']}\u2502    ❱ {__COLORS__['white']}{__LINE__NUMBER__:<6}{__COLORS__['yellow']}{i}{__COLORS__['reset']}"; break
            MIDDLE_LINE += f"\n    {__COLORS__['red']}\u2502      {__COLORS__['grey']}{__LINE__NUMBER__:<6}{__COLORS__['yellow']}{i}{__COLORS__['reset']}"
    if __ERROR__ not in __ALL_ERRORS_VERSACE_CODE_BASE__: MIDDLE_LINE = f"{__COLORS__['red']}    {__OPTIONAL2__}{__COLORS__['yellow']}{MIDDLE_LINE}{__COLORS__['reset']}"; MIDDLE_LINE_LEN = len(__OPTIONAL2__) - 2
    BOTTOM_LINE = f"{__COLORS__['red']}    \u2570{__STRAIGHT_HORIZONTAL_LINE__*(MIDDLE_LINE_LEN)}>   {__WHITESPACE_TYPE__*(__WHITESPACE__)}"
    if __ERROR_REPORTING_CALLED__ is False and '-*- all errors -*-' in __OPTIANAL_ARGS_IN_FILE__: print(f"{__COLORS__['bold red']}Full Traceback:{__COLORS__['reset']}")
    __ERROR_REPORTING_CALLED__ = True
    print("")
    
    #[print(f"{__COLORS__['red']}\u2502   {__COLORS__['yellow']}{i}{__COLORS__['reset']}") for i in __LINE_BEFORE__ if i != '']
    print(f"{TOP_LINE}")
    __LINE__ = __LINE__.strip()
    if __ERROR__ == "NoMain":
        UnhandledException("No main function found in the file.\n\tNOTE: if you want to run a file without a main function, add \"[-*- no main -*-]\" to the top of the file")
    elif __ERROR__ == "NeverClosed":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE[:-2]}{'^'*len(__LINE__)}")
        print(f"{__COLORS__['red']}Never closed.{__COLORS__['red']}")
    elif __ERROR__ == "InvalidDelimeter":
        BOTTOM_LINE = mark_chars(__LINE__, "'", BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Versace does not support the (\') delimeter, use only (\"){__COLORS__['reset']}")
    elif __ERROR__ == "MissingSemiColon":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{SPACE_CHAR*len(__LINE__)}^")
        print(f"{__COLORS__['red']}Missing semi-colon {__COLORS__['yellow']}(;){__COLORS__['red']} at the end of the line (This error was picked up because the [-*- no newline -*-] argument was found in file){__COLORS__['reset']}")
    elif __ERROR__ == "InvalidTypeOfValue":
        BOTTOM_LINE += '^'*len(__LINE_LIST__[0])
        # example : int somefloat = 1.0;
        # mark    : ^^^             ^^^
        __FOUND__: bool = False
        __COUNT__: int = 0
        for i in BOTTOM_LINE:
            if i == '^': __COUNT__ += 1
        for i in __LINE__:
            if i == '=': __FOUND__ = True; BOTTOM_LINE += SPACE_CHAR; continue
            if __FOUND__ :
                if i == ' ': BOTTOM_LINE += SPACE_CHAR; continue
                if i == ',': BOTTOM_LINE += SPACE_CHAR; continue
                if i == ';': break
                BOTTOM_LINE += '^'
            else:
                if __COUNT__ != 0: __COUNT__ -= 1
                else: BOTTOM_LINE += SPACE_CHAR
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        if 'Unsigned' not in __OPTIONAL2__: print(f"{__COLORS__['red']}Expected {__COLORS__['bold yellow']}{__DATA_TYPE_FULL__.get(__OPTIONAL2__)}{__COLORS__['reset']}{__COLORS__['red']} value, but got {__COLORS__['bold yellow']}{__DATA_TYPE_FULL__.get(__OPTIONAL__)}{__COLORS__['reset']}{__COLORS__['red']} value instead{__COLORS__['reset']}")
        else:
            if __OPTIONAL3__ is not None: __OPTIONAL2__ = __DATA_TYPE_FULL__.get(__OPTIONAL3__)
            print(f"{__COLORS__['red']}Expected {__COLORS__['bold yellow']}{__DATA_TYPE_FULL__.get(__OPTIONAL__)}{__COLORS__['reset']}{__COLORS__['red']}, but got {__COLORS__['bold yellow']}{__OPTIONAL2__}{__COLORS__['reset']}{__COLORS__['red']} value instead. A value must NOT be provided if using an unsigned binary integer.{__COLORS__['reset']}")
    elif __ERROR__ == "dotUsed":
        BOTTOM_LINE = mark_chars(__LINE__, '.', BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Versace does not support the (.) operator for class/function sub-object calls, use (::) instead{__COLORS__['reset']}")
    elif __ERROR__ == "InvalidValue":
        if 'Must' in __OPTIONAL2__:
            __KERNAL__: MappingProxyType = MappingProxyType(
                {
                    '127' : 'i8',
                    '32767' : 'i16',
                    '2147483647' : 'i32',
                    '9223372036854775807' : 'i64',
                    '170141183460469231731687303715884105727' : 'i128',
                    '3.4028234663852886e+38' : 'f32',
                    '1.7976931348623157e+308' : 'f64',
                }
            )
            TYPE: str = __KERNAL__.get(__OPTIONAL2__.split(' ')[-1])
            BOTTOM_LINE += '^'*len(__LINE_LIST__[0])
            # example : int somefloat = 1.0;
            # mark    : ^^^             ^^^
            __FOUND__: bool = False
            __COUNT__: int = 0
            for i in BOTTOM_LINE:
                if i == '^': __COUNT__ += 1
            for i in __LINE__:
                if i == '=': __FOUND__ = True; BOTTOM_LINE += SPACE_CHAR; continue
                if __FOUND__ :
                    if i == ' ': BOTTOM_LINE += SPACE_CHAR; continue
                    if i == ',': BOTTOM_LINE += SPACE_CHAR; continue
                    if i == ';': break
                    BOTTOM_LINE += '^'
                else:
                    if __COUNT__ != 0: __COUNT__ -= 1
                    else: BOTTOM_LINE += SPACE_CHAR
            print(f"{MIDDLE_LINE}")
            print(f"{BOTTOM_LINE}")
            print(f"{__COLORS__['red']}{__DATA_TYPE_FULL__.get(TYPE)} {__OPTIONAL2__}, got {__OPTIONAL__} instead.{__COLORS__['reset']}")
    elif __ERROR__ == "notFoundError":
        BOTTOM_LINE = mark_words(__LINE_LIST__, __OPTIONAL__, BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Variable {__COLORS__['bold yellow']}{__OPTIONAL__}{__COLORS__['reset']}{__COLORS__['red']} was not Found{__COLORS__['reset']}")
    elif __ERROR__ == "VariableNotDeclared":
        BOTTOM_LINE = mark_words(__LINE_LIST__, __OPTIONAL__, BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Variable {__COLORS__['bold yellow']}{__OPTIONAL__}{__COLORS__['reset']}{__COLORS__['red']} was not declared{__COLORS__['reset']}")
    elif __ERROR__ == "AssignedValueToUndefined":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Cannot assign value to undefined variable{__COLORS__['reset']}")
    elif __ERROR__ == "FromStatement":
        BOTTOM_LINE = mark_words(__LINE_LIST__, "from", BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Cannot import from statement{__COLORS__['reset']}")
    elif __ERROR__ == "InvalidNumberOfVariablesToValues":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE[:-2]}{'^'*len(__LINE__)}")
        print(f"{__COLORS__['red']}Invalid number of variables to values or vice versa use the ({__COLORS__['yellow']}|{__COLORS__['red']}) operator to separate values passed to a function during variable declaration{__COLORS__['reset']}")
    elif __ERROR__ == "TriedToAssignValueToMultipleVariables":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE[:-2]}{'^'*len(__LINE__)}")
        print(f"{__COLORS__['red']}Cannot assign value to multiple variables{__COLORS__['reset']}")
    elif __ERROR__ == "AddedDataTypesToPrivClass":
        BOTTOM_LINE = mark_words(__LINE_LIST__, (__DATA_TYPE_TOKENS__.keys()), BOTTOM_LINE).strip()
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Cannot add data types to private class{__COLORS__['reset']}")
    elif __ERROR__ == "AddedArgumentsToPublic":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*(len(__LINE__) - 2)}")
        print(f"{__COLORS__['red']}Cannot add arguments to public class{__COLORS__['reset']}")
    elif __ERROR__ == "outCalledError":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE.strip()}{__WHITESPACE_TYPE__*__WHITESPACE__} {'^'*len(__LINE_LIST__[0])}")
        print(f"{__COLORS__['red']}Called out more than once{__COLORS__['reset']}")
    elif __ERROR__ == "AsyncAndPrivate":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{' '*len(__LINE_LIST__[0])} {'^'*len(__LINE_LIST__[1])}")
        print(f"{__COLORS__['red']}Cannot use private and async together{__COLORS__['reset']}")
    elif __ERROR__ == "usedHashtag":
        BOTTOM_LINE = mark_chars(__LINE__, '#', BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Cannot use # in code{__COLORS__['reset']}")
    elif __ERROR__ == "badStaticForLoop":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE[:-2]}{'^'*len(__LINE__)}")
        print(f"{__COLORS__['red']}Invalid for loop{__COLORS__['reset']}")
    elif __ERROR__ == "badDynTask":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE[:-2]}{'^'*len(__LINE__)}")
        print(f"{__COLORS__['red']}Invalid dynamic task{__COLORS__['reset']}")
    elif __ERROR__ == "UsedAsyncAndMethod":
        BOTTOM_LINE = mark_words(__LINE_LIST__, "async", BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Cannot use async and method together{__COLORS__['reset']}")
    elif __ERROR__ == "unclosedComment":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE[:-2]}{'^'*len(__LINE__)}")
        print(f"{__COLORS__['red']}Unclosed comment{__COLORS__['reset']}")
    elif __ERROR__ == "AssignmentInPrivate":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE[:-2]}{'^'*len(__LINE__)}")
        print(f"{__COLORS__['red']}Cannot assign value in private{__COLORS__['reset']}")
    elif __ERROR__ == "InvalidDataType":
        BOTTOM_LINE = mark_words(__LINE_LIST__, __LINE_LIST__[0], BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Unknown data type provided {__COLORS__['yellow']}\"{__LINE_LIST__[0]}\"{__COLORS__['reset']}")
    elif __ERROR__ == "NullTypeFunction":
        BOTTOM_LINE = mark_words(__LINE_LIST__, __LINE_LIST__[0], BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Cannot use null type as function{__COLORS__['reset']}")
    elif __ERROR__ == "TriedToAssignValueToDataClass":
        BOTTOM_LINE = mark_chars(__LINE__, '=', BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Cannot assign value to structure{__COLORS__['reset']}")
    elif __ERROR__ == "BadConfigData":
        print(f"{MIDDLE_LINE.split('#')[0].strip()}")
        print(f"{BOTTOM_LINE}{'^'*len(__LINE__.split('#')[0].strip())}")
        print(f"{__COLORS__['red']}Invalid config data entered, {__OPTIONAL__}.{__COLORS__['reset']}")
    elif __ERROR__ == "FileNotFound":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE[:-2]}{'^'*len(__LINE__)}")
        print(f"{__COLORS__['red']}File not found{__COLORS__['reset']}")
    elif __ERROR__ == "InvalidRefrence":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}    {'^'*len(__LINE__[4:])}")
        print(f"{__COLORS__['red']}Invalid refrence{__COLORS__['reset']}")
    elif __ERROR__ == "InvalidDynamicTask":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}          {'^'*len(__LINE__[10:])}")
        print(f"{__COLORS__['red']}Invalid dynamic task{__COLORS__['reset']}")
    elif __ERROR__ == "TriedToAssignValueToFinal":
        BOTTOM_LINE = mark_chars(__LINE__, '=', BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Cannot assign a value when setting it to final{__COLORS__['reset']}")
    elif __ERROR__ == 'Used<Error':
        BOTTOM_LINE = mark_chars(__LINE__, '<', BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Cannot use (<), This Version of Versace expects (<<){__COLORS__['reset']}")
    elif __ERROR__ == "InvalidKeyword":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE.strip()}{__WHITESPACE_TYPE__*__WHITESPACE__} {'^'*len(__LINE_LIST__[0])}")
        # check what the keyword is most likely to be and suggest it
        from difflib import get_close_matches
        # __CLASSES__, __VARIABLES__, __FUNCTIONS__
        __KEYWORDS__ = list(__TOKENS__.keys()) + list(__GLOBAL_VARIABLES__.__ALL_PYTHON_KEYWORDS__) + list(__CLASSES__.keys())
        __SUGGESTED_KEYWORD__ = get_close_matches(__LINE_LIST__[0], __KEYWORDS__, n=1)
        __PRINT_LINE__ = f", {__COLORS__['red']}if you meant to assin a value to a declared variable, use {__COLORS__['green']}'let'{__COLORS__['red']} instead.{__COLORS__['reset']}"
        if __SUGGESTED_KEYWORD__:
            if __LINE_LIST__[0] in ('tuple', 'dict'):
                if __LINE_LIST__[0] == 'tuple':
                    __SUGGESTED_KEYWORD__ = ['array']
                elif __LINE_LIST__[0] == 'dict':
                    __SUGGESTED_KEYWORD__ = ['map']
            __PRINT_LINE__ = f"{__COLORS__['red']}, did you mean {__COLORS__['yellow']}'{__COLORS__['underline']}{__SUGGESTED_KEYWORD__[0]}{__COLORS__['reset']}{__COLORS__['yellow']}'{__COLORS__['red']}?{__COLORS__['reset']}"
        print(f"{__COLORS__['red']}Invalid Keyword {__COLORS__['yellow']}'{__LINE_LIST__[0]}'{__COLORS__['reset']}{__COLORS__['red']} was used{__PRINT_LINE__}")
    elif __ERROR__ == "badReturn":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE[:-2]}{'^'*len(__LINE__)}")
        print(f"{__COLORS__['red']}Return has to be followed by something to return, if you are intending to return nothing, use {__COLORS__['yellow']}'return 0'{__COLORS__['red']} or {__COLORS__['yellow']}'return NULL'{__COLORS__['red']}{__COLORS__['reset']}")
    elif __ERROR__ == "CyclicIncludeError":
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE[:-2]}{'^'*len(__LINE__)}")
        print(f"{__COLORS__['red']}Circular include detected for {__COLORS__['yellow']}\"{__OPTIONAL__}\"{__COLORS__['red']}, this is not allowed{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}\nNOTE: This means that one of your files is trying to include itself, or another file that includes it. \n{__COLORS__['red']}(The shown module, is the last module that was checked and my not be right.){__COLORS__['reset']}")
    elif __ERROR__ == 'InvalidEnumType':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE.strip()}{__WHITESPACE_TYPE__*__WHITESPACE__} {'^'*len(__LINE_LIST__[0])}")
        print(f"{__COLORS__['red']}Invalid enum type, {__COLORS__['yellow']}\"{__LINE_LIST__[0]}\"{__COLORS__['red']} is not a valid enum type, Only valid enum types are {__COLORS__['yellow']}(int, str){__COLORS__['reset']}")
    elif __ERROR__ == 'IlligalChar':
        BOTTOM_LINE = mark_chars(__LINE__, __OPTIONAL__, BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}Illigal character {__COLORS__['yellow']}\"{__OPTIONAL__}\"{__COLORS__['red']} was used{__COLORS__['reset']}")
    elif __ERROR__ == 'ConstCallOutsideGlobal':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE.strip()}{__WHITESPACE_TYPE__*__WHITESPACE__} {'^'*len(__LINE_LIST__[0])}")
        print(f"{__COLORS__['red']}Cannot define a constant outside of the global scope.{__COLORS__['reset']}")
    elif __ERROR__ == 'TriedOverloadingGlobalOperator':
        BOTTOM_LINE = mark_chars(__LINE__, __OPTIONAL__, BOTTOM_LINE)
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}")
        print(f"{__COLORS__['red']}You can not overlaod the global operators, {__COLORS__['yellow']}\"{__OPTIONAL__}\"{__COLORS__['red']} is a global operator\n{__COLORS__['yellow']}NOTE: You can overload class operators only.{__COLORS__['reset']}")
    elif __ERROR__ == 'CanNotFixSize':
        BOTTOM_LINE = mark_chars(__LINE__, '*', BOTTOM_LINE).strip() + SPACE_CHAR * len(' '.join(__LINE_LIST__[1:-1]))
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{'^'*len(__LINE_LIST__[-1])}")
        print(f"{__COLORS__['red']}You can not fix the size of anything other than a list, {__COLORS__['yellow']}\"{__LINE_LIST__[0]}\"{__COLORS__['red']} is not a list{__COLORS__['reset']}")
    elif __ERROR__ == 'InvalidCopySyntax':
        print(f"{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE[:-2]}{'^'*len(__LINE__.strip())}")
        print(f"{__COLORS__['red']}Invalid copy syntax, syntax should look like: {__COLORS__['yellow']}\"copy var -> new_var\"{__COLORS__['reset']}")
    else:
        print(f"{__COLORS__['red']}{MIDDLE_LINE}")
        print(f"{BOTTOM_LINE}{__OPTIONAL__}")
        print(f"{__ERROR__}{__COLORS__['reset']}")
        if '-*- all errors -*-' in __OPTIANAL_ARGS_IN_FILE__:
            print(f"{__COLORS__['yellow']}NOTE: This last error was not generated by Versace, so the line marking may be incorrect.{__COLORS__['reset']}")
        else:
            print(f"{__COLORS__['yellow']}\nNOTE: This error was not generated by Versace, so the line marking may be incorrect.{__COLORS__['reset']}")
    if '-d' in __PASS_LIST__:
        from rich.pretty import pprint
        print(f"\n{__COLORS__['red']}{'-'*int((__TERMINAL_WIDTH__-12)/2)} DEBUG INFO {'-'*int((__TERMINAL_WIDTH__-11)/2)}")
        from rich.console import Console as rich_console
        rconsole = rich_console()
        rconsole.print(org_args_passed)
        if '-all' in __PASS_LIST__:
            __COLLECT_DATA__()
            from rich import console as cconsole; rich_print = cconsole.Console().print # Define the __O__CODE_PRINT__ variable
            console("")
            from rich.pretty import pprint
            from rich.syntax import Syntax
            print(f"{__COLORS__['red']}{'-'*int((__TERMINAL_WIDTH__-31)/2)} Original Data From File Passed {'-'*int((__TERMINAL_WIDTH__-31)/2)}")
            __OUTPUT__ = Syntax(''.join(__LINES_FROM_FILE_RAW__), "swift", theme="one-dark", line_numbers=True, background_color="default") # Define the __D__TOKENS__ variable
            rich_print(__OUTPUT__) # Print the __D__TOKENS__
            print(f"\n{__COLORS__['red']}{'-'*int((__TERMINAL_WIDTH__-33)/2)} Python Code Generated by Versace {'-'*int((__TERMINAL_WIDTH__-33)/2)}")
            __OUTPUT__ = Syntax('\n'.join(__FINAL_LIST__), "python", theme="one-dark", line_numbers=True, background_color="default") # Define the __D__TOKENS__ variable
            rich_print(__OUTPUT__) # Print the __D__TOKENS__
        print(f"{__COLORS__['red']}{'-'*int((__TERMINAL_WIDTH__))}{__COLORS__['reset']}")
        exit()
    if '-*- all errors -*-' in __OPTIANAL_ARGS_IN_FILE__: return
    else: exit(1)
def __GET_LINE_NUMBER__(__LINE__, MODE=None, RETURN_TYPE=0) -> str:
    """
    \n Gets the correct line number for the line from the original file.
    \n Outputs the line number or 'Line is not in file' if the line is not in the original file.
    \n Input: line - The line to get the line number for. (string)
    \n Output: line number - The line number of the line. (int)
    """
    if type(__LINE__) != str:
        __LINE__ = (''.join(__LINE__)).replace(' ', '')
    __LINE__ = __LINE__.strip().replace(' ', '')
    if '<INDENTATIONSEP>' in __LINE__: __LINE__ = __LINE__.replace('<INDENTATIONSEP>', '{')
    if '<DEDENTATIONSEP>' in __LINE__: __LINE__ = __LINE__.replace('<DEDENTATIONSEP>', '}')
    if __LINE__.endswith(';') == False:
        if __LINE__.endswith(('{', '}', '(', ')', '[', ']', ',')) == False:
            __LINE__ += ';'

    if MODE is None:
        for _I_ in __LINES_FROM_FILE_RAW__:
            if __LINE__ in _I_.strip().replace(' ', ''):
                __U__LINE__NUMBER__: int = __LINES_FROM_FILE_RAW__.index(_I_) + 1
                return __U__LINE__NUMBER__

    __SIMILARITY__: list[float] = []
    __SIMILAR_LINE__: list[int] = []

    for __I__ in range(len(__LINES_FROM_FILE_RAW__)):
        if len(__LINES_FROM_FILE_RAW__[__I__]) == 0:
            continue
        # remove all the spaces from the line
        __RATIO__: float = __APPROXIMATE_LINE__(__LINES_FROM_FILE_RAW__[__I__].replace(' ', '').strip(), __LINE__.strip())
        __SIMILARITY__.append(__RATIO__)
        __SIMILAR_LINE__.append(__I__ + 1)

    for __I__ in range(len(__SIMILARITY__)):
        if __SIMILARITY__[__I__] == max(__SIMILARITY__):
            if max(__SIMILARITY__) < 0.5:
                if RETURN_TYPE == 1: return f"{int(__SIMILAR_LINE__[__I__])}, {round(max(__SIMILARITY__), 2)*100}% Likely"
                return f"{int(__SIMILAR_LINE__[__I__])}"
            return int(__SIMILAR_LINE__[__I__])

    return 'Unknown'
def __APPROXIMATE_LINE__(__LINE_1__: str, __LINE_2__: str) -> int:
    """
    \n Compares two strings and returns the similarity percentage.
    \n Input: compare - The string to compare.
    \n        compare_to - The string to compare to.
    \n Output: The similarity percentage. (0.0 - 1.0)
    """
    from difflib import SequenceMatcher
    return SequenceMatcher(None, __LINE_1__, __LINE_2__).ratio()
@ASYNC
def __MAKE_ERROR_CODE__(ERROR):
    if isinstance(ERROR, str) is False:
        ERROR = str(ERROR)
    new_code = '0xE'
    for i in range(0, len(ERROR)):
        new_code += str(hex(ord(ERROR[i]))[2:]).upper()
    return new_code.strip()
@ASYNC
def __DECODE_ERROR_CODE__(ERROR):
    ERROR = ERROR.replace('0xE', '')
    ERROR = ERROR.lower()
    new_code = ''
    for i in range(0, len(ERROR), 2):
        new_code += chr(int(ERROR[i:i+2], 16))
    return new_code.strip()

# ------------------------ Misc Functions ------------------------ #
@ASYNC
def __DUMMY_CALL__(*args, **kwargs) -> None:
    """
    \n This function does nothing. It takes any number of arguments and returns nothing.
    """
    return
@ASYNC
def __LATCH__(__ITEM__: bool) -> bool:
    """
    \n This function is used to latch a boolean value.
    \n Input: __ITEM__ - The boolean value to latch.
    \n Output: The latched value.
    """
    return not __ITEM__
@MEMOIZE
def __BOX_PRINT__(text: str, text_color: str = 'green', box_color: str = 'green') -> None:
    print(f"{__COLORS__[box_color]}╭{'─'*(__TERMINAL_WIDTH__-2)}╮{__COLORS__['reset']}")
    # wrap the text
    text = wrap(text, __TERMINAL_WIDTH__-4)
    for line in text:
        print(f"{__COLORS__[box_color]}│ {__COLORS__[text_color]}{line}{__COLORS__[box_color]}{' '*((__TERMINAL_WIDTH__-len(line))-4)} │{__COLORS__['reset']}")
    print(f"{__COLORS__[box_color]}╰{'─'*(__TERMINAL_WIDTH__-2)}╯{__COLORS__['reset']}")

# ------------------------ Parser/Lexical Analysis Functions ------------------------ #
def __PARSER__(__BALANCE_IN__, __BALANCE_OUT__, __MISSING_DECLARATION__) -> None:
    global __FINAL_LIST__, __INDENTATION_COUNT__, __STATIC_FOR_CALLS__, __IN_STATIC_FOR__, __STATIC_FOR_LINE__
    __CURRENT_INDENTATION_COUNT__: list[int] = []
    __ADD__: bool = False
    __TRY__: int = 1
    for _INDEX_, _LINE_LIST_ in enumerate(__TOKENIZED_LIST__):
        __INDENTATION_LEVEL__ = 0
        #print(f"{__COLORS__['green']}Line {__GET_LINE_NUMBER__(' '.join(_LINE_LIST_))}: {__COLORS__['yellow']}{_LINE_LIST_}{__COLORS__['reset']}")
        #print(f"{str(mode):<7} |" , _INDEX_, '|', *_LINE_LIST_)
        for indexx, j in enumerate(_LINE_LIST_):
            # check if j is in private functions or private classes
            if __CHECK_IF_DELARED__(j, _LINE_LIST_[indexx], __TYPE__=1):
                _LINE_LIST_[indexx] = '__' + _LINE_LIST_[indexx]
            continue
        for index1, ii in enumerate(_LINE_LIST_):
            for iii in ii:
                if '\"' not in iii:
                    if __CHECK_IF_DELARED__(iii, ii, __TYPE__=0):
                        _LINE_LIST_[index1] = '__' + _LINE_LIST_[index1]
        for index, i in enumerate(_LINE_LIST_):
            #if i == '|' and _LINE_LIST_[index + 1] == '|':
            #    __FINAL_LIST__.append(' '.join(_LINE_LIST_).replace('||', ''))
            if i in __GLOBAL_VARIABLES__.__CHANGE_WORDS__:
                _LINE_LIST_[index] = __GLOBAL_VARIABLES__.__CHANGE_WORDS__[i]
            if i == '.':
                #try:
                if _LINE_LIST_[index - 1].isnumeric() is False and _LINE_LIST_[index + 1].isnumeric() is False:
                    __ERROR_REPORTING__(_LINE_LIST_, 'dotUsed')
                #except (NameError, SyntaxError):
                #    __ERROR_REPORTING__(_LINE_LIST_, 'dotUsed')
            if '::' in i:
                _LINE_LIST_[index] = i.replace('::', '.')

        if _LINE_LIST_[-1] == '++':
            _LINE_LIST_[-1] = '+='
            _LINE_LIST_.append('1')
        elif _LINE_LIST_[-1] == '--':
            _LINE_LIST_[-1] = '-='
            _LINE_LIST_.append('1')
        elif _LINE_LIST_[-1] == '**':
            _LINE_LIST_[-1] = '*='
            if _LINE_LIST_[0] == 'let': _LINE_LIST_.append(_LINE_LIST_[1])
            else: _LINE_LIST_.append(_LINE_LIST_[0])
        elif _LINE_LIST_[-1] == '//':
            _LINE_LIST_[-1] = '/='
            if _LINE_LIST_[0] == 'let': _LINE_LIST_.append(_LINE_LIST_[1])
            else: _LINE_LIST_.append(_LINE_LIST_[0])

        if _LINE_LIST_[0] == 'else' and _LINE_LIST_[1] == 'if':
            __LINE__ = __TOKENS__['else if'](_LINE_LIST_)      # <---------------------------------------------------- USING TOKEN
            if not isinstance(__LINE__, str): __LINE__ = ''
            __FINAL_LIST__.append(__LINE__.replace('<INDENTATIONSEP>', ':').replace('<DEDENTATIONSEP>', ''))
        elif _LINE_LIST_[0] in __TOKENS__:
            __LINE__ = __TOKENS__[_LINE_LIST_[0]](_LINE_LIST_) # <---------------------------------------------------- USING TOKEN
            if not isinstance(__LINE__, str): __LINE__ = ''
            __FINAL_LIST__.append(__LINE__.replace('<INDENTATIONSEP>', ':').replace('<DEDENTATIONSEP>', ''))
        else:
            if '=' in _LINE_LIST_:
                for i in __MISSING_DECLARATION__:
                    if i[0] == _LINE_LIST_[0]:
                        __MISSING_DECLARATION__.remove(i)
                if __CHECK_IF_DELARED__(_LINE_LIST_[0], _LINE_LIST_, 11, 'InvalidKeyword') is False:
                    __FINAL_LIST__.append('')
                __LINE__ = __SYNTAX_ANALYSIS__.__variable__.__VARIABLE__(_LINE_LIST_) # <------------------------------------ USING SYNTAX ANALYSIS
                __FINAL_LIST__.append(__LINE__.replace('<INDENTATIONSEP>', ':').replace('<DEDENTATIONSEP>', ''))
            else:
                __LINE__ = ' '.join(_LINE_LIST_).replace('<INDENTATIONSEP>', ':').replace('<DEDENTATIONSEP>', '')
                if not isinstance(__LINE__, str): __LINE__ = ''
                __FINAL_LIST__.append(__INDENTATION__ * __INDENTATION_COUNT__ + __LINE__)

        if len(__IN_STATIC_FOR__) != 0:
            __CURRENT_INDENTATION_COUNT__.append(__INDENTATION_COUNT__) if len(__CURRENT_INDENTATION_COUNT__) + 1 == __STATIC_FOR_CALLS__ else None

        if '-*- no indent -*-' not in __OPTIANAL_ARGS_IN_FILE__:
            __INDENTATION_LEVEL__ = 0
            if '<DEDENTATIONSEP>' in _LINE_LIST_:
                # count the number of <DEDENTATIONSEP> in the line
                __INDENTATION_LEVEL__ = _LINE_LIST_.count('<DEDENTATIONSEP>')
                # remove the <DEDENTATIONSEP> from the line
                __TOKENIZED_LIST__[_INDEX_][__TOKENIZED_LIST__[_INDEX_].index('<DEDENTATIONSEP>')] = ''
                # subtract the number of <DEDENTATIONSEP> from the __INDENTATION_COUNT__ variable
                __INDENTATION_COUNT__ -= __INDENTATION_LEVEL__

                for i in range(__INDENTATION_LEVEL__):
                    if len(__BALANCE_OUT__) > 0:
                        __BALANCE_OUT__.pop(-1)
                    __BALANCE_IN__.insert(0, _INDEX_)
            __INDENTATION_LEVEL__ = 0
            if '<INDENTATIONSEP>' in _LINE_LIST_:
                # count the number of <INDENTATIONSEP> in the line
                __INDENTATION_LEVEL__ = _LINE_LIST_.count('<INDENTATIONSEP>')
                # remove the <INDENTATIONSEP> from the line
                __TOKENIZED_LIST__[_INDEX_][__TOKENIZED_LIST__[_INDEX_].index('<INDENTATIONSEP>')] = ':'
                # add the number of <INDENTATIONSEP> to the __INDENTATION_COUNT__ variable
                __INDENTATION_COUNT__ += __INDENTATION_LEVEL__

                for i in range(__INDENTATION_LEVEL__):
                    if len(__BALANCE_IN__) > 0:
                        __BALANCE_IN__.pop(-1)
                    __BALANCE_OUT__.insert(0, _INDEX_)
        else: __INDENTATION_COUNT__ = 0
        if len(__IN_STATIC_FOR__) != 0:
            if __INDENTATION_COUNT__ == __CURRENT_INDENTATION_COUNT__[-1]:
                if 'main' not in __STATIC_FOR_LINE__[-1]:
                    __FINAL_LIST__.append((__INDENTATION__*(__CURRENT_INDENTATION_COUNT__[-1] + 1)) + __STATIC_FOR_LINE__[-1])
                else: __FINAL_LIST__.append((__INDENTATION__*(__CURRENT_INDENTATION_COUNT__[-1])) + __STATIC_FOR_LINE__[-1])
                if 'return' in __STATIC_FOR_LINE__[-1]:
                    __INDENTATION_COUNT__ -= 1
                    __FINAL_LIST__.pop(-1)
                    __FINAL_LIST__.append((__INDENTATION__*(__CURRENT_INDENTATION_COUNT__[-1])) + __STATIC_FOR_LINE__[-1])
                if 'update' in __STATIC_FOR_LINE__[-1]:
                    __INDENTATION_COUNT__ -= 1
                    __FINAL_LIST__.pop(-1)
                    __FINAL_LIST__.append(__STATIC_FOR_LINE__[-1])
                __CURRENT_INDENTATION_COUNT__.pop(-1)
                __IN_STATIC_FOR__.pop(-1)
                __STATIC_FOR_CALLS__ -= 1
                __STATIC_FOR_LINE__.pop(-1)

    for index, i in enumerate(__FINAL_LIST__):
        if '\\:' in i:
            __FINAL_LIST__[index] = i.replace('\\:', '::')
    return __BALANCE_IN__, __BALANCE_OUT__, __MISSING_DECLARATION__
def __LEXICAL_ANALYSIS__(mode = None, __INCLUDE_LIST__=None) -> int:
    global __FINAL_LIST__, __INDENTATION_COUNT__, __STATIC_FOR_CALLS__, __IN_STATIC_FOR__, __STATIC_FOR_LINE__
    __LINES_FROM_FILE_RAW_COPY__: list[str] = deepcopy(__LINES_FROM_FILE_RAW__)
    if __INCLUDE_LIST__ is None:
        global __TOKENIZED_LIST__
    else:
        __TOKENIZED_LIST__ = __INCLUDE_LIST__.copy()
    if __IN_INTREPRETED_MODE__:
        __FINAL_LIST__ = []
    _LINE_LIST_: list[str] = []
    __DO_NOTHING__ = False
    __IN_MULTI_LINE_COMMENT__: bool = False
    """
    This is the code that checks for missing semicolons, its absolutely horrible and needs to be fixed.
    """

    __CHARS_DONT_NEED_SEMI_COLON__: tuple = ( '{',  '}', '(', '[', ']', ',', '...')

    for index, i in enumerate(__LINES_FROM_FILE_RAW_COPY__):
        if __IN_MULTI_LINE_COMMENT__ :
            __LINES_FROM_FILE_RAW_COPY__[index] = ''
        for index2, j in enumerate(i):
            try:
                if j == '/' and i[index2+1] == '/':
                    __LINES_FROM_FILE_RAW_COPY__[index] = __LINES_FROM_FILE_RAW_COPY__[index][:index2]
                    break
                if j == '/' and i[index2+1] == '*':
                    __IN_MULTI_LINE_COMMENT__ = True
                    __LINES_FROM_FILE_RAW_COPY__[index] = ''
                if j == '*' and i[index2+1] == '/':
                    __IN_MULTI_LINE_COMMENT__ = False
                    __LINES_FROM_FILE_RAW_COPY__[index] = ''
                if __IN_MULTI_LINE_COMMENT__ :
                    __LINES_FROM_FILE_RAW_COPY__[index] = ''
                    break
            except IndexError: pass
    __LINES_FROM_FILE_RAW_COPY__ = [i.strip() for i in __LINES_FROM_FILE_RAW_COPY__ if i != '']
    if '-*- no newline -*-' in __OPTIANAL_ARGS_IN_FILE__:
        for index, i in enumerate(__LINES_FROM_FILE_RAW_COPY__):
            i = i.strip()
            if i == '':
                continue
            if i.startswith('[') and i.endswith(']'):
                continue
            elif i.endswith(';') is False and i.endswith(__CHARS_DONT_NEED_SEMI_COLON__) is False:
                if i.startswith('@') is False: __ERROR_REPORTING__(i, "MissingSemiColon")

    for _line_ in __TOKENIZED_LIST__:
        for i in _line_:
            if i.startswith("'") or i.endswith("'"):
                __ERROR_REPORTING__(_line_, "InvalidDelimeter")

    for _INDEX_, _LINE_ in enumerate(__TOKENIZED_LIST__):
        # if : ['float', 'a', '=', '5', '.', '5', ';'] then ['float', 'a', '=', '5.5', ';']
        for __INDEX__, __CHAR__ in enumerate(_LINE_):
            if __CHAR__ == '.':
                if _LINE_[__INDEX__-1].isnumeric() and _LINE_[__INDEX__+1].isnumeric():
                    _LINE_[__INDEX__-1] = _LINE_[__INDEX__-1] + _LINE_[__INDEX__] + _LINE_[__INDEX__+1]
                    _LINE_.pop(__INDEX__)
                    _LINE_.pop(__INDEX__)
                    __TOKENIZED_LIST__[_INDEX_] = _LINE_
                    break

    for _INDEX_, _LINE_ in enumerate(__TOKENIZED_LIST__):
        if '{' in _LINE_ and '}' in _LINE_:
            __DO_NOTHING__ = True
        else: __DO_NOTHING__ = False
        for __INDEX__, __CHAR__ in enumerate(_LINE_):
            if __CHAR__ == '{':
                # if { is equal to __CHAR__ then split the list at the index of __CHAR__
                # example : ['public', 'main', '()', '{', 'out', '<<', '<string>"Hello World!"', '<<', 'endl', ';<newline>', 'out', '<<', '<string>"Press any key to continue..."', '<<', 'endl', ';<newline>', '}']
                # becomes : ['public', 'main', '()', '{'] and ['out', '<<', '<string>"Hello World!"', '<<', 'endl', ';<newline>', 'out', '<<', '<string>"Press any key to continue..."', '<<', 'endl', ';<newline>', '}']
                if __DO_NOTHING__: continue
                __TOKENIZED_LIST__[_INDEX_] = _LINE_[:__INDEX__ + 1]
                __TOKENIZED_LIST__.insert(_INDEX_ + 1, _LINE_[__INDEX__ + 1:])
                break
            elif __CHAR__ == ';<newline>':
                __TOKENIZED_LIST__[_INDEX_] = _LINE_[:__INDEX__]
                __TOKENIZED_LIST__.insert(_INDEX_ + 1, _LINE_[__INDEX__ + 1:])
                break

    for _INDEX_, _LINE_LIST_ in enumerate(__TOKENIZED_LIST__):
        if '{' in _LINE_LIST_ and '}' in _LINE_LIST_: continue
        if '{' in _LINE_LIST_:
            # example line: ['public', 'main', '()', '{', 'out', '<<', '"Hello World!"', '<<', 'endl!']
            # becomes: ['public', 'main', '()', '<INDENTATIONSEP>', 'out', '<<', '"Hello World!"', '<<', 'endl!']
            __TOKENIZED_LIST__[_INDEX_].insert(__TOKENIZED_LIST__[_INDEX_].index('{') + 1, '<INDENTATIONSEP>')
            __TOKENIZED_LIST__[_INDEX_].remove('{')

        if '}' in _LINE_LIST_:
            # example line: ['public', 'main', '()', '<INDENTATIONSEP>', 'out', '<<', '"Hello World!"', '<<', 'endl!']
            # becomes: ['public', 'main', '()', '<INDENTATIONSEP>', 'out', '<<', '"Hello World!"', '<<', 'endl!', '<DEDENTATIONSEP>']
            __TOKENIZED_LIST__[_INDEX_].insert(__TOKENIZED_LIST__[_INDEX_].index('}') + 1, '<DEDENTATIONSEP>')
            __TOKENIZED_LIST__[_INDEX_].remove('}')

    __BALANCE_OUT__: list[str] = []
    __BALANCE_IN__: list[str] = []
    _INDEX_ = 0
    __MISSING_DECLARATION__: list[str] = []
    for _INDEX_, _LINE_ in enumerate(__TOKENIZED_LIST__):
        [__ERROR_REPORTING__(_LINE_, "IlligalChar", __CHAR__) for __INDEX__, __CHAR__ in enumerate(_LINE_) if __CHAR__ in __GLOBAL_VARIABLES__.__ILLIGAL_CHARS__]
        if '<DEDENTATIONSEP>' == _LINE_[0] or '<INDENTATIONSEP>' == _LINE_[0]:
            continue
        if _LINE_[0] in __TOKENS_T_ or _LINE_[0] in __GLOBAL_VARIABLES__.__DEF_CHARS__ or _LINE_[0] in tuple(__GLOBAL_VARIABLES__.__CHANGE_WORDS__.keys()):
            continue
        if _LINE_[0] in __GLOBAL_VARIABLES__.__ALL_PYTHON_KEYWORDS__ and __ALLOW_PYTHONIC_SYNTAX__:
            continue
        #__ERROR_REPORTING__(_LINE_, "InvalidKeyword")
        __MISSING_DECLARATION__.append((_LINE_[0], _INDEX_))
        if __IN_INTREPRETED_MODE__: return "remove"
        
    __BALANCE_IN__, __BALANCE_OUT__, __MISSING_DECLARATION__ = __PARSER__(__BALANCE_IN__, __BALANCE_OUT__, __MISSING_DECLARATION__)

    if __MISSING_DECLARATION__:
        for i in __MISSING_DECLARATION__:
            # check if the missing declarations are declared now
            __CHECK_IF_DELARED__(i[0], __TOKENIZED_LIST__[i[1]], 11, ERROR="InvalidKeyword")
    
    if mode == 'include': return __FINAL_LIST__
    if mode != 'include':
        if '-*- no main -*-' in __OPTIANAL_ARGS_IN_FILE__:
            pass
        else:
            if __PUBLIC_INIT_FOUND__ is False and __IN_INTREPRETED_MODE__ is False:
                try:
                    __ERROR_REPORTING__(__FINAL_LIST__[1], f"NoMain")
                except IndexError: __ERROR_REPORTING__(__FINAL_LIST__[0], f"NoMain")
    if __INDENTATION_COUNT__ != 0:
        for index, i in enumerate(__TOKENIZED_LIST__):
            if index in __BALANCE_OUT__:
                __ERROR_REPORTING__(' '.join(i).replace(':', '{', 1), 'NeverClosed')
                continue

    if mode != 'include':
        if __ERROR_REPORTING_CALLED__:
            if __IN_INTREPRETED_MODE__: return "remove"
            if '-f' in __PASS_LIST__: console(__FREEZE_COMMAND__)
            exit()
        for _INDEX_, _LINE_ in enumerate(__FINAL_LIST__):
            for index, char in enumerate(_LINE_):
                if char in ascii_letters and char in digits and char in punctuation and char in whitespace: continue
                if char in EMOJI_UNICODE: __FINAL_LIST__[_INDEX_] = _LINE_.replace(char, EMOJI_UNICODE[char])
        if __PUBLIC_CLOSE_FOUND__: __FINAL_LIST__.append('\nclose( "str", 321, {1:"1"}, 1)')
        # check if there is a diffrence between the original file data and the data that is going to be written to the file
        if '-c' in __PASS_LIST__:
            DEFAULT_MODE = {1:__1__, 2:__2__, 3:__3__}
            if __BINARY__ > 3 or __BINARY__ < 1:
                raise UnhandledException(f"The binary mode {__BINARY__} specified in the config file is not supported. Only (1, 2, 3) are supported.")
            if '-1' in __PASS_LIST__:
                __COMPILER__(__1__())
            elif '-2' in __PASS_LIST__:
                __COMPILER__(__2__())
            elif '-3' in __PASS_LIST__:
                __COMPILER__(__3__())
            else:
                __COMPILER__(DEFAULT_MODE[__BINARY__]())
        elif '-t' in __PASS_LIST__:
            __TRANSPILER__()
        else:
            __EXECUTION__()
        if __IN_INTREPRETED_MODE__:
            __FINAL_LIST__ = []
        return 0

# ----------------- Intrepreter ----------------- #
def __INTREPETER__(CODE=None) -> None:
    global __TOKENIZED_LIST__, __OPTIANAL_ARGS_IN_FILE__, __IN_INTREPRETED_MODE__, __LINES__, __LINES_FROM_FILE_RAW__, __TERMINAL_WIDTH__
    __IN_INTREPRETED_MODE__ = True
    __OPTIANAL_ARGS_IN_FILE__.append('-*- all errors -*-')
    __OPTIANAL_ARGS_IN_FILE__.append('-*- no main -*-')
    __PREVIOURLINES__ = []
    if not CODE:
        print(f"{__COLORS__['yellow']}Welcome to the Versace intrepreter!{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}Type {__COLORS__['red']}\"exit()\"{__COLORS__['yellow']} to exit the intrepreter.{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}Type {__COLORS__['red']}\"clear()\"{__COLORS__['yellow']} to clear the screen.{__COLORS__['reset']}")
        print(f"{__COLORS__['yellow']}Type {__COLORS__['red']}\"help\"{__COLORS__['yellow']}, {__COLORS__['red']}\"copyright\"{__COLORS__['yellow']}, {__COLORS__['red']}\"credits\"{__COLORS__['yellow']} or {__COLORS__['red']}\"license\"{__COLORS__['yellow']} for more information.{__COLORS__['reset']}")
    if CODE:
        __INDENT_COUNT__ = 0
        console("")
        __TERMINAL_WIDTH__ = get_terminal_size().columns
        __TOKENIZED_LIST__ = []
        print(f"{__COLORS__['green']}> {__COLORS__['reset']}", end='')
        line = CODE
        if line == 'exit()':
            exit()
        elif line == 'clear()':
            console(__CLEAR_SCREEN__)
            print(f"{__COLORS__['yellow']}You are using the Versace intrepreter{__COLORS__['reset']}")
            exit()
        elif line == 'help':
            __MISSALANEOUS__().__HELP_MENU__()
            exit()
        elif line == 'copyright':
            __MISSALANEOUS__().__COPYRIGHT__()
            exit()
        elif line == 'credits':
            __MISSALANEOUS__().__CREDITS__()
            exit()
        elif line == 'license':
            __MISSALANEOUS__().__LICENSE__()
            exit()
        if line.endswith(('{', '(', '[', ',', 'if', 'else', 'while', 'for', 'def', 'class')):
            __INDENT_COUNT__ += 1
            while True:
                try:
                    print(f"{__COLORS__['green']}. {__COLORS__['reset']}", end='')
                    line += input().strip()
                    if line.endswith(('{', '(', '[', ',', 'if', 'else', 'while', 'for', 'def', 'class','func','struct', 'enum', '{;', '(;', '[;', ',', 'if;', 'else;', 'while;', 'for;', 'func;', 'def;', 'struct;', 'enum;', 'class;')):
                        __INDENT_COUNT__ += 1
                    if line.endswith(('}', ')', ']', ',', 'if', 'else', 'while', 'for', 'def', 'class', 'func','struct', 'enum', '{;', '(;', '[;', ',', 'if;', 'else;', 'while;', 'for;', 'func;', 'def;', 'struct;', 'enum;', 'class;')):
                        __INDENT_COUNT__ -= 1
                    if __INDENT_COUNT__ == 0:
                        break
                    if __INDENT_COUNT__ < 0:
                        __ERROR_REPORTING__(line, "NeverClosed")
                        exit()
                except KeyboardInterrupt:
                    break
            if __INDENT_COUNT__ != 0:
                __ERROR_REPORTING__(line, "NeverClosed")
                exit()
        if len(__PREVIOURLINES__) > 0:
            if line == __PREVIOURLINES__[-1]:
                __PREVIOURLINES__.pop(-1)
        if line.endswith(';') != True:
            if line.endswith(('{', '(', '[', ',', 'if', 'else', 'while', 'for', 'def', 'class', 'func','struct', 'enum', '{;', '(;', '[;', ',', 'if;', 'else;', 'while;', 'for;', 'func;', 'def;', 'struct;', 'enum;', 'class;')) != True or line.endswith(('}', ')', ']', ',', 'if', 'else', 'while', 'for', 'def', 'class', 'func','struct', 'enum', '{;', '(;', '[;', ',', 'if;', 'else;', 'while;', 'for;', 'func;', 'def;', 'struct;', 'enum;', 'class;')) != True:
                __ERROR_REPORTING__(line, "MissingSemiColon")
                exit()
        __PREVIOURLINES__.append(line)
        __LINES__ = __PREVIOURLINES__.copy()
        __LINES_FROM_FILE_RAW__ = __PREVIOURLINES__.copy()
        if '-d' in __PASS_LIST__:
            _T_TOKENS_ = __TOKENS__.copy()
            __FOUND_VALID_TOKEN__ = False
            for token in _T_TOKENS_:
                if line.startswith(token):
                    _T_TOKENS_[token] = "Status 1"
                else:
                    _T_TOKENS_[token] = "Status 0"
            print(f"{__COLORS__['yellow']}Tokens:{__COLORS__['reset']}")
            print(f"{__COLORS__['bold red']}{{{__COLORS__['reset']}")
            for token in _T_TOKENS_:
                if _T_TOKENS_[token] == "Status 1":
                    __FOUND_VALID_TOKEN__ = True
                    print(f"    {__COLORS__['green']}{token}: {__COLORS__['reset']}Status 1")
                else:
                    print(f"    {__COLORS__['red']}{token}: {__COLORS__['reset']}Status 0")
            print(f"{__COLORS__['bold red']}}}{__COLORS__['reset']}")
            if __FOUND_VALID_TOKEN__ is False:
                print(f"{__COLORS__['red']}No valid matching token found.{__COLORS__['reset']}")
            else:
                print(f"{__COLORS__['green']}Valid matching token found.{__COLORS__['reset']}")
            exit()
        __SPLIT_ALL_LINES__()
        if __LEXICAL_ANALYSIS__() == 'remove':
            __PREVIOURLINES__.pop(-1)
            exit()
    if not CODE:
        while True:
            try:
                __INDENT_COUNT__ = 0
                console("")
                __TERMINAL_WIDTH__ = get_terminal_size().columns
                __TOKENIZED_LIST__ = []
                print(f"{__COLORS__['green']}> {__COLORS__['reset']}", end='')
                line = input().strip()
                if line == 'exit()':
                    exit()
                elif line == 'clear()':
                    console(__CLEAR_SCREEN__)
                    print(f"{__COLORS__['yellow']}You are using the Versace intrepreter{__COLORS__['reset']}")
                    continue
                elif line == 'help':
                    __MISSALANEOUS__().__HELP_MENU__()
                    continue
                elif line == 'copyright':
                    __MISSALANEOUS__().__COPYRIGHT__()
                    continue
                elif line == 'credits':
                    __MISSALANEOUS__().__CREDITS__()
                    continue
                elif line == 'license':
                    __MISSALANEOUS__().__LICENSE__()
                    continue
                if line.endswith(('{', '(', '[', ',', 'if', 'else', 'while', 'for', 'def', 'class')):
                    __INDENT_COUNT__ += 1
                    while True:
                        try:
                            print(f"{__COLORS__['green']}. {__COLORS__['reset']}", end='')
                            line += input().strip()
                            if line.endswith(('{', '(', '[', ',', 'if', 'else', 'while', 'for', 'def', 'class','func','struct', 'enum', '{;', '(;', '[;', ',', 'if;', 'else;', 'while;', 'for;', 'func;', 'def;', 'struct;', 'enum;', 'class;')):
                                __INDENT_COUNT__ += 1
                            if line.endswith(('}', ')', ']', ',', 'if', 'else', 'while', 'for', 'def', 'class', 'func','struct', 'enum', '{;', '(;', '[;', ',', 'if;', 'else;', 'while;', 'for;', 'func;', 'def;', 'struct;', 'enum;', 'class;')):
                                __INDENT_COUNT__ -= 1
                            if __INDENT_COUNT__ == 0:
                                break
                            if __INDENT_COUNT__ < 0:
                                __ERROR_REPORTING__(line, "NeverClosed")
                                continue
                        except KeyboardInterrupt:
                            break
                    if __INDENT_COUNT__ != 0:
                        __ERROR_REPORTING__(line, "NeverClosed")
                        continue
                if len(__PREVIOURLINES__) > 0:
                    if line == __PREVIOURLINES__[-1]:
                        __PREVIOURLINES__.pop(-1)
                if line.endswith(';') != True:
                    if line.endswith(('{', '(', '[', ',', 'if', 'else', 'while', 'for', 'def', 'class', 'func','struct', 'enum', '{;', '(;', '[;', ',', 'if;', 'else;', 'while;', 'for;', 'func;', 'def;', 'struct;', 'enum;', 'class;')) != True or line.endswith(('}', ')', ']', ',', 'if', 'else', 'while', 'for', 'def', 'class', 'func','struct', 'enum', '{;', '(;', '[;', ',', 'if;', 'else;', 'while;', 'for;', 'func;', 'def;', 'struct;', 'enum;', 'class;')) != True:
                        __ERROR_REPORTING__(line, "MissingSemiColon")
                        continue
                __PREVIOURLINES__.append(line)
                __LINES__ = __PREVIOURLINES__.copy()
                __LINES_FROM_FILE_RAW__ = __PREVIOURLINES__.copy()
                if '-d' in __PASS_LIST__:
                    _T_TOKENS_ = __TOKENS__.copy()
                    __FOUND_VALID_TOKEN__ = False
                    for token in _T_TOKENS_:
                        if line.startswith(token):
                            _T_TOKENS_[token] = "Status 1"
                        else:
                            _T_TOKENS_[token] = "Status 0"
                    print(f"{__COLORS__['yellow']}Tokens:{__COLORS__['reset']}")
                    print(f"{__COLORS__['bold red']}{{{__COLORS__['reset']}")
                    for token in _T_TOKENS_:
                        if _T_TOKENS_[token] == "Status 1":
                            __FOUND_VALID_TOKEN__ = True
                            print(f"    {__COLORS__['green']}{token}: {__COLORS__['reset']}Status 1")
                        else:
                            print(f"    {__COLORS__['red']}{token}: {__COLORS__['reset']}Status 0")
                    print(f"{__COLORS__['bold red']}}}{__COLORS__['reset']}")
                    if __FOUND_VALID_TOKEN__ is False:
                        print(f"{__COLORS__['red']}No valid matching token found.{__COLORS__['reset']}")
                    else:
                        print(f"{__COLORS__['green']}Valid matching token found.{__COLORS__['reset']}")
                    continue
                __SPLIT_ALL_LINES__()
                if __LEXICAL_ANALYSIS__() == 'remove':
                    __PREVIOURLINES__.pop(-1)
                    continue
            except KeyboardInterrupt:
                print(f'{__COLORS__["bold red"]}To exit the intrepreter, type "exit()"{__COLORS__["reset"]}')

# ----------------- Compiler Related Functions ----------------- #
@OVERLOAD(__1__)
def __COMPILER__(type: __1__) -> None:
    global __FINAL_LIST__, __PASS_LIST__, __IN_COMPILING__, __COMPILE_SAVE_PATH__
    if __SYSTEM__.path_exists(gettempdir() + path_sep + "compiled") is False:
        __SYSTEM__.make_dirs(gettempdir() + path_sep + "compiled")
    __TEMP_FILE__ = gettempdir() + path_sep + "compiled" + path_sep + f'{path.basename(__FILE_PATH__).split(".")[0]}.tmp'
    __PASS_LIST__.remove(__FILE_PATH__)
    __PASS_LIST__.remove('-c')
    __PASS_LIST__.remove('-1') if '-1' in __PASS_LIST__ else __PASS_LIST__
    __PASS_LIST__.pop(0)
    for i in __PASS_LIST__:
        if '.' in i:
            __TEMP_FILE__ = i
            break
    else:
        __TEMP_FILE__ = path.basename(__FILE_PATH__).split('.')[0]
    if '.' not in __TEMP_FILE__:
        __TEMP_FILE__ += __EXE_FILE_TYPE__
    if __SYSTEM__.get_c_dir() not in __TEMP_FILE__ and ':' not in __TEMP_FILE__:
        __TEMP_FILE__ = __SYSTEM__.get_c_dir() + path_sep + __TEMP_FILE__
    __COMPILE_SAVE_PATH__ = __TEMP_FILE__
    with open(gettempdir() + path_sep + "compiled" + path_sep + f'{path.basename(__TEMP_FILE__).split(".")[0]}.tmp', 'w', encoding="utf-8") as f:
        f.write(__LINE_0__().replace("with open(__file__, \'r\') as f:\n" + f"{__INDENTATION__*1}__THIS_FILE_DATA__ = f.readlines()\n", "__THIS_FILE_DATA__=['coding', 'GENERATED', 'Versace, https, Ze7111']\n") + '\n')
        f.write('\n'.join(__FINAL_LIST__))

    print(f"{__COLORS__['red']}Is this a window or console application? (w/c) : {__COLORS__['reset']}", end='')
    __WC_TYPE__ = input().lower().strip()

    print(f"{__COLORS__['red']}Enter icon path (leave blank if you do not want to use an icon): {__COLORS__['reset']}", end='')
    __ICON__ = input().strip().replace("\'", '\"')

    if __ICON__.strip() != '':
        __ICON__ = f'--icon {__ICON__}' if '\"' in __ICON__ else f'--icon "{__ICON__}"'
    else:
        __ICON__ = f'--icon "{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}base{path_sep}icon.ico"'

    if __WC_TYPE__ == 'w':
        __WC_TYPE__ = '--windowed'
    else:
        __WC_TYPE__ = '--console'

    __FINAL_COMMAND__: list[str] = ["pyinstaller", "--noconfirm", "--onefile", f'{__WC_TYPE__}', f"{__ICON__}", __TEMP_FILE__.replace(__SYSTEM__.get_c_dir() + path_sep, '')]
    __FINAL_COMMAND__ = [str(i) for i in __FINAL_COMMAND__ if i != '']

    __TIME_IT__ = get_time()
    __EXECUTE_COMPILE_COMMAND__(__FINAL_COMMAND__, MODE=2)
    __IN_COMPILING__ = True
    COUNT: int = 0
    print(f"{__COLORS__['green']}\nVersace Compiler Version: {__VERSION__}")
    while True:
        if __EXECUTNG__:
            print(f"{__COLORS__['red']}Compiling {COUNT} [{__COLORS__['red']}{'━'*COUNT}{__COLORS__['red']}]{__COLORS__['reset']}", end='\r')
            wait(0.5)
            COUNT += 1
        else:
            __TIME_IT__ = round(get_time() - __TIME_IT__, 3)
            break

    __IN_COMPILING__ = False

    print(f"{__COLORS__['red']}Compiling {COUNT} [{__COLORS__['green']}{'━'*COUNT}{__COLORS__['red']}]{__COLORS__['reset']}")
    print(f"{__COLORS__['red']}  Compilation completed in {__COLORS__['green']}{__TIME_IT__}{__COLORS__['red']} seconds. Using Optimizer: {__COLORS__['green']}One File (1){__COLORS__['reset']}")

    remove(gettempdir() + path_sep + "compiled" + path_sep + path.basename(__TEMP_FILE__).split('.')[0] + ".tmp")
    rmtree(__SYSTEM__.get_c_dir() + path_sep + "build" + path_sep + path.basename(__TEMP_FILE__).split('.')[0])

    for i in listdir(__SYSTEM__.get_c_dir() + path_sep + "dist"):
        move(__SYSTEM__.get_c_dir() + path_sep + "dist" + path_sep + i, __SYSTEM__.get_c_dir() + path_sep + i)

    if len(listdir(__SYSTEM__.get_c_dir() + path_sep + "dist")) == 0:
        rmtree(__SYSTEM__.get_c_dir() + path_sep + "dist")
    if len(listdir(__SYSTEM__.get_c_dir() + path_sep + "build")) == 0:
        rmtree(__SYSTEM__.get_c_dir() + path_sep + "build")
    if len(listdir(gettempdir() + path_sep + "compiled")) == 0:
        rmtree(gettempdir() + path_sep + "compiled")

    for i in listdir(__SYSTEM__.get_c_dir()):
        if i.endswith('.spec'):
            remove(i)
@OVERLOAD(__2__)
def __COMPILER__(type: __2__) -> None:
    global __FINAL_LIST__, __PASS_LIST__, __IN_COMPILING__, __COMPILE_SAVE_PATH__
    if __SYSTEM__.path_exists(gettempdir() + path_sep + "compiled") is False:
        __SYSTEM__.make_dirs(gettempdir() + path_sep + "compiled")
    __TEMP_FILE__ = gettempdir() + path_sep + "compiled" + path_sep + f'{path.basename(__FILE_PATH__).split(".")[0]}.tmp'
    __PASS_LIST__.remove(__FILE_PATH__)
    __PASS_LIST__.remove('-c')
    __PASS_LIST__.remove('-2') if '-2' in __PASS_LIST__ else __PASS_LIST__
    __PASS_LIST__.pop(0)
    for i in __PASS_LIST__:
        if '.' in i:
            __TEMP_FILE__ = i
            break
    else:
        __TEMP_FILE__ = path.basename(__FILE_PATH__).split('.')[0]
    if '.' not in __TEMP_FILE__:
        __TEMP_FILE__ += __EXE_FILE_TYPE__
    if __SYSTEM__.get_c_dir() not in __TEMP_FILE__ and ':' not in __TEMP_FILE__:
        __TEMP_FILE__ = __SYSTEM__.get_c_dir() + path_sep + __TEMP_FILE__
    __COMPILE_SAVE_PATH__ = __TEMP_FILE__
    with open(gettempdir() + path_sep + "compiled" + path_sep + f'{path.basename(__TEMP_FILE__).split(".")[0]}.tmp', 'w', encoding="utf-8") as f:
        f.write(__LINE_0__().replace("with open(__file__, \'r\') as f:\n" + f"{__INDENTATION__*1}__THIS_FILE_DATA__ = f.readlines()\n", "__THIS_FILE_DATA__=['coding', 'GENERATED', 'Versace, https, Ze7111']\n") + '\n')
        f.write('\n'.join(__FINAL_LIST__))

    print(f"{__COLORS__['red']}Is this a window or console application? (w/c) : {__COLORS__['reset']}", end='')
    __WC_TYPE__ = input().lower().strip()

    print(f"{__COLORS__['red']}Enter icon path (leave blank if you do not want to use an icon): {__COLORS__['reset']}", end='')
    __ICON__ = input().strip().replace("\'", '\"')

    if __ICON__.strip() != '':
        __ICON__ = f'--icon {__ICON__}' if '\"' in __ICON__ else f'--icon "{__ICON__}"'
    else:
        __ICON__ = f'--icon "{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}base{path_sep}icon.ico"'

    if __WC_TYPE__ == 'w':
        __WC_TYPE__ = '--windowed'
    else:
        __WC_TYPE__ = '--console'

    __FINAL_COMMAND__: list[str] = ["pyinstaller", "--noconfirm", "--onedir", f'{__WC_TYPE__}', f"{__ICON__}", __TEMP_FILE__.replace(__SYSTEM__.get_c_dir() + path_sep, '')]
    __FINAL_COMMAND__ = [str(i) for i in __FINAL_COMMAND__ if i != '']

    __TIME_IT__ = get_time()
    __EXECUTE_COMPILE_COMMAND__(__FINAL_COMMAND__, MODE=2)
    __IN_COMPILING__ = True
    COUNT: int = 0
    print(f"{__COLORS__['green']}\nVersace Compiler Version: {__VERSION__}")
    while True:
        if __EXECUTNG__:
            print(f"{__COLORS__['red']}Compiling {COUNT} [{__COLORS__['red']}{'━'*COUNT}{__COLORS__['red']}]{__COLORS__['reset']}", end='\r')
            wait(0.5)
            COUNT += 1
        else:
            __TIME_IT__ = round(get_time() - __TIME_IT__, 3)
            break

    __IN_COMPILING__ = False

    print(f"{__COLORS__['red']}Compiling {COUNT} [{__COLORS__['green']}{'━'*COUNT}{__COLORS__['red']}]{__COLORS__['reset']}")
    print(f"{__COLORS__['red']}  Compilation took {__COLORS__['green']}{__TIME_IT__}{__COLORS__['red']} seconds. Using Optimizer: {__COLORS__['green']}One Directory (2){__COLORS__['reset']}")

    remove(gettempdir() + path_sep + "compiled" + path_sep + path.basename(__TEMP_FILE__).split('.')[0] + ".tmp")
    rmtree(__SYSTEM__.get_c_dir() + path_sep + "build" + path_sep + path.basename(__TEMP_FILE__).split('.')[0])

    for i in listdir(__SYSTEM__.get_c_dir() + path_sep + "dist"):
        move(__SYSTEM__.get_c_dir() + path_sep + "dist" + path_sep + i, __SYSTEM__.get_c_dir() + path_sep + i)

    if len(listdir(__SYSTEM__.get_c_dir() + path_sep + "dist")) == 0:
        rmtree(__SYSTEM__.get_c_dir() + path_sep + "dist")
    if len(listdir(__SYSTEM__.get_c_dir() + path_sep + "build")) == 0:
        rmtree(__SYSTEM__.get_c_dir() + path_sep + "build")
    if len(listdir(gettempdir() + path_sep + "compiled")) == 0:
        rmtree(gettempdir() + path_sep + "compiled")

    for i in listdir(__SYSTEM__.get_c_dir()):
        if i.endswith('.spec'):
            remove(i)
@OVERLOAD(__3__)
def __COMPILER__(type: __3__) -> None:
    print(f"{__COLORS__['red']}This optimization level is broken (i am working on a fix), do you want to continue (y/n): {__COLORS__['reset']}", end='')
    __CONTINUE__ = input().lower().strip()
    if __CONTINUE__ != 'y':
        return
    global __FINAL_LIST__, __PASS_LIST__, __IN_COMPILING__, __COMPILE_SAVE_PATH__
    if __SYSTEM__.path_exists(gettempdir() + path_sep + "compiled") is False:
        __SYSTEM__.make_dirs(gettempdir() + path_sep + "compiled")
    __TEMP_FILE__ = gettempdir() + path_sep + "compiled" + path_sep + f'{path.basename(__FILE_PATH__).split(".")[0]}.tmp'
    __PASS_LIST__.remove(__FILE_PATH__)
    __PASS_LIST__.remove('-c')
    __PASS_LIST__.remove('-3') if '-3' in __PASS_LIST__ else __PASS_LIST__
    __PASS_LIST__.pop(0)
    for i in __PASS_LIST__:
        if '.' in i:
            __TEMP_FILE__ = i
            break
    else:
        __TEMP_FILE__ = path.basename(__FILE_PATH__).split('.')[0]
    if '.' not in __TEMP_FILE__:
        __TEMP_FILE__ += __EXE_FILE_TYPE__
    if __SYSTEM__.get_c_dir() not in __TEMP_FILE__ and ':' not in __TEMP_FILE__:
        __TEMP_FILE__ = __SYSTEM__.get_c_dir() + path_sep + __TEMP_FILE__
    __COMPILE_SAVE_PATH__ = __TEMP_FILE__
    with open(gettempdir() + path_sep + "compiled" + path_sep + f'{path.basename(__TEMP_FILE__).split(".")[0]}.tmp', 'w', encoding="utf-8") as f:
        f.write(__LINE_0__().replace("with open(__file__, \'r\') as f:\n" + f"{__INDENTATION__*1}__THIS_FILE_DATA__ = f.readlines()\n", "__THIS_FILE_DATA__=['coding', 'GENERATED', 'Versace, https, Ze7111']\n") + '\n')
        f.write('\n'.join(__FINAL_LIST__))

    print(f"{__COLORS__['red']}Is this a window or console application? (w/c) : {__COLORS__['reset']}", end='')
    __WC_TYPE__ = input().lower().strip()

    print(f"{__COLORS__['red']}Enter icon path (leave blank if you do not want to use an icon): {__COLORS__['reset']}", end='')
    __ICON__ = input().strip().replace("\'", "").replace('\"', "")

    print(f"{__COLORS__['red']}Enter version of the application (1.0.0): {__COLORS__['reset']}", end='')
    __VERSION__ = input().strip().replace("\'", "").replace('\"', "")

    print(f"{__COLORS__['red']}Enter description of the application (leave blank if you do not want to use a description): {__COLORS__['reset']}", end='')
    __DESCRIPTION__ = input().strip().replace("\'", "").replace('\"', "")

    if __ICON__.strip() != '':
        __ICON__ = f'{__ICON__}'
    else:
        __ICON__ = f'{__SYSTEM__.get_user_dir()}{path_sep}Versace{path_sep}base{path_sep}icon.ico'

    if __WC_TYPE__.strip() == 'w':
        __WC_TYPE__ = 'base=None\nif platform == \"win32\":\n\tbase=\"Win32GUI\"'
    else:
        __WC_TYPE__ = 'base=None'

    if __VERSION__.strip() == '':
        __VERSION__ = '1.0.0'

    if __DESCRIPTION__.strip() == '':
        __DESCRIPTION__ = 'None'

    __CX_FREEZE_DATA__: list = [
        "from cx_Freeze import setup, Executable; import sys, os",
        f"{__WC_TYPE__}",
        f"executables = [Executable(r\"{__TEMP_FILE__}\", base=base, target_name=r\"{path.basename(__TEMP_FILE__).split('.')[0]}\", icon=r\"{__ICON__}\")]",
        f"setup(name=r\"{path.basename(__TEMP_FILE__).split('.')[0]}\", version=r\"{__VERSION__}\", description=r\"{__DESCRIPTION__}\", executables=executables)"
    ]

    __CX_FREEZE_FILE__ = gettempdir() + path_sep + "compiled" + path_sep + 'setup.py'
    with open(__CX_FREEZE_FILE__, 'w', encoding="utf-8") as f:
        f.write('\n'.join(__CX_FREEZE_DATA__))
    print(gettempdir() + path_sep + "compiled" + path_sep + 'setup.py')
    __FINAL_COMMAND__ = [__ORG_PYTHON_PATH__, f"\"{__CX_FREEZE_FILE__}\"", "build"]
    __FINAL_COMMAND__ = [str(i) for i in __FINAL_COMMAND__ if i != '']
    __TIME_IT__ = get_time()
    __EXECUTE_COMPILE_COMMAND__(__FINAL_COMMAND__, MODE=2)
    __IN_COMPILING__ = True
    COUNT: int = 0
    print(f"{__COLORS__['green']}\nVersace Compiler Version: {__VERSION__}")
    while True:
        if __EXECUTNG__:
            print(f"{__COLORS__['red']}Compiling {COUNT} [{__COLORS__['red']}{'━'*COUNT}{__COLORS__['red']}]{__COLORS__['reset']}", end='\r')
            wait(0.5)
            COUNT += 1
        else:
            __TIME_IT__ = round(get_time() - __TIME_IT__, 3)
            break

    __IN_COMPILING__ = False

    print(f"{__COLORS__['red']}Compiling {COUNT} [{__COLORS__['green']}{'━'*COUNT}{__COLORS__['red']}]{__COLORS__['reset']}")
    print(f"{__COLORS__['red']}  Compilation took {__COLORS__['green']}{__TIME_IT__}{__COLORS__['red']} seconds. Using Optimizer: {__COLORS__['green']}Max Optimized (3){__COLORS__['reset']}")

    remove(gettempdir() + path_sep + "compiled" + path_sep + path.basename(__TEMP_FILE__).split('.')[0] + ".tmp")
@ASYNC
def __EXECUTE_COMPILE_COMMAND__(__FINAL_COMMAND__, MODE):
    global __EXECUTNG__
    if MODE == 3: exit()
    if __EXECUTNG__ is False:
        __EXECUTNG__ = True
        execute_no_output(' '.join(__FINAL_COMMAND__), stdout=DEVNULL, stderr=STDOUT)
        #execute(' '.join(__FINAL_COMMAND__))
        __EXECUTNG__ = False

# ------------------ Transpiler Related Functions ------------------ #
def __TRANSPILER__() -> None:
    global __FINAL_LIST__, __PASS_LIST__
    console("")
    __PASS_LIST__.remove(__FILE_PATH__)
    try:
        __SAVE_PATH__ = __PASS_LIST__[__PASS_LIST__.index('-t') + 1]
    except IndexError:
        raise UnhandledException("No path specified for the transpiled file.")
    __PASS_LIST__.remove('-t')
    if '.' not in __SAVE_PATH__:
        __SAVE_PATH__ += '.py'
    if __SYSTEM__.get_c_dir() not in __SAVE_PATH__:
        __SAVE_PATH__ = __SYSTEM__.get_c_dir() + path_sep + __SAVE_PATH__
    with open(__SAVE_PATH__, 'w', encoding="utf-8") as f:
        f.write(__LINE_0__() + '\n')
        f.write('\n'.join(__FINAL_LIST__))
    __BOX_PRINT__(f"Transpiled {path.basename(__FILE_PATH__)} to {__SAVE_PATH__}", 'green', 'green')

# ------------------- Runtime Related Functions ------------------- #
@MEMOIZE
def __EXECUTION__() -> None:
    global print
    # Import the NamedTemporaryFile and gettempdir functions from the tempfile module
    __EXEC_PATH__ = gettempdir() + fr'{path_sep}VERSACETEMP{path_sep}{path.basename(__FILE_PATH__)}.py'
    if __SYSTEM__.path_exists(gettempdir() + fr'{path_sep}VERSACETEMP') is False:
        __SYSTEM__.make_dirs(gettempdir() + fr'{path_sep}VERSACETEMP')
    with open(__EXEC_PATH__, 'w', encoding="utf-8") as f:
        f.write(__LINE_0__() + '\n')
        f.write('\n'.join(__FINAL_LIST__))
    if '-exec' in __PASS_LIST__:
        from ast import parse
        console("")
        tree = parse(open(__EXEC_PATH__).read())
        exec(compile(tree, filename=__EXEC_PATH__, mode='exec'), globals())
        print = base_print
    else: __SECURE_CODE_EXECUTION__([__PYTHON_PATH__, __EXEC_PATH__])
    return
def __SECURE_CODE_EXECUTION__(command) -> None:
    try:
        # get all errors from the execution
        from tempfile import NamedTemporaryFile
        error_file = NamedTemporaryFile(mode='w', delete=False)
        if '-ast' in __PASS_LIST__: command.insert(1, '-m'); command.insert(2, 'dis')
        try:
            execute(command, stderr=error_file, check=False)
        except KeyboardInterrupt: UnhandledException("Keyboard Interrupt Detected (Ctrl+C)")
        error_file.close()
        with open(error_file.name, 'r', encoding="utf-8") as f:
            errors = f.read()
        remove(error_file.name)
        if errors != '':
            errors = errors.splitlines()
            # invert the dict
            __INVERTED_DICT__ = {v: k for k, v in __GLOBAL_VARIABLES__.__CHANGE_WORDS__.items()}
            error_line = errors[-3].strip()
            for value in __INVERTED_DICT__:
                if value in error_line:
                    error_line = error_line.replace(value, __INVERTED_DICT__[value])
            error_line = __GET_LINE_NUMBER__(error_line, MODE='error')
            error_line_text = __LINES_FROM_FILE_RAW__[error_line-1].strip() if isinstance(error_line, int) else errors[-3].strip() + ' (Could not locate the exact line)'
            __ERROR_REPORTING__(error_line_text, errors[-1][errors[-1].find(':')+1:].strip(), errors[-2][4:], errors[-1][:errors[-1].find(':')+1], DEBUG_LINE=errors[-3].strip(), DEBUG_FILE=errors[0].strip())
            exit()
    except FileNotFoundError:
        raise UnhandledException('Execution failed, this could be caused by one or more of the following errors:\n\t- Python Path provided in the Config file is invalid.\n\t- Versace could not locate the transpiled file to execute.\n\t- The Cache File is curropted.')

# --------------------- Startup --------------------- #
@EXEC_TIME
def __INITIALIZER__() -> None:
    """
    This function is the main function of the program.
    It runs all the other functions and does all the other stuff.
    """
    #__GEN_NEW_SYNTAX_HIGHLIGHTING_DATA__() # uncomment this line to generate new syntax highlighting data, ONLY USE THIS IF YOU CHANGED THE TOKENS
    #__DECODE_ERROR_CODE__("0xE1242") # uncomment this line to decode an error code
    try:
        global __FILE_PATH__
        __INITIALIZE__()
        __READ_SYS_ARGS__()
        __INITIALIZE_CHECKS__()
        __INNIT_DATA_COLLECTOR__(__FILE_PATH__)
        __CHECK_ARGS__(__FILE_PATH__)
        mode = __OPEN_FILE__(__FILE_PATH__)
        if mode == "Empty":
            console("")
            print(__COLORS__["reset"], end="")
            if '-f' in __PASS_LIST__:
                console(__FREEZE_COMMAND__)
                exit()
            if '-d' in __PASS_LIST__:
                __COLLECT_DATA__()
                __SHOW_DEBUG_DATA__()
                __DUMP_DATA__()
            del globals()['__INITIALIZE__']
            del globals()['__READ_SYS_ARGS__']
            del globals()['__INITIALIZE_CHECKS__']
            del globals()['__INNIT_DATA_COLLECTOR__']
            del globals()['__CHECK_ARGS__']
            del globals()['__OPEN_FILE__']
            del globals()['__COLLECT_DATA__']
            del globals()['__SHOW_DEBUG_DATA__']
            del globals()['__DUMP_DATA__']
            return
        del mode
        __SPLIT_ALL_LINES__()
        #del globals()['__INITIALIZE__']
        #del globals()['__READ_SYS_ARGS__']
        #del globals()['__INITIALIZE_CHECKS__']
        #del globals()['__INNIT_DATA_COLLECTOR__']
        #del globals()['__CHECK_ARGS__']
        #del globals()['__OPEN_FILE__']
        __LEXICAL_ANALYSIS__()
        if '-d' in __PASS_LIST__:
            __COLLECT_DATA__()
            __SHOW_DEBUG_DATA__()
            __DUMP_DATA__()
    except KeyboardInterrupt:
        UnhandledException("Keyboard Interrupt Detected.", no_exit=True)
    except Exception as e:
        console("")
        # print the full traceback
        if '--debug' in __PASS_LIST__:
            from rich.console import Console as RichConsole
            rconsole = RichConsole()
            rconsole.print_exception(show_locals=True)
        else:
            print(f"{__COLORS__['red']}Unhandled Internal Exception: {e}{__COLORS__['reset']}")
    finally:
        console("")
        if __IN_COMPILING__:
            remove(gettempdir() + path_sep + "compiled" + path_sep + path.basename(__COMPILE_SAVE_PATH__).split('.')[0] + ".tmp")
            rmtree(__SYSTEM__.get_c_dir() + path_sep + "build" + path_sep + path.basename(__COMPILE_SAVE_PATH__).split('.')[0])

            for i in listdir(__SYSTEM__.get_c_dir() + path_sep + "dist"):
                move(__SYSTEM__.get_c_dir() + path_sep + "dist" + path_sep + i, __SYSTEM__.get_c_dir() + path_sep + i)

            if len(listdir(__SYSTEM__.get_c_dir() + path_sep + "dist")) == 0:
                rmtree(__SYSTEM__.get_c_dir() + path_sep + "dist")
            if len(listdir(__SYSTEM__.get_c_dir() + path_sep + "build")) == 0:
                rmtree(__SYSTEM__.get_c_dir() + path_sep + "build")
            if len(listdir(gettempdir() + path_sep + "compiled")) == 0:
                rmtree(gettempdir() + path_sep + "compiled")
            for i in listdir(__SYSTEM__.get_c_dir()):
                if i.endswith('.spec'):
                    remove(i)
        print(__COLORS__["reset"], end="")
        if '-f' in __PASS_LIST__:
            console(__FREEZE_COMMAND__)
            exit()

if '--test' in __PASS_LIST__:
    __TEST_MODE__()

# --------------------- Check if Imported or Runing Directly --------------------- #
if __name__ == "__main__":
    #from cProfile import run as cprun
    #cprun('__INITIALIZER__()', sort='time')
    __INITIALIZER__()
else:
    import sys
    def _VS(code):
        execute(f"{sys.executable} {__file__} -i \"{code}\"", shell=True, check=False)
